diff -crB --binary sbl6/segalib/dma/dma_cpum.c sbl6_patch/segalib/dma/dma_cpum.c
*** sbl6/segalib/dma/dma_cpum.c	1996-02-08 05:23:16.000000000 -0500
--- sbl6_patch/segalib/dma/dma_cpum.c	2021-11-14 20:07:08.000000000 -0500
***************
*** 39,44 ****
--- 39,45 ----
   * C VIRTUAL TYPES DEFINITIONS
   */
  #include "sega_xpt.h"
+ #include "sega_csh.h"
  
  /*
   * USER SUPPLIED INCLUDE FILES
***************
*** 371,374 ****
      return(DMA_CPU_END);                    /* 正常終了をリターン            */
  }
  
! 
\ No newline at end of file
--- 372,375 ----
      return(DMA_CPU_END);                    /* 正常終了をリターン            */
  }
  
! 
diff -crB --binary sbl6/segalib/dma/dma_scu1.c sbl6_patch/segalib/dma/dma_scu1.c
*** sbl6/segalib/dma/dma_scu1.c	1996-02-08 05:23:18.000000000 -0500
--- sbl6_patch/segalib/dma/dma_scu1.c	2021-11-14 20:08:26.000000000 -0500
***************
*** 35,40 ****
--- 35,41 ----
  /*
   * C STANDARD LIBRARY FUNCTIONS/MACROS DEFINES
   */
+ #include <string.h>
  
  /*
   * C VIRTUAL TYPES DEFINITIONS
***************
*** 238,241 ****
      }
  }
  
! 
\ No newline at end of file
--- 239,242 ----
      }
  }
  
! 
diff -crB --binary sbl6/segalib/gfs/gfs.c sbl6_patch/segalib/gfs/gfs.c
*** sbl6/segalib/gfs/gfs.c	2021-11-14 19:22:22.000000000 -0500
--- sbl6_patch/segalib/gfs/gfs.c	2021-11-14 20:53:32.000000000 -0500
***************
*** 28,33 ****
--- 28,34 ----
  #include    "gfs_dir.h"
  #include    "gfs_trn.h"
  #include    "gfs_cdc.h"
+ #include    "gfs_buf.h"
  
  
  #if !defined(USE_SGL)
diff -crB --binary sbl6/segalib/gfs/gfs_mmb.c sbl6_patch/segalib/gfs/gfs_mmb.c
*** sbl6/segalib/gfs/gfs_mmb.c	1996-02-08 05:23:36.000000000 -0500
--- sbl6_patch/segalib/gfs/gfs_mmb.c	2021-11-14 20:12:48.000000000 -0500
***************
*** 23,28 ****
--- 23,29 ----
  #include    "gfs_mmc.h"
  #include    "gfs_mmb.h"
  #include    "gfs_trn.h"
+ #include    "gfs_mmf.h"
  
  /*****************************************************************************
   *      定数マクロ
diff -crB --binary sbl6/segalib/include/sega_int.h sbl6_patch/segalib/include/sega_int.h
*** sbl6/segalib/include/sega_int.h	1996-02-08 05:23:46.000000000 -0500
--- sbl6_patch/segalib/include/sega_int.h	2021-11-21 17:42:34.000000000 -0500
***************
*** 170,175 ****
--- 170,177 ----
  #define INT_ACK_ENA         0x1         /* 有効                              */
  #define INT_ACK_DIS         0x0         /* 保持                              */
  
+ #define INT_SetScuFunc(num, hdr)    SYS_SETUINT(num, hdr)
+ 
  /******************************************************************************
   *
   * NAME:    INT_GetMsk()        -   割り込みマスクレジスタ取得
***************
*** 494,502 ****
  **	込みハンドラを登録する際に細工をするようにして、ユーザには、そんなこと
  **	は意識させないようにする。
  */
! void		INT_SetScuFunc( int	n, interrupt_t	handler );
  interrupt_t	INT_GetScuFunc( int	n );
  #endif
  
  #endif  /* ifndef SEGA_INT_H */
! 
\ No newline at end of file
--- 496,504 ----
  **	込みハンドラを登録する際に細工をするようにして、ユーザには、そんなこと
  **	は意識させないようにする。
  */
! //void		INT_SetScuFunc( int	n, interrupt_t	handler );
  interrupt_t	INT_GetScuFunc( int	n );
  #endif
  
  #endif  /* ifndef SEGA_INT_H */
! 
diff -crB --binary sbl6/segalib/include/sega_scl.h sbl6_patch/segalib/include/sega_scl.h
*** sbl6/segalib/include/sega_scl.h	1995-09-29 10:30:48.000000000 -0400
--- sbl6_patch/segalib/include/sega_scl.h	2021-04-21 19:17:26.000000000 -0400
***************
*** 1,1440 ****
! /*------------------------------------------------------------------------
!  *  FILE:	SEGA_SCL.H
!  *
!  *	Copyright(c) 1994 SEGA
!  *
!  *  PURPOSE:
!  *	Scroll Simulation program header file
!  *	Scroll Register Data Structure Definition File
!  *
!  *  AUTHOR(S):
!  *	K.M
!  *		
!  *  MOD HISTORY:
!  *	Written by K.M on 1994-05-20 Ver.1.00
!  *	Updated by K.M on 1994-07-01 Ver.1.00
!  * 
!  *------------------------------------------------------------------------
!  */
! 
! #ifndef	SEGA_SCR_H
! #define SEGA_SCR_H
! 
! #include <sega_xpt.h>
! #include <sega_def.h>
! #include <sega_mth.h> 
! 
! #define VBR              0x06000000
! #define SCU_BASE         0x25FE0000
! #define SCU_INTR_MASK    0x000000a0
! #define SCU_INTR_STATUS  0x000000a4
! #define SETUINT   ((Sint32 (*)()) *((Uint32*)(VBR+0x300)))
! #define GETUINT   ((Sint32 (*)()) *((Uint32*)(VBR+0x304)))
! #define SETSINT   ((Sint32 (*)()) *((Uint32*)(VBR+0x310)))
! #define GETSINT   ((Sint32 (*)()) *((Uint32*)(VBR+0x314)))
! #define VBIVN	0x40
! #define VBOVN	0x41
! #define HBIVN	0x42
! 
! /*********************************************
!  *      System Register Cluster	             *
!  *      Address ranger 180000H - 180027H     *
!  *********************************************/
!  typedef struct	SclSysreg{
! 	Uint16	tvmode;			/* TV Mode */
! 	Uint16	extenbl;		/* External Input Enable */
! 	Uint16	tvstatus;		/* TV Status Read Only */
! 	Uint16	vramsize;		/* VRAM Size */
! 	Uint16	H_val;			/* H Counter Read Only */
! 	Uint16	V_val;			/* V Counter Read Only */
! 	Uint16	vramchg;		/* VRAM Change */
! 	Uint16	ramcontrl;		/* RAM Control */
! 	Uint16	vramcyc[8];		/* VRAM Cycle Table x8 */
! 	Uint16	dispenbl;		/* Display Enable */
! 	Uint16	mosaic;			/* Mosaic Control */
! 	Uint16	specialcode_sel;	/* Special Code Selector */
! 	Uint16	specialcode;		/* Special Code */
!  } SclSysreg;
! 
! /**********************************************
!  *      Scroll Data Set Register Cluster      *
!  *      Address ranger 180028H - 18006FH      *
!  **********************************************/
! typedef struct SclDataset{
! 	Uint16	charcontrl0;		/* Character Control */
! 	Uint16	charcontrl1;		/* Character Control */
! 	Uint16	bmpalnum0;		/* Bitmap Palette Number */
! 	Uint16	bmpalnum1;		/* Bitmap Palette Number */
! 	Uint16	patnamecontrl[5];	/* Pattern Name Controlx5 */
! 	Uint16	platesize;		/* Plate Size */	
! 	Uint16	mapoffset0;		/* Map Offset */
! 	Uint16	mapoffset1;		/* Map Offset */
! 	Uint16	normap[8];		/* Normal Scroll Map x8*/
! 	Uint16	rotmap[16];		/* Rotate Scroll Map x16*/
! } SclDataset;
! 
! /***************************************************
!  *      Normal Scroll Function Register Cluster    *
!  *      Address ranger 180070H - 1800AFH           *
!  ***************************************************/
! typedef struct SclNorscl{
! 	Fixed32	n0_move_x;		/* NBG0 Scroll Movement X */
! 	Fixed32	n0_move_y;		/* NBG0 Scroll Movement Y */
! 	Fixed32	n0_delta_x;		/* NBG0 Scroll Movement X */
! 	Fixed32	n0_delta_y;		/* NBG0 Scroll Movement Y */
! 	Fixed32	n1_move_x;		/* NBG1 Scroll Movement X */
! 	Fixed32	n1_move_y;		/* NBG1 Scroll Movement Y */
! 	Fixed32	n1_delta_x;		/* NBG1 Scroll Movement X */
! 	Fixed32	n1_delta_y;		/* NBG1 Scroll Movement Y */
! 	Uint16	n2_move_x;		/* NBG2 Scroll Movement X */
! 	Uint16	n2_move_y;		/* NBG2 Scroll Movement Y */
! 	Uint16	n3_move_x;		/* NBG3 Scroll Movement X */
! 	Uint16	n3_move_y;		/* NBG3 Scroll Movement Y */
! 	Uint16	zoomenbl;		/* Zoom Enable */
! 	Uint16	linecontrl;		/* Normal Extension Control */
! 	Uint32	celladdr;		/* Cell Scroll Table Address */
! 	Uint32	lineaddr[2];		/* Line Scroll Table Address x2 */
! 	Uint32	linecolmode;		/* Line BG Color Mode Address */
! 	Uint32	backcolmode;		/* Back BG Color Mode Address */
! } SclNorscl;
! 
! /****************************************************
!  *      Rotate Scroll Function Register Cluster     *
!  *      Address ranger 1800B0H - 1800BFH            *
!  ****************************************************/
! typedef struct SclRotscl{
! 	Uint16	paramode;		/* Rotate Parameter Mode */
! 	Uint16	paramcontrl;		/* Rotate Parameter Read Control */
! 	Uint16	k_contrl;		/* Keisu Table Control */
! 	Uint16	k_offset;		/* Keisu Addres Offset */
! 	Uint16	mapover[2];		/* Rotate Scroll Map Over */
! 	Uint32	paramaddr;		/* Rotate Parameter Tabel Address */
! } SclRotscl;
! 
! /***************************************************
!  *      Window Scroll Setting Register Cluster     *
!  *      Address ranger 1800C0H - 1800DFH           *
!  ***************************************************/
! typedef struct SclWinscl{
! 					/* 1800C0 */
! 	Uint16	win0_start[2];		/* Window #0 Start X & Y */
! 					/* 1800C4 */
! 	Uint16	win0_end[2];		/* Window #0 End X & Y */
! 					/* 1800C8 */
! 	Uint16	win1_start[2];		/* Window #1 Start X & Y */
! 					/* 1800CC */
! 	Uint16	win1_end[2];		/* Window #1 End X & Y */
! 					/* 1800D0 */
! 	Uint16	wincontrl[4];		/* Window Control */
! 					/* 1800D8 */
! 	Uint32 	linewin0_addr;		/* Line Window #0 Table Address */ 
! 					/* 1800DC */
! 	Uint32 	linewin1_addr;		/* Line Window #1 Table Address */ 
! } SclWinscl;
! 
! /***********************************************
!  *      Priority Related Register Cluster      *
!  ***********************************************/
! typedef struct SclPrior{
! 	Uint16	prnum;
! } SclPrior;
! 
! 
! /**************************************************
!  *      Scroll Parameters Definition              *
!  **************************************************/
! typedef struct  SclXy {
! 	 Fixed32         x;
! 	 Fixed32         y;
! } SclXy;
! 
! typedef struct  SclXyz {
! 	 Fixed32         x;
! 	 Fixed32         y;
! 	 Fixed32         z;
! } SclXyz;
! 
! typedef struct  SclXy16 {
!         Uint16         x;
!         Uint16         y;
! } SclXy16;
! 
! typedef struct  SclXyz16 {
!         Sint16         x;
!         Sint16         y;
!         Sint16         z;
! } SclXyz16;
! 
! typedef struct  SclRgb {
! 	 Sint16		red;
! 	 Sint16		green;
! 	 Sint16		blue;
! } SclRgb;
! 
! typedef struct  SclLineTb {
! 	 Fixed32	h;
! 	 Fixed32	v;
! 	 Fixed32	dh;
! } SclLineTb;
! 
! typedef struct  SclLineWindowTb {
! 	 Uint16		start;
! 	 Uint16		end;
! } SclLineWindowTb;
! 
! typedef struct SclVramConfig{
! 	Uint32	ktboffsetA;/* 回転ﾊﾟﾗﾒｰﾀA用係数ﾃｰﾌﾞﾙをﾊﾞﾝｸ中のどこに配置するか */
! 	Uint32	ktboffsetB;/* 回転ﾊﾟﾗﾒｰﾀB用係数ﾃｰﾌﾞﾙをﾊﾞﾝｸ中のどこに配置するか */
! 	Uint8	vramModeA; /* VRAM A を２つのバンクに区切るか指定(0/1)  */
! 	Uint8	vramModeB; /* VRAM B を２つのバンクに区切るか指定(0/1)  */
! 	Uint8	vramA0;    /* VRAM A or A0 を回転面の何で使用するか指定 */
! 	Uint8	vramA1;    /* VRAM A1 を回転面の何で使用するか指定      */
! 	Uint8	vramB0;    /* VRAM B or B0 を回転面の何で使用するか指定 */
! 	Uint8	vramB1;    /* VRAM B1 を回転面の何で使用するか指定      */
! 	Uint8	colram;    /* カラーＲＡＭに係数データを置くか？        */
! } SclVramConfig;
! 
! typedef struct SclRotreg{
! 	SclXyz		screenst;
! 	SclXy		screendlt;
! 	SclXy		delta;
! 	Fixed32		matrix_a;
! 	Fixed32		matrix_b;
! 	Fixed32		matrix_c;
! 	Fixed32		matrix_d;
! 	Fixed32		matrix_e;
! 	Fixed32		matrix_f;
! 	SclXyz16	viewp;
! 	Uint16		dummy1;
! 	SclXyz16	rotatecenter;
! 	Uint16		dummy2;
! 	SclXy		move;
! 	SclXy		zoom;
! 	Fixed32		k_tab;
! 	SclXy		k_delta;
! /*	Fixed32		dummy3[8];	*/
! 	Fixed32		dummy3[2];
! } SclRotreg;
! 
! typedef struct SclRotparam{
! 	Uint32		addr;
! 	SclXyz		screenst;
! 	SclXy		screendlt;
! 	SclXy		delta;
! 	Fixed32		matrix_a;
! 	Fixed32		matrix_b;
! 	Fixed32		matrix_c;
! 	Fixed32		matrix_d;
! 	Fixed32		matrix_e;
! 	Fixed32		matrix_f;
! 	Fixed32		matrix_g;
! 	Fixed32		matrix_h;
! 	Fixed32		matrix_i;
! 	Fixed32		drotangle;
! 	SclXyz		viewp;
! 	SclXyz		rotatecenter;
! 	SclXyz		disprotcenter;
! 	SclXyz		move;
! 	SclXy		zoom;
! 	Fixed32		k_tab;
! 	SclXy		k_delta;
! 	Uint16		k_size;
! } SclRotparam;
! 
! /*******************************************
!  *      Scroll Configure Data Structure    *
!  *******************************************/
! typedef	struct	SclConfig {
! 	Uint8		dispenbl;
! 	Uint8		charsize;
! 	Uint8		pnamesize;
! 	Uint8		platesize;
! 	Uint8		bmpsize;
! 	Uint8		coltype;
! 	Uint8		datatype;
! 	Uint8		mapover;
! 	Uint8		flip;
! 	Uint16		patnamecontrl;
! /*	Uint32		plate_addr[16];		1995.9.29 cyoshida */
! 	Uint32		plate_addr[32];
! } SclConfig;
! 
! /******************************************************
!  *      Line & Cell Scroll Parameter Data Structure   *
!  ******************************************************/
! #define	SCL_MAXLINE	512
! #define	SCL_MAXCELL	64
! 
! typedef	struct	SclLineparam{
! 	Uint8		delta_enbl;
! 	Uint8		v_enbl;
! 	Uint8		h_enbl;
! 	Uint8		cell_enbl;
! 	Uint8		interval;
! 	Uint32		line_addr;
! 	Uint32		cell_addr;
! 	SclLineTb	line_tbl[SCL_MAXLINE];
! 	Fixed32		cell_tbl[SCL_MAXCELL];
! }	SclLineparam;
! 
! typedef	struct	SclLineWin{
! 	Uint16		winum;
! 	Uint16		y[2];
! 	Uint32		addr;
! 	SclXy16		tbl[SCL_MAXLINE];
! }	SclLineWin;
! 
! /***tuika c.yoshida******/
! 
! typedef	struct	SclSblSgl{
! 	Uint16		sgl_flag;
! }SclSblSgl;
! 
! /************************/
! 
! #define SCL_VDP2_VRAM		0x25e00000
! #define SCL_VDP2_VRAM_A		0x25e00000
! #define SCL_VDP2_VRAM_A0	0x25e00000
! #define SCL_VDP2_VRAM_A1	0x25e20000
! #define SCL_VDP2_VRAM_B		0x25e40000
! #define SCL_VDP2_VRAM_B0	0x25e40000
! #define SCL_VDP2_VRAM_B1	0x25e60000
! #define	SCL_COLRAM_ADDR		0x25F00000	/* Color RAM */
! 
! #define SCL_NON			0   /* RBG0では使用しない        */
! #define SCL_RBG0_K 		1   /* RBG0の係数ﾃｰﾌﾞﾙを置く     */
! #define SCL_RBG0_PN 		2   /* RBG0のﾊﾟﾀｰﾝﾈｰﾑﾃｰﾌﾞﾙを置く */
! #define SCL_RBG0_CHAR 		3   /* RBG0のｷｬﾗｸﾀを置く         */
! #define SCL_RBG1_K 		4   /* RBG1の係数ﾃｰﾌﾞﾙを置く     */
! 
! #define	SCL_CHAR_SIZE_1X1	0
! #define	SCL_CHAR_SIZE_2X2	1
! 
! #define	SCL_PN2WORD		0
! #define	SCL_PN1WORD		1
! 
! #define	SCL_PL_SIZE_1X1		0
! #define	SCL_PL_SIZE_2X1		1
! #define	SCL_PL_SIZE_2X2		3
! 
! #define	SCL_BMP_SIZE_512X256	0
! #define	SCL_BMP_SIZE_512X512	1
! #define	SCL_BMP_SIZE_1024X256	2
! #define	SCL_BMP_SIZE_1024X512	3
! 
! #define	SCL_COL_TYPE_16		0
! #define	SCL_COL_TYPE_256	1
! #define	SCL_COL_TYPE_2048	2
! #define	SCL_COL_TYPE_32K	3
! #define	SCL_COL_TYPE_1M		4
! 
! #define	SCL_CELL		0
! #define	SCL_BITMAP		1
! 
! #define	SCL_OVER_0		0
! #define	SCL_OVER_1		1
! #define	SCL_OVER_2		2
! #define	SCL_OVER_3		3
! 
! #define	SCL_PN_10BIT		0
! #define	SCL_PN_12BIT		1
! 
! #define	SCL_1_LINE		0
! #define	SCL_2_LINE		1
! #define	SCL_4_LINE		2
! 
! #define	SCL_NON_INTER		0
! #define	SCL_SINGLE_INTER	2
! #define	SCL_DOUBLE_INTER	3
! 
! #define	SCL_224LINE		0
! #define	SCL_240LINE		1
! #define	SCL_256LINE		2
! 
! #define	SCL_NORMAL_A		0
! #define	SCL_NORMAL_B		1
! #define	SCL_HIRESO_A		2
! #define	SCL_HIRESO_B		3
! #define	SCL_NORMAL_AE		4
! #define	SCL_NORMAL_BE		5
! #define	SCL_HIRESO_AE		6
! #define	SCL_HIRESO_BE		7
! 
! #define	SCL_X_AXIS		1
! #define	SCL_Y_AXIS		2
! 
! #define	SCL_W0			0
! #define	SCL_W1			1
! 
! #define FIXED(x)	      ((Fixed32)((x) * 65536.0))
! #define MUL_FIXED(a, b)       MTH_Mul(a, b)
! #define DIV_FIXED(a, b)       MTH_Div(a, b)
! 
! #endif	/* ifndef SEGA_SCR_H */
! 
! 
! /*------------------------------------------------------------------------
!  *  
!  *
!  *  DESCRIPTION:
!  *
!  *          Header file for Priority library internal use.
!  *          Each Macro Set a parameter on Register buffer.
!  *          the buffer will copy to REAL regster while V-interval.
!  *          ここにあるマクロは、レジスタバッファに各コントロール値を
!  *          書き込み、書き込んだレジスタバッファのダーティーフラグを
!  *          1 にする。
! -------------------------------------------------------------------------*/
! 
! #ifndef __PRI_GLVAR
! #define __PRI_GLVAR
! 
! #ifndef __PRI_MACRO
! #define __PRI_MACRO
! 
! #ifndef __PRI_REG
! #define __PRI_REG
! 
! /*-----< other group regs >----*/
! typedef struct {
!     Uint16 SpriteControl;		/* 1800E0 */
!     Uint16 ShadowControl;		/* 1800E2 */
!     Uint16 ColorRamOffset0;		/* 1800E4 */
!     Uint16 ColorRamOffset1;		/* 1800E6 */
!     Uint16 LineColorEnable;		/* 1800E8 */
!     Uint16 SpecialPriorityMode;		/* 1800EA */
!     Uint16 ColorMixControl;		/* 1800EC */
!     Uint16 SpecialColorMixMode;		/* 1800EE */
! } SclOtherPriRegister;
! 
! /*----< sprite priority >----*/
! typedef struct {
!     Uint16 PriorityNumberSP01;		/* 1800F0 */
!     Uint16 PriorityNumberSP23;		/* 1800F2 */
!     Uint16 PriorityNumberSP45;		/* 1800F4 */
!     Uint16 PriorityNumberSP67;		/* 1800F6 */
! } SclSpPriNumRegister;
! 
! /*----< scroll priority >----*/
! typedef struct {
!     Uint16 PriorityNumberNBG01;		/* 1800F8 */
!     Uint16 PriorityNumberNBG23;		/* 1800FA */
!     Uint16 PriorityNumberRBG0;		/* 1800FC */
! } SclBgPriNumRegister;
! 
! /*----< sprite color Mix >----*/
! typedef struct {
!     Uint16 ColMixRateSP01;		/* 180100 */
!     Uint16 ColMixRateSP23;		/* 180102 */
!     Uint16 ColMixRateSP45;		/* 180104 */
!     Uint16 ColMixRateSP67;		/* 180106 */
! } SclSpColMixRegister;
! 
! /*----< scroll color Mix >----*/
! typedef struct {
!     Uint16 ColMixRateNBG01;		/* 180108 */
!     Uint16 ColMixRateNBG23;		/* 18010A */
!     Uint16 ColMixRateRBG0;		/* 18010C */
!     Uint16 ColMixRateLCBAK;		/* 18010E */
! } SclBgColMixRegister;
! 
! /*----< color offset >----*/
! typedef struct {
!     Uint16 ColorOffsetEnable;		/* 180110 */
!     Uint16 ColorOffsetSelect;		/* 180112 */
!     Uint16 ColorOffsetA_RED;		/* 180114 */
!     Uint16 ColorOffsetA_GREEN;		/* 180116 */
!     Uint16 ColorOffsetA_BLUE;		/* 180118 */
!     Uint16 ColorOffsetB_RED;		/* 18011A */
!     Uint16 ColorOffsetB_GREEN;		/* 18011E */
!     Uint16 ColorOffsetB_BLUE;		/* 180120 */
! } SclColOffsetRegister;
! 
! /*---- レジスタバッファのダーティー・フラグ */
! typedef struct
! {
!     Uint32 SclOtherPri:1;
!     Uint32 SclSpPriNum:1;
!     Uint32 SclBgPriNum:1;
!     Uint32 SclSpColMix:1;
!     Uint32 SclBgColMix:1;
!     Uint32 SclColOffset:1;
! } SclPriBuffDirtyFlags;
! 
! #endif /* __PRI_REG */
! 
! 
! extern SclOtherPriRegister	SclOtherPri;
! extern SclSpPriNumRegister	SclSpPriNum;
! extern SclBgPriNumRegister	SclBgPriNum;
! extern SclSpColMixRegister	SclSpColMix;
! extern SclBgColMixRegister	SclBgColMix;
! extern SclColOffsetRegister	SclColOffset;
! extern SclPriBuffDirtyFlags	SclPriBuffDirty;
! 
! /* Following macros never check argument value range.*/
! 
! /* VDP-II manual p.129 */
! #define SCL_SET_SPCCCS(/* 2 bits */ spcccs) /* スプライト色演算条件 */\
!   (SclPriBuffDirty.SclOtherPri = 1,\
!    SclOtherPri.SpriteControl \
!    = (SclOtherPri.SpriteControl & 0x0FFF) | ((spcccs) << 12))
! 
! #define SCL_GET_SPCCCS() \
!   ((SclOtherPri.SpriteControl & 0x3000) >> 12)
! 
! #define SCL_SET_SPCCN(/* 3 bits */ spccn) /* スプライト色演算条件ナンバ */\
!   (SclPriBuffDirty.SclOtherPri = 1,\
!    SclOtherPri.SpriteControl \
!    = (SclOtherPri.SpriteControl & 0xF0FF) | ((spccn) << 8))
! 
! #define SCL_GET_SPCCN() \
!   ((SclOtherPri.SpriteControl & 0x0700) >> 8)
! 
! #define SCL_SET_SPCLMD(/* 1 bit */ spclmd) /* スプライトの色形式 */\
!   (SclPriBuffDirty.SclOtherPri = 1,\
!    SclOtherPri.SpriteControl \
!    = (SclOtherPri.SpriteControl & 0xFFDF) | ((spclmd) << 5))
! 
! #define SCL_GET_SPCLMD() \
!   ((SclOtherPri.SpriteControl & 0x0020) >> 5)
! 
! #define SCL_SET_SPWINEN(/* 1 bit */ spwinen) /* スプライトウィンドウイネーブル */\
!   (SclPriBuffDirty.SclOtherPri = 1,\
!    SclOtherPri.SpriteControl \
!    = (SclOtherPri.SpriteControl & 0xFFEF) | ((spwinen) << 4))    /* -> p.121 */
! 
! #define SCL_GET_SPWINEN() \
!   ((SclOtherPri.SpriteControl & 0x0010) >> 4)
! 
! #define SCL_SET_SPTYPE(/* 4bits */ sptype) /* スプライトのタイプ指定 */\
!   (SclPriBuffDirty.SclOtherPri = 1,\
!    SclOtherPri.SpriteControl \
!    = (SclOtherPri.SpriteControl & 0xFFF0) | (sptype))
! 
! #define SCL_GET_SPTYPE() \
!   (SclOtherPri.SpriteControl & 0x000F)
! 
! /* VDP-II manual p.131 */
! /*-------------------- スプライト用プライオリティレジスタ No.0-7 */
! 
! #define SCL_SET_S0PRIN(/* 3 bits */ s0prin) \
!   (SclPriBuffDirty.SclSpPriNum = 1,\
!    SclSpPriNum.PriorityNumberSP01 \
!    = (SclSpPriNum.PriorityNumberSP01 & 0xFFF0) | (s0prin))
! 
! #define SCL_GET_S0PRIN() \
!   ((SclSpPriNum.PriorityNumberSP01 & 0x0007))
! 
! #define SCL_SET_S1PRIN(/* 3 bits */ s1prin) \
!   (SclPriBuffDirty.SclSpPriNum = 1, \
!    SclSpPriNum.PriorityNumberSP01 \
!    = (SclSpPriNum.PriorityNumberSP01 & 0xF0FF) | ((s1prin) << 8))
! 
! #define SCL_GET_S1PRIN() \
!   ((SclSpPriNum.PriorityNumberSP01 & 0x0700) >> 8)
! 
! #define SCL_SET_S2PRIN(/* 3 bits */ s2prin) \
!   (SclPriBuffDirty.SclSpPriNum = 1, \
!    SclSpPriNum.PriorityNumberSP23 \
!    = (SclSpPriNum.PriorityNumberSP23 & 0xFFF0) | ((s2prin)))
! 
! #define SCL_GET_S2PRIN() \
!   ((SclSpPriNum.PriorityNumberSP23 & 0x0007))
! 
! #define SCL_SET_S3PRIN(/* 3 bits */ s3prin) \
!   (SclPriBuffDirty.SclSpPriNum = 1, \
!    SclSpPriNum.PriorityNumberSP23 \
!    = (SclSpPriNum.PriorityNumberSP23 & 0xF0FF) | ((s3prin) << 8))
! 
! #define SCL_GET_S3PRIN() \
!   ((SclSpPriNum.PriorityNumberSP23 & 0x0700) >> 8)
! 
! #define SCL_SET_S4PRIN(/* 3 bits */ s4prin) \
!   (SclPriBuffDirty.SclSpPriNum = 1, \
!    SclSpPriNum.PriorityNumberSP45 \
!    = (SclSpPriNum.PriorityNumberSP45 & 0xFFF0) | ((s4prin)))
! 
! #define SCL_GET_S4PRIN() \
!   ((SclSpPriNum.PriorityNumberSP45 & 0x0007))
! 
! #define SCL_SET_S5PRIN(/* 3 bits */ s5prin) \
!   (SclPriBuffDirty.SclSpPriNum = 1, \
!    SclSpPriNum.PriorityNumberSP45 \
!    = (SclSpPriNum.PriorityNumberSP45 & 0xF0FF) | ((s5prin) << 8))
! 
! #define SCL_GET_S5PRIN() \
!   ((SclSpPriNum.PriorityNumberSP45 & 0x0700) >> 8)
! 
! #define SCL_SET_S6PRIN(/* 3 bits */ s6prin) \
!   (SclPriBuffDirty.SclSpPriNum = 1, \
!    SclSpPriNum.PriorityNumberSP67 \
!    = (SclSpPriNum.PriorityNumberSP67 & 0xFFF0) | ((s6prin)))
! 
! #define SCL_GET_S6PRIN() \
!   ((SclSpPriNum.PriorityNumberSP67 & 0x0007))
! 
! #define SCL_SET_S7PRIN(/* 3 bits */ s7prin) \
!   (SclPriBuffDirty.SclSpPriNum = 1, \
!    SclSpPriNum.PriorityNumberSP67 \
!    = (SclSpPriNum.PriorityNumberSP67 & 0xF0FF) | ((s7prin) << 8))
! 
! #define SCL_GET_S7PRIN() \
!   ((SclSpPriNum.PriorityNumberSP67 & 0x0700) >> 8)
! 
! /* VDP-II manual p.132 */
! /*------------------- スプライト用カラー演算割合レジスタ No.0-7 */
! 
! #define SCL_SET_S0CCRT(/* 5bits */ s0ccrt) \
!   (SclPriBuffDirty.SclSpColMix = 1, \
!    SclSpColMix.ColMixRateSP01 \
!    = (SclSpColMix.ColMixRateSP01 & 0xFF00) | ((s0ccrt)))
! 
! #define SCL_GET_S0CCRT() \
!   ((SclSpColMix.ColMixRateSP01 & 0x001F) >> 0)
! 
! #define SCL_SET_S1CCRT(/* 5bits */ s1ccrt) \
!   (SclPriBuffDirty.SclSpColMix = 1, \
!    SclSpColMix.ColMixRateSP01 \
!    = (SclSpColMix.ColMixRateSP01 & 0x00FF) | ((s1ccrt) << 8))
! 
! #define SCL_GET_S1CCRT() \
!   ((SclSpColMix.ColMixRateSP01 & 0x1F00) >> 8)
! 
! #define SCL_SET_S2CCRT(/* 5bits */ s2ccrt) \
!   (SclPriBuffDirty.SclSpColMix = 1, \
!    SclSpColMix.ColMixRateSP23 \
!    = (SclSpColMix.ColMixRateSP23 & 0xFF00) | ((s2ccrt)))
! 
! #define SCL_GET_S2CCRT() \
!   ((SclSpColMix.ColMixRateSP23 & 0x001F))
! 
! #define SCL_SET_S3CCRT(/* 5bits */ s3ccrt) \
!   (SclPriBuffDirty.SclSpColMix = 1, \
!    SclSpColMix.ColMixRateSP23 \
!    = (SclSpColMix.ColMixRateSP23 & 0x00FF) | ((s3ccrt) << 8))
! 
! #define SCL_GET_S3CCRT() \
!   ((SclSpColMix.ColMixRateSP23 & 0x1F00) >> 8)
! 
! #define SCL_SET_S4CCRT(/* 5bits */ s4ccrt) \
!   (SclPriBuffDirty.SclSpColMix = 1, \
!    SclSpColMix.ColMixRateSP45 \
!    = (SclSpColMix.ColMixRateSP45 & 0xFF00) | ((s4ccrt)))
! 
! #define SCL_GET_S4CCRT() \
!   ((SclSpColMix.ColMixRateSP45 & 0x001F))
! 
! #define SCL_SET_S5CCRT(/* 5bits */ s5ccrt) \
!   (SclPriBuffDirty.SclSpColMix = 1, \
!    SclSpColMix.ColMixRateSP45 \
!    = (SclSpColMix.ColMixRateSP45 & 0x00FF) | ((s5ccrt) << 8))
! 
! #define SCL_GET_S5CCRT() \
!   ((SclSpColMix.ColMixRateSP45 & 0x1F00) >> 8)
! 
! #define SCL_SET_S6CCRT(/* 5bits */ s6ccrt) \
!   (SclPriBuffDirty.SclSpColMix = 1, \
!    SclSpColMix.ColMixRateSP67 \
!    = (SclSpColMix.ColMixRateSP67 & 0xFF00) | ((s6ccrt)))
! 
! #define SCL_GET_S6CCRT() \
!   ((SclSpColMix.ColMixRateSP67 & 0x001F))
! 
! #define SCL_SET_S7CCRT(/* 5bits */ s7ccrt) \
!   (SclPriBuffDirty.SclSpColMix = 1, \
!    SclSpColMix.ColMixRateSP67 \
!    = (SclSpColMix.ColMixRateSP67 & 0x00FF) | ((s7ccrt) << 8))
! 
! #define SCL_GET_S7CCRT() \
!   ((SclSpColMix.ColMixRateSP67 & 0x1F00) >> 8)
! 
! /* VDP-II manual p.138 */
! /*-- カラー RAM アドレスオフセット N0|R1, N1|EXBG, N2, N3, R0, SPRITE */
! 
! #define SCL_SET_N0CAOS(/* 3bits */ n0caos) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorRamOffset0 \
!    = (SclOtherPri.ColorRamOffset0 & 0xFFF0) | ((n0caos)))
! 
! #define SCL_GET_N0CAOS() \
!   ((SclOtherPri.ColorRamOffset0 & 0x0007))
! 
! #define SCL_SET_N1CAOS(/* 3bits */ n1caos) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorRamOffset0 \
!    = (SclOtherPri.ColorRamOffset0 & 0xFF0F) | ((n1caos) << 4))
! 
! #define SCL_GET_N1CAOS() \
!   ((SclOtherPri.ColorRamOffset0 & 0x0070) >> 4)
! 
! #define SCL_SET_N2CAOS(/* 3bits */ n2caos) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorRamOffset0 \
!    = (SclOtherPri.ColorRamOffset0 & 0xF0FF) | ((n2caos) << 8))
! 
! #define SCL_GET_N2CAOS() \
!   ((SclOtherPri.ColorRamOffset0 & 0x0700) >> 8)
! 
! #define SCL_SET_N3CAOS(/* 3bits */ n3caos) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorRamOffset0 \
!    = (SclOtherPri.ColorRamOffset0 & 0x0FFF) | ((n3caos) << 12))
! 
! #define SCL_GET_N3CAOS() \
!   ((SclOtherPri.ColorRamOffset0 & 0x7000) >> 12)
! 
! #define SCL_SET_R0CAOS(/* 3bits */ r0caos) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorRamOffset1 \
!    = (SclOtherPri.ColorRamOffset1 & 0xFFF0) | ((r0caos) << 0))
! 
! #define SCL_GET_R0CAOS() \
!   ((SclOtherPri.ColorRamOffset1 & 0x0007) >> 0)
! 
! #define SCL_SET_SPCAOS(/* 3bits */ spcaos) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorRamOffset1 \
!    = (SclOtherPri.ColorRamOffset1 & 0xFF0F) | ((spcaos) << 4))
! 
! #define SCL_GET_SPCAOS() \
!   ((SclOtherPri.ColorRamOffset1 & 0x0070) >> 4)
! 
! 
! /*----- ラインカラー画面イネーブル N0|R1, N1|EXBG, N2, N3, R0, SPRITE */
! 
! #define SCL_SET_N0LCEN(/* 1bit */ n0lcen) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.LineColorEnable \
!    = (SclOtherPri.LineColorEnable & 0xFFFE) | ((n0lcen)))
! 
! #define SCL_GET_N0LCEN() \
!   ((SclOtherPri.LineColorEnable & 0x0001))
! 
! #define SCL_SET_N1LCEN(/* 1bit */ n1lcen) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.LineColorEnable \
!    = (SclOtherPri.LineColorEnable & 0xFFFD) | ((n1lcen) << 1))
! 
! #define SCL_GET_N1LCEN() \
!   ((SclOtherPri.LineColorEnable & 0x0002) >> 1)
! 
! #define SCL_SET_N2LCEN(/* 1bit */ n2lcen) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.LineColorEnable \
!    = (SclOtherPri.LineColorEnable & 0xFFFB) | ((n2lcen) << 2))
! 
! #define SCL_GET_N2LCEN() \
!   ((SclOtherPri.LineColorEnable & 0x0004) >> 2)
! 
! #define SCL_SET_N3LCEN(/* 1bit */ n3lcen) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.LineColorEnable \
!    = (SclOtherPri.LineColorEnable & 0xFFF7) | ((n3lcen) << 3))
! 
! #define SCL_GET_N3LCEN() \
!   ((SclOtherPri.LineColorEnable & 0x0008) >> 3)
! 
! #define SCL_SET_R0LCEN(/* 1bit */ r0lcen) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.LineColorEnable \
!    = (SclOtherPri.LineColorEnable & 0xFFEF) | ((r0lcen) << 4))
! 
! #define SCL_GET_R0LCEN() \
!   ((SclOtherPri.LineColorEnable & 0x0010) >> 4)
! 
! #define SCL_SET_SPLCEN(/* 1bit */ splcen) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.LineColorEnable \
!    = (SclOtherPri.LineColorEnable & 0xFFDF) | ((splcen) << 5))
! 
! #define SCL_GET_SPLCEN() \
!   ((SclOtherPri.LineColorEnable & 0x0020) >> 5)
! 
! /*-------- 特殊プライオリティモード N0|R1, N1|EXBG, N2, N3, R0 */
! 
! #define SCL_SET_N0SPRM(/* 2bits */ n0sprm) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.SpecialPriorityMode \
!    = (SclOtherPri.SpecialPriorityMode & 0xFFFC) | ((n0sprm)))
! 
! #define SCL_GET_N0SPRM() \
!   ((SclOtherPri.SpecialPriorityMode & 0x0003))
! 
! #define SCL_SET_N1SPRM(/* 2bits */ n1sprm) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.SpecialPriorityMode \
!    = (SclOtherPri.SpecialPriorityMode & 0xFFF3) | ((n1sprm) << 2))
! 
! #define SCL_GET_N1SPRM() \
!   ((SclOtherPri.SpecialPriorityMode & 0x000C) >> 2)
! 
! #define SCL_SET_N2SPRM(/* 2bits */ n2sprm) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.SpecialPriorityMode \
!    = (SclOtherPri.SpecialPriorityMode & 0xFFCF) | ((n2sprm) << 4))
! 
! #define SCL_GET_N2SPRM() \
!   ((SclOtherPri.SpecialPriorityMode & 0x0030) >> 4)
! 
! #define SCL_SET_N3SPRM(/* 2bits */ n3sprm) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.SpecialPriorityMode \
!    = (SclOtherPri.SpecialPriorityMode & 0xFF3F) | ((n3sprm) << 6))
! 
! #define SCL_GET_N3SPRM() \
!   ((SclOtherPri.SpecialPriorityMode & 0x00C0) >> 6)
! 
! #define SCL_SET_R0SPRM(/* 2bits */ r0sprm) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.SpecialPriorityMode \
!    = (SclOtherPri.SpecialPriorityMode & 0xFCFF) | ((r0sprm) << 8))
! 
! #define SCL_GET_R0SPRM() \
!   ((SclOtherPri.SpecialPriorityMode & 0x0300) >> 8)
! 
! /*---------プライオリティー番号 N0|R1, N1|EXBG, N2, N3, R0 */
! 
! #define SCL_SET_N0PRIN(/* 3 bits */ n0prin) \
!   (SclPriBuffDirty.SclBgPriNum = 1, \
!    SclBgPriNum.PriorityNumberNBG01 \
!    = (SclBgPriNum.PriorityNumberNBG01 & 0xFF00) | ((n0prin)))
! 
! #define SCL_GET_N0PRIN() \
!   ((SclBgPriNum.PriorityNumberNBG01 & 0x0007))
! 
! #define SCL_SET_N1PRIN(/* 3 bits */ n1prin) \
!   (SclPriBuffDirty.SclBgPriNum = 1, \
!    SclBgPriNum.PriorityNumberNBG01 \
!    = (SclBgPriNum.PriorityNumberNBG01 & 0x00FF) | ((n1prin) << 8))
! 
! #define SCL_GET_N1PRIN() \
!   ((SclBgPriNum.PriorityNumberNBG01 & 0x0700) >> 8)
! 
! #define SCL_SET_N2PRIN(/* 3 bits */ n2prin) \
!   (SclPriBuffDirty.SclBgPriNum = 1, \
!    SclBgPriNum.PriorityNumberNBG23 \
!    = (SclBgPriNum.PriorityNumberNBG23 & 0xFF00) | ((n2prin)))
! 
! #define SCL_GET_N2PRIN() \
!   ((SclBgPriNum.PriorityNumberNBG23 & 0x0007))
! 
! #define SCL_SET_N3PRIN(/* 3 bits */ n3prin) \
!   (SclPriBuffDirty.SclBgPriNum = 1, \
!    SclBgPriNum.PriorityNumberNBG23 \
!    = (SclBgPriNum.PriorityNumberNBG23 & 0x00FF) | ((n3prin) << 8))
! 
! #define SCL_GET_N3PRIN() \
!   ((SclBgPriNum.PriorityNumberNBG23 & 0x0700) >> 8)
! 
! #define SCL_SET_R0PRIN(/* 3 bits */ r0prin) \
!   (SclPriBuffDirty.SclBgPriNum = 1, \
!    SclBgPriNum.PriorityNumberRBG0 \
!    = ((r0prin)))
! 
! #define SCL_GET_R0PRIN() \
!    ((SclBgPriNum.PriorityNumberRBG0 & 0x0007))
! 
! #define SCL_SET_BOKEN(/* 1 bits */ boken) /* ボカシ演算イネーブル */\
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorMixControl \
!    = (SclOtherPri.ColorMixControl & 0x7FFF) | ((boken) << 15))
! 
! #define SCL_GET_B0KEN() \
!   ((SclOtherPri.ColorMixControl & 0x8000) >> 15)
! 
! #define SCL_SET_BOKN(/* 3 bits */ bokn) /* ボカシ画面番号 */\
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorMixControl \
!    = (SclOtherPri.ColorMixControl & 0x8FFF) | ((bokn) << 12))
! 
! #define SCL_GET_BOKN() \
!   ((SclOtherPri.ColorMixControl & 0x7000) >> 12)
! 
! #define SCL_SET_EXCCEN(/* 1 bit */ exccn) /* 拡張カラー演算イネーブル */\
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorMixControl \
!    = (SclOtherPri.ColorMixControl & 0xFBFF) | ((exccn) << 10))
! 
! #define SCL_GET_EXCCEN() \
!   ((SclOtherPri.ColorMixControl & 0x0400) >> 10)
! 
! #define SCL_SET_CCRTMD(/* 1 bit */ ccrtmd) /* カラー演算割合モード */\
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorMixControl \
!    = (SclOtherPri.ColorMixControl & 0xFDFF) | ((Uint32)(ccrtmd) << 9))
! 
! #define SCL_GET_CCRTMD() \
!   ((SclOtherPri.ColorMixControl & 0x0200) >> 9)
! 
! #define SCL_SET_CCMD(/* 1 bit */ ccmd) /* カラー演算モード */\
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorMixControl \
!    = (SclOtherPri.ColorMixControl & 0xFEFF) | ((Uint32)(ccmd) << 8))
! 
! #define SCL_GET_CCMD() \
!   ((SclOtherPri.ColorMixControl & 0x0100) >> 8)
! 
! /*------ カラー演算イネーブル N0|R1, N1|EXBG, N2, N3, R0, LC, SPRITE */ 
! #define SCL_SET_SPCCEN(/* 1 bit */ spccen) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorMixControl \
!    = (SclOtherPri.ColorMixControl & 0xFFBF) | ((spccen) << 6))
! 
! #define SCL_GET_SPCCEN() \
!   ((SclOtherPri.ColorMixControl & 0x0040) >> 6)
! 
! #define SCL_SET_LCCCEN(/* 1 bit */ lcccen) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorMixControl \
!    = (SclOtherPri.ColorMixControl & 0xFFDF) | ((lcccen) << 5))
! 
! #define SCL_GET_LCCCEN() \
!   ((SclOtherPri.ColorMixControl & 0x0020) >> 5)
! 
! #define SCL_SET_R0CCEN(/* 1 bit */ r0ccen) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorMixControl \
!    = (SclOtherPri.ColorMixControl & 0xFFEF) | ((r0ccen) << 4))
! 
! #define SCL_GET_R0CCEN() \
!   ((SclOtherPri.ColorMixControl & 0x0010) >> 4)
! 
! #define SCL_SET_N3CCEN(/* 1 bit */ n3ccen) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorMixControl \
!    = (SclOtherPri.ColorMixControl & 0xFFF7) | ((n3ccen) << 3))
! 
! #define SCL_GET_N3CCEN() \
!   ((SclOtherPri.ColorMixControl & 0x0008) >> 3)
! 
! #define SCL_SET_N2CCEN(/* 1 bit */ n2ccen) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorMixControl \
!    = (SclOtherPri.ColorMixControl & 0xFFFB) | ((n2ccen) << 2))
! 
! #define SCL_GET_N2CCEN() \
!   ((SclOtherPri.ColorMixControl & 0x0004) >> 2)
! 
! #define SCL_SET_N1CCEN(/* 1 bit */ n1ccen) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorMixControl \
!    = (SclOtherPri.ColorMixControl & 0xFFFD) | ((n1ccen) << 1))
!   
! #define SCL_GET_N1CCEN() \
!   ((SclOtherPri.ColorMixControl & 0x0002) >> 1)
! 
! #define SCL_SET_N0CCEN(/* 1 bit */ n0ccen) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorMixControl \
!    = (SclOtherPri.ColorMixControl & 0xFFFE) | ((n0ccen)))
! 
! #define SCL_GET_N0CCEN() \
!   ((SclOtherPri.ColorMixControl & 0x0001))
! 
! 
! /*-------------- 特殊カラー演算モード N0|R1, N1|EXBG, N2, N3, R0 */
! #define SCL_SET_N0SCCM(/* 2 bits */ n0sccm) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.SpecialColorMixMode \
!    = (SclOtherPri.SpecialColorMixMode & 0xFFFC) | ((n0sccm)))
! 
! #define SCL_GET_N0SCCM() \
!   ((SclOtherPri.SpecialColorMixMode & 0x0003))
! 
! #define SCL_SET_N1SCCM(/* 2 bits */ n1sccm) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.SpecialColorMixMode \
!    = (SclOtherPri.SpecialColorMixMode & 0xFFF3) | ((n1sccm) << 2))
! 
! #define SCL_GET_N1SCCM() \
!   ((SclOtherPri.SpecialColorMixMode & 0x000C) >> 2)
! 
! #define SCL_SET_N2SCCM(/* 2 bits */ n2sccm) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.SpecialColorMixMode \
!    = (SclOtherPri.SpecialColorMixMode & 0xFFCF) | ((n2sccm) << 4))
! 
! #define SCL_GET_N2SCCM() \
!   ((SclOtherPri.SpecialColorMixMode & 0x0030) >> 4)
! 
! #define SCL_SET_N3SCCM(/* 2 bits */ n3sccm) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.SpecialColorMixMode \
!    = (SclOtherPri.SpecialColorMixMode & 0xFF3F) | ((n3sccm) << 6))
! 
! #define SCL_GET_N3SCCM() \
!   ((SclOtherPri.SpecialColorMixMode & 0x00C0) >> 6)
! 
! #define SCL_SET_R0SCCM(/* 2 bits */ r0sccm) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.SpecialColorMixMode \
!   = (SclOtherPri.SpecialColorMixMode & 0xFCFF) | ((r0sccm) << 8))
! 
! #define SCL_GET_R0SCCM() \
!   ((SclOtherPri.SpecialColorMixMode & 0x0300) >> 8)
! 
! /*------ スクロール面用カラー演算割合 N0|R1, N1|EXBG, N2, N3, R0, LC, BACK */
! #define SCL_SET_N0CCRT(/* 5 bits */ n0ccrt) \
!   (SclPriBuffDirty.SclBgColMix = 1, \
!    SclBgColMix.ColMixRateNBG01 \
!    = (SclBgColMix.ColMixRateNBG01 & 0xFF00) | ((n0ccrt)))
! 
! #define SCL_GET_N0CCRT() \
!   ((SclBgColMix.ColMixRateNBG01 & 0x001F))
! 
! #define SCL_SET_N1CCRT(/* 5 bits */ n1ccrt) \
!   (SclPriBuffDirty.SclBgColMix = 1, \
!    SclBgColMix.ColMixRateNBG01 \
!    = (SclBgColMix.ColMixRateNBG01 & 0x00FF) | ((n1ccrt) << 8))
! 
! #define SCL_GET_N1CCRT() \
!   ((SclBgColMix.ColMixRateNBG01 & 0x1F00) >> 8)
! 
! #define SCL_SET_N2CCRT(/* 5 bits */ n2ccrt) \
!   (SclPriBuffDirty.SclBgColMix = 1, \
!    SclBgColMix.ColMixRateNBG23 \
!    = (SclBgColMix.ColMixRateNBG23 & 0xFF00) | ((n2ccrt)))
! 
! #define SCL_GET_N2CCRT() \
!   ((SclBgColMix.ColMixRateNBG23 & 0x001F))
! 
! #define SCL_SET_N3CCRT(/* 5 bits */ n3ccrt) \
!   (SclPriBuffDirty.SclBgColMix = 1, \
!    SclBgColMix.ColMixRateNBG23 \
!    = (SclBgColMix.ColMixRateNBG23 & 0x00FF) | ((n3ccrt) << 8))
! 
! #define SCL_GET_N3CCRT() \
!   ((SclBgColMix.ColMixRateNBG23 & 0x1F00) >> 8)
! 
! #define SCL_SET_R0CCRT(/* 5 bits */ r0ccrt) \
!   (SclPriBuffDirty.SclBgColMix = 1, \
!    SclBgColMix.ColMixRateRBG0 \
!    = ((r0ccrt)))
! 
! #define SCL_GET_R0CCRT() \
!   ((SclBgColMix.ColMixRateRBG0 & 0x001F))
! 
! #define SCL_SET_LCCCRT(/* 5 bits */ lcccrt) \
!   (SclPriBuffDirty.SclBgColMix = 1, \
!    SclBgColMix.ColMixRateLCBAK \
!    = (SclBgColMix.ColMixRateLCBAK & 0xFF00) | ((lcccrt)))
! 
! #define SCL_GET_LCCCRT() \
!   ((SclBgColMix.ColMixRateLCBAK & 0x001F))
! 
! #define SCL_SET_BKCCRT(/* 5 bits */ bkccrt) \
!   (SclPriBuffDirty.SclBgColMix = 1, \
!    SclBgColMix.ColMixRateLCBAK \
!    = (SclBgColMix.ColMixRateLCBAK & 0x00FF) | ((bkccrt) << 8))
! 
! #define SCL_GET_BKCCRT() \
!   ((SclBgColMix.ColMixRateLCBAK & 0x1F00) >> 8)
! 
! /*-- カラーオフセットイネーブル N0|R1, N1|EXBG, N2, N3, R0, BACK, SPRITE */
! 
! #define SCL_SET_N0COEN(/* 1 bit */ n0coen) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetEnable \
!    = (SclColOffset.ColorOffsetEnable & 0xFFFE) | ((n0coen)))
! 
! #define SCL_GET_N0COEN() \
!   ((SclColOffset.ColorOffsetEnable & 0x0001))
! 
! #define SCL_SET_N1COEN(/* 1 bit */ n1coen) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetEnable \
!    = (SclColOffset.ColorOffsetEnable & 0xFFFD) | ((n1coen) << 1))
! 
! #define SCL_GET_N1COEN() \
!   ((SclColOffset.ColorOffsetEnable & 0x0002) >> 1)
! 
! #define SCL_SET_N2COEN(/* 1 bit */ n2coen) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetEnable \
!    = (SclColOffset.ColorOffsetEnable & 0xFFFB) | ((n2coen) << 2))
! 
! #define SCL_GET_N2COEN() \
!   ((SclColOffset.ColorOffsetEnable & 0x0004) >> 2)
! 
! #define SCL_SET_N3COEN(/* 1 bit */ n3coen) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetEnable \
!    = (SclColOffset.ColorOffsetEnable & 0xFFF7) | ((n3coen) << 3))
! 
! #define SCL_GET_N3COEN() \
!   ((SclColOffset.ColorOffsetEnable & 0x0008) >> 3)
! 
! #define SCL_SET_R0COEN(/* 1 bit */ r0coen) \
!    (SclPriBuffDirty.SclColOffset = 1, \
!     SclColOffset.ColorOffsetEnable \
!     = (SclColOffset.ColorOffsetEnable & 0xFFEF) | ((r0coen) << 4))
! 
! #define SCL_GET_R0COEN() \
!   ((SclColOffset.ColorOffsetEnable & 0x0010) >> 4)
! 
! #define SCL_SET_BKCOEN(/* 1 bit */ bkcoen) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetEnable \
!    = (SclColOffset.ColorOffsetEnable & 0xFFDF) | ((bkcoen) << 5))
! 
! #define SCL_GET_BKCOEN() \
!   ((SclColOffset.ColorOffsetEnable & 0x0020) >> 5)
! 
! #define SCL_SET_SPCOEN(/* 1 bit */ spcoen) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetEnable \
!    = (SclColOffset.ColorOffsetEnable & 0xFFBF) | ((spcoen) << 6))
! 
! #define SCL_GET_SPCOEN() \
!   ((SclColOffset.ColorOffsetEnable & 0x0040) >> 6)
! 
! /*--- カラーオフセットレジスタ選択 N0|R1, N1|EXBG, N2, N3, R0, BACK, SPRITE */
! 
! #define SCL_SET_N0COSL(/* 1 bit */ n0cosl) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetSelect \
!    = (SclColOffset.ColorOffsetSelect & 0xFFFE) | (n0cosl))
! 
! #define SCL_GET_N0COSL() \
!   ((SclColOffset.ColorOffsetSelect & 0x0001))
! 
! #define SCL_SET_N1COSL(/* 1 bit */ n1cosl) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetSelect \
!    = (SclColOffset.ColorOffsetSelect & 0xFFFD) | ((n1cosl) << 1))
! 
! #define SCL_GET_N1COSL() \
!   ((SclColOffset.ColorOffsetSelect & 0x0002) >> 1)
! 
! #define SCL_SET_N2COSL(/* 1 bit */ n2cosl) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetSelect \
!    = (SclColOffset.ColorOffsetSelect & 0xFFFB) | ((n2cosl) << 2))
! 
! #define SCL_GET_N2COSL() \
!   ((SclColOffset.ColorOffsetSelect & 0x0004) >> 2)
! 
! #define SCL_SET_N3COSL(/* 1 bit */ n3cosl) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetSelect \
!    = (SclColOffset.ColorOffsetSelect & 0xFFF7) | ((n3cosl) << 3))
! 
! #define SCL_GET_N3COSL() \
!   ((SclColOffset.ColorOffsetSelect & 0x0008) >> 3)
! 
! #define SCL_SET_R0COSL(/* 1 bit */ r0cosl) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetSelect \
!    = (SclColOffset.ColorOffsetSelect & 0xFFEF) | ((r0cosl) << 4))
! 
! #define SCL_GET_R0COSL() \
!   ((SclColOffset.ColorOffsetSelect & 0x0010) >> 4)
! 
! #define SCL_SET_BKCOSL(/* 1 bit */ bkcosl) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetSelect \
!    = (SclColOffset.ColorOffsetSelect & 0xFFDF) | ((bkcosl) << 5))
! 
! #define SCL_GET_BKCOSL() \
!   ((SclColOffset.ColorOffsetSelect & 0x0020) >> 5)
! 
! #define SCL_SET_SPCOSL(/* 1 bit */ spcosl) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetSelect \
!    = (SclColOffset.ColorOffsetSelect & 0xFFBF) | ((spcosl) << 6))
! 
! #define SCL_GET_SPCOSL() \
!   ((SclColOffset.ColorOffsetSelect & 0x0040) >> 6)
! 
! /* カラーオフセットレジスタ A */
! #define SCL_SET_COARD(/* 9 bit */ coard) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetA_RED \
!    = (coard))
! 
! #define SCL_GET_COARD() \
!   (SclColOffset.ColorOffsetA_RED & 0x01FF)
! 
! #define SCL_SET_COAGR(/* 9 bit */ coagr) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetA_GREEN \
!    = (coagr))
! 
! #define SCL_GET_COAGR() \
!   (SclColOffset.ColorOffsetA_GREEN & 0x01FF)
! 
! #define SCL_SET_COABL(/* 9 bit */ coabl) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetA_BLUE \
!    = (coabl))
! 
! #define SCL_GET_COABL() \
!   (SclColOffset.ColorOffsetA_BLUE & 0x01FF)
! 
! /* カラーオフセットレジスタ B*/
! #define SCL_SET_COBRD(/* 9 bit */ cobrd) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetB_RED \
!    = (cobrd))
! 
! #define SCL_GET_COBRD() \
!    (SclColOffset.ColorOffsetB_RED & 0x01FF)
! 
! #define SCL_SET_COBGR(/* 9 bit */ cobgr) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetB_GREEN \
!    = (cobgr))
! 
! #define SCL_GET_COBGR() \
!   (SclColOffset.ColorOffsetB_GREEN & 0x01FF)
! 
! #define SCL_SET_COBBL(/* 9 bit */ cobbl) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetB_BLUE \
!    = (cobbl))
! 
! #define SCL_GET_COBBL() \
!   (SclColOffset.ColorOffsetB_BLUE & 0x01FF)
! 
! /*----------- シャドウコントロール N0|R1, N1|EXBG, N2, N3, R0, BACK */
! 
! #define SCL_SET_N0SDEN(/* 1 bit */ n0sden) \
!    (SclPriBuffDirty.SclOtherPri = 1, \
!     SclOtherPri.ShadowControl \
!     = (SclOtherPri.ShadowControl & 0xFFFE) | ((n0sden)))
! 
! #define SCL_GET_N0SDEN() \
!   ((SclOtherPri.ShadowControl & 0x0001))
! 
! #define SCL_SET_N1SDEN(/* 1 bit */ n1sden) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ShadowControl \
!    = (SclOtherPri.ShadowControl & 0xFFFD) | ((n1sden) << 1))
! 
! #define SCL_GET_N1SDEN() \
!   ((SclOtherPri.ShadowControl & 0x0002) >> 1)
! 
! #define SCL_SET_N2SDEN(/* 1 bit */ n2sden) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ShadowControl \
!    = (SclOtherPri.ShadowControl & 0xFFFB) | ((n2sden) << 2))
! 
! #define SCL_GET_N2SDEN() \
!   ((SclOtherPri.ShadowControl & 0x0004) >> 2)
! 
! #define SCL_SET_N3SDEN(/* 1 bit */ n3sden) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ShadowControl \
!    = (SclOtherPri.ShadowControl & 0xFFF7) | ((n3sden) << 3))
! 
! #define SCL_GET_N3SDEN() \
!   ((SclOtherPri.ShadowControl & 0x0008) >> 3)
! 
! #define SCL_SET_R0SDEN(/* 1 bit */ r0sden) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ShadowControl \
!    = (SclOtherPri.ShadowControl & 0xFFEF) | ((r0sden) << 4))
! 
! #define SCL_GET_R0SDEN() \
!   ((SclOtherPri.ShadowControl & 0x0010) >> 4)
! 
! #define SCL_SET_BKSDEN(/* 1 bit */ bksden) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ShadowControl \
!    = (SclOtherPri.ShadowControl & 0xFFDF) | ((bksden) << 5))
! 
! #define SCL_GET_BKSDEN() \
!   ((SclOtherPri.ShadowControl & 0x0020) >> 5)
! 
! /*--------------------------------------- 透明シャドウセレクト */
! #define SCL_SET_TPSDSL(/* 1 bit */ tpsden) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ShadowControl \
!    = (SclOtherPri.ShadowControl & 0xFEFF) | ((tpsden) << 8))
! 
! #define SCL_GET_TPSDSL() \
!   ((SclOtherPri.ShadowControl & 0x0100) >> 8)
! 
! /*---------------------------カラー RAM モード */
! /* 0x1800E 番地にあるので スクロールライブラリで設定する */
! 
! /* 値の定義 */
! 
! #define SCL_RBG0	0x00000001
! #define SCL_RBG1	0x00000002
! #define SCL_NBG0	0x00000004
! #define SCL_NBG1	0x00000008
! #define SCL_NBG2	0x00000010
! #define SCL_NBG3	0x00000020
! 
! #define SCL_EXBG	0x00000080
! #define SCL_SPR 	0x00000100
! #define SCL_SP0 	0x00000100
! #define SCL_SP1 	0x00000200
! #define SCL_SP2 	0x00000400
! #define SCL_SP3 	0x00000800
! #define SCL_SP4 	0x00001000
! #define SCL_SP5 	0x00002000
! #define SCL_SP6 	0x00004000
! #define SCL_SP7 	0x00008000
! #define SCL_RP  	0x00010000
! #define SCL_RP_R	0xfffeffff
! #define SCL_CC  	0x00020000
! #define SCL_LNCL	0x00040000
! #define SCL_BACK	0x00080000
! 
! #define SCL_RBG_TB_A	SCL_RBG0
! #define SCL_RBG_TB_B	SCL_RBG1
! 
! #define SCL_CRM15_1024 0
! #define SCL_CRM15_2048 1
! #define SCL_CRM24_1024 2
! 
! /* スプライトのタイプ指定 */
! #define SCL_TYPE0	0
! #define SCL_TYPE1	1
! #define SCL_TYPE2	2
! #define SCL_TYPE3	3
! #define SCL_TYPE4	4
! #define SCL_TYPE5	5
! #define SCL_TYPE6	6
! #define SCL_TYPE7	7
! #define SCL_TYPE8	8
! #define SCL_TYPE9	9
! #define SCL_TYPEA	10
! #define SCL_TYPEB	11
! #define SCL_TYPEC	12
! #define SCL_TYPED	13
! #define SCL_TYPEE	14
! #define SCL_TYPEF	15
! 
! #define SCL_PALETTE	0
! #define SCL_MIX 	1
! 
! #define SCL_MSB_SHADOW	0
! #define SCL_SP_WINDOW	1
! 
! #define SCL_IF_BEHIND	0
! #define SCL_IF_EQUAL	1
! #define SCL_IF_FRONT	2
! #define SCL_MSB_ON	3
! 
! #define SCL_OFFSET_A	0
! #define SCL_OFFSET_B	1
! 
! #endif /* __PRI_MACRO */
! 
! extern SclOtherPriRegister  SclOtherPri;  /* いろいろ */
! 
! extern SclSpPriNumRegister  SclSpPriNum;  /* スプライトのプライオリティ番号 */
! 
! extern SclBgPriNumRegister  SclBgPriNum;  /* スクロールのプライオリティ番号 */
! 
! extern SclSpColMixRegister  SclSpColMix;  /* スプライトの色演算 */
! 
! extern SclBgColMixRegister  SclBgColMix;  /* スクロールの色演算 */
! 
! extern SclColOffsetRegister SclColOffset; /* カラーオフセット */
! 
! extern SclPriBuffDirtyFlags SclPriBuffDirty; /* レジスタバッファのダーティー・フラグ */
! 
! /*--- REAL Priority Registers (Pointer) ---*/
! 
! extern SclOtherPriRegister  *SclRealOtherPri;
! 
! extern SclSpPriNumRegister  *SclRealSpPriNum;
! 
! extern SclBgPriNumRegister  *SclRealBgPriNum;
! 
! extern SclSpColMixRegister  *SclRealSpColMix;
! 
! extern SclBgColMixRegister  *SclRealBgColMix;
! 
! extern SclColOffsetRegister *SclRealColOffset;
! 
! #endif /* __PRI_GLVAR */
! 
! /* ＶＤＰ２ライブラリのプロトタイプ宣言 */
! #ifndef	SEGA_SCL_PROTO
! #define SEGA_SCL_PROTO
! 
! extern	void	SCL_Vdp2Init(void);
! extern	void	SCL_Vdp2_SGLInit(Uint16 tvmod);
! extern	void	SCL_SetDisplayMode(Uint8 interlace,Uint8 vertical,Uint8 horizontal);
! extern	void	SCL_InitVramConfigTb(SclVramConfig *tp);
! extern	void	SCL_InitConfigTb(SclConfig *scfg);
! extern	void	SCL_InitLineParamTb(SclLineparam *lp);
! extern	void	SCL_SetVramConfig(SclVramConfig *tp);
! extern	void	SCL_SetConfig(Uint16 sclnum, SclConfig *scfg);
! extern	void	SCL_SetCycleTable(Uint16 *tp);
! extern	void	SCL_Open(Uint32 sclnum);
! extern	void	SCL_Close(void);
! extern	void	SCL_SetLineParam(SclLineparam *lp);
! extern	void	SCL_MoveTo(Fixed32 x,Fixed32 y,Fixed32 z);
! extern	void	SCL_Move(Fixed32 x,Fixed32 y,Fixed32 z);
! extern	void	SCL_Scale(Fixed32 Sx, Fixed32 Sy);
! extern	void	SCL_SetColRamMode(Uint32 ComRamMode);
! extern	Uint32	SCL_InitRotateTable(Uint32 Address,Uint16 Mode,Uint32 rA,Uint32 rB);
! extern	void	SCL_RotateTo(Fixed32 xy,Fixed32 z,Fixed32 disp,Uint16 mode);
! extern	void	SCL_Rotate(Fixed32 xy,Fixed32 z,Fixed32 disp);
! extern	void	SCL_SetRotateViewPoint(Uint16 x,Uint16 y,Uint16 z);
! extern	void    SCL_SetRotateZoom(Fixed32 x,Fixed32 y);
! extern	void	SCL_SetRotateCenter(Uint16 x,Uint16 y,Uint16 z);
! extern	void	SCL_SetRotateCenterDisp(Uint16 x,Uint16 y);
! extern	void	SCL_SetCoefficientData(Uint32 sclnum,Uint16 *data,Uint16 x,Uint16 y);
! extern	void	SCL_SetLncl(Uint32 addr,Uint16 tbnum,Uint16 *palNumTb);
! extern	void	SCL_SetBack(Uint32 addr,Uint16 dataSize,Uint16 *dataTb);
! extern	void	SCL_SetMosaic(Uint32 surface,Uint8 x,Uint8 y);
! extern	void	SCL_SetSpriteMode(Uint8 Type, Uint8 ColMode, Uint8 WinMode);
! extern	Uint32	SCL_GetColRamMode(void);
! extern	void	SCL_SetColRam(Uint32 Object, Uint32 Index,Uint32 num,void *Color);
! extern	Uint32	SCL_AllocColRam(Uint32 Surface, Uint32 NumOfColors, Uint8 transparent);
! extern	void	SCL_FreeColRam(Uint32 Surface);
! extern	void	SCL_SetAutoColChg(Uint32 Surface,Uint32 Interval,Uint32 Index,
! 			Uint32 NumOfCol,Uint32 NumOfTbl,Uint32 *ChangeTbl);
! extern	Uint32	SCL_GetColRamOffset(Uint32 Object);
! extern	void	SCL_SetPriority(Uint32 Object, Uint8 Priority);
! extern	Uint8	SCL_GetPriority(Uint32 Object);
! extern	void	SCL_SetColMixMode(Uint32 ColMixPriority, Uint8 Mode);
! extern	void	SCL_SetColMixRate(Uint32 Surfaces, Uint8 Rate);
! extern	void	SCL_SetAutoColMix(Uint32 Surfaces,Uint32 Interval,Uint32 Time,
! 			Uint8 StartRate,Uint8 EndRate);
! extern	void	SCL_SetColOffset(Uint32 OffsetReg, Uint32 Surfaces,
! 			Sint16 red, Sint16 green, Sint16 blue);
! extern	void	SCL_IncColOffset(Uint32 OffsetReg,Sint16 red,Sint16 green,Sint16 blue);
! extern	void	SCL_SetAutoColOffset(Uint32 OffsetReg,Uint32 Interval,Uint32 Time,
! 				SclRgb *start,SclRgb *end);
! extern	void	SCL_EnableBlur(Uint32 Surface);
! extern	void	SCL_DisableBlur(void);
! extern	void	SCL_EnableLineCol(Uint32 Surface);
! extern	void	SCL_DisableLineCol(Uint32 Surface);
! extern	void	SCL_SetWindow(Uint8 win,Uint32 logic,Uint32 enable,Uint32 area,
! 			Uint16 sx,Uint16 sy,Uint16 ex,Uint16 ey);
! extern	void	SCL_SetLineWindow(Uint8 win,Uint32 logic,Uint32 enable,Uint32 area,
! 			Uint32 addr,Uint32 sy,Uint32 tbSize,SclLineWindowTb *tp);
! extern	void	SCL_SetSpriteWindow(Uint32 logic,Uint32 enable,Uint32 area);
! extern	void	SCL_SetFrameInterval(Uint16 count);
! extern	void	SCL_DisplayFrame(void);
! extern	void	SCL_VblankStart(void);
! extern	void	SCL_VblankEnd(void);
! extern	void	SCL_AbortAutoVe(void);
! 
! extern	void	SCL_SglOn(void);		/* tuika c.yoshida */
! extern	void	SCL_SglOff(void);		/* tuika c.yoshida */
! 
! /* 画面サイズデフォルト */
! extern	Uint16	SclDisplayX;
! extern	Uint16	SclDisplayY;
! 
! /* レジスタバッファ */
! extern	SclSysreg	Scl_s_reg;
! extern	SclDataset	Scl_d_reg;
! extern	SclNorscl	Scl_n_reg;
! extern	SclRotscl	Scl_r_reg;
! extern	SclWinscl	Scl_w_reg;
! extern	Uint16		SclProcess;
! extern	SclSblSgl	Scl_flag;
! 
! #endif /* SEGA_SCL_PROTO */
! 
\ No newline at end of file
--- 1,1425 ----
! /*------------------------------------------------------------------------
!  *  FILE:	SEGA_SCL.H
!  *
!  *	Copyright(c) 1994 SEGA
!  *
!  *  PURPOSE:
!  *	Scroll Simulation program header file
!  *	Scroll Register Data Structure Definition File
!  *
!  *  AUTHOR(S):
!  *	K.M
!  *		
!  *  MOD HISTORY:
!  *	Written by K.M on 1994-05-20 Ver.1.00
!  *	Updated by K.M on 1994-07-01 Ver.1.00
!  * 
!  *------------------------------------------------------------------------
!  */
! 
! #ifndef	SEGA_SCR_H
! #define SEGA_SCR_H
! 
! #include <sega_xpt.h>
! #include <sega_def.h>
! #include <sega_mth.h> 
! 
! #define VBR              0x06000000
! #define SCU_BASE         0x25FE0000
! #define SCU_INTR_MASK    0x000000a0
! #define SCU_INTR_STATUS  0x000000a4
! #define SETUINT   ((Sint32 (*)()) *((Uint32*)(VBR+0x300)))
! #define GETUINT   ((Sint32 (*)()) *((Uint32*)(VBR+0x304)))
! #define SETSINT   ((Sint32 (*)()) *((Uint32*)(VBR+0x310)))
! #define GETSINT   ((Sint32 (*)()) *((Uint32*)(VBR+0x314)))
! #define VBIVN	0x40
! #define VBOVN	0x41
! #define HBIVN	0x42
! 
! /*********************************************
!  *      System Register Cluster	             *
!  *      Address ranger 180000H - 180027H     *
!  *********************************************/
!  typedef struct	SclSysreg{
! 	Uint16	tvmode;			/* TV Mode */
! 	Uint16	extenbl;		/* External Input Enable */
! 	Uint16	tvstatus;		/* TV Status Read Only */
! 	Uint16	vramsize;		/* VRAM Size */
! 	Uint16	H_val;			/* H Counter Read Only */
! 	Uint16	V_val;			/* V Counter Read Only */
! 	Uint16	vramchg;		/* VRAM Change */
! 	Uint16	ramcontrl;		/* RAM Control */
! 	Uint16	vramcyc[8];		/* VRAM Cycle Table x8 */
! 	Uint16	dispenbl;		/* Display Enable */
! 	Uint16	mosaic;			/* Mosaic Control */
! 	Uint16	specialcode_sel;	/* Special Code Selector */
! 	Uint16	specialcode;		/* Special Code */
!  } SclSysreg;
! 
! /**********************************************
!  *      Scroll Data Set Register Cluster      *
!  *      Address ranger 180028H - 18006FH      *
!  **********************************************/
! typedef struct SclDataset{
! 	Uint16	charcontrl0;		/* Character Control */
! 	Uint16	charcontrl1;		/* Character Control */
! 	Uint16	bmpalnum0;		/* Bitmap Palette Number */
! 	Uint16	bmpalnum1;		/* Bitmap Palette Number */
! 	Uint16	patnamecontrl[5];	/* Pattern Name Controlx5 */
! 	Uint16	platesize;		/* Plate Size */	
! 	Uint16	mapoffset0;		/* Map Offset */
! 	Uint16	mapoffset1;		/* Map Offset */
! 	Uint16	normap[8];		/* Normal Scroll Map x8*/
! 	Uint16	rotmap[16];		/* Rotate Scroll Map x16*/
! } SclDataset;
! 
! /***************************************************
!  *      Normal Scroll Function Register Cluster    *
!  *      Address ranger 180070H - 1800AFH           *
!  ***************************************************/
! typedef struct SclNorscl{
! 	Fixed32	n0_move_x;		/* NBG0 Scroll Movement X */
! 	Fixed32	n0_move_y;		/* NBG0 Scroll Movement Y */
! 	Fixed32	n0_delta_x;		/* NBG0 Scroll Movement X */
! 	Fixed32	n0_delta_y;		/* NBG0 Scroll Movement Y */
! 	Fixed32	n1_move_x;		/* NBG1 Scroll Movement X */
! 	Fixed32	n1_move_y;		/* NBG1 Scroll Movement Y */
! 	Fixed32	n1_delta_x;		/* NBG1 Scroll Movement X */
! 	Fixed32	n1_delta_y;		/* NBG1 Scroll Movement Y */
! 	Uint16	n2_move_x;		/* NBG2 Scroll Movement X */
! 	Uint16	n2_move_y;		/* NBG2 Scroll Movement Y */
! 	Uint16	n3_move_x;		/* NBG3 Scroll Movement X */
! 	Uint16	n3_move_y;		/* NBG3 Scroll Movement Y */
! 	Uint16	zoomenbl;		/* Zoom Enable */
! 	Uint16	linecontrl;		/* Normal Extension Control */
! 	Uint32	celladdr;		/* Cell Scroll Table Address */
! 	Uint32	lineaddr[2];		/* Line Scroll Table Address x2 */
! 	Uint32	linecolmode;		/* Line BG Color Mode Address */
! 	Uint32	backcolmode;		/* Back BG Color Mode Address */
! } SclNorscl;
! 
! /****************************************************
!  *      Rotate Scroll Function Register Cluster     *
!  *      Address ranger 1800B0H - 1800BFH            *
!  ****************************************************/
! typedef struct SclRotscl{
! 	Uint16	paramode;		/* Rotate Parameter Mode */
! 	Uint16	paramcontrl;		/* Rotate Parameter Read Control */
! 	Uint16	k_contrl;		/* Keisu Table Control */
! 	Uint16	k_offset;		/* Keisu Addres Offset */
! 	Uint16	mapover[2];		/* Rotate Scroll Map Over */
! 	Uint32	paramaddr;		/* Rotate Parameter Tabel Address */
! } SclRotscl;
! 
! /***************************************************
!  *      Window Scroll Setting Register Cluster     *
!  *      Address ranger 1800C0H - 1800DFH           *
!  ***************************************************/
! typedef struct SclWinscl{
! 					/* 1800C0 */
! 	Uint16	win0_start[2];		/* Window #0 Start X & Y */
! 					/* 1800C4 */
! 	Uint16	win0_end[2];		/* Window #0 End X & Y */
! 					/* 1800C8 */
! 	Uint16	win1_start[2];		/* Window #1 Start X & Y */
! 					/* 1800CC */
! 	Uint16	win1_end[2];		/* Window #1 End X & Y */
! 					/* 1800D0 */
! 	Uint16	wincontrl[4];		/* Window Control */
! 					/* 1800D8 */
! 	Uint32 	linewin0_addr;		/* Line Window #0 Table Address */ 
! 					/* 1800DC */
! 	Uint32 	linewin1_addr;		/* Line Window #1 Table Address */ 
! } SclWinscl;
! 
! /***********************************************
!  *      Priority Related Register Cluster      *
!  ***********************************************/
! typedef struct SclPrior{
! 	Uint16	prnum;
! } SclPrior;
! 
! 
! /**************************************************
!  *      Scroll Parameters Definition              *
!  **************************************************/
! typedef struct  SclXy {
! 	 Fixed32         x;
! 	 Fixed32         y;
! } SclXy;
! 
! typedef struct  SclXyz {
! 	 Fixed32         x;
! 	 Fixed32         y;
! 	 Fixed32         z;
! } SclXyz;
! 
! typedef struct  SclXy16 {
!         Uint16         x;
!         Uint16         y;
! } SclXy16;
! 
! typedef struct  SclXyz16 {
!         Sint16         x;
!         Sint16         y;
!         Sint16         z;
! } SclXyz16;
! 
! typedef struct  SclRgb {
! 	 Sint16		red;
! 	 Sint16		green;
! 	 Sint16		blue;
! } SclRgb;
! 
! typedef struct  SclLineTb {
! 	 Fixed32	h;
! 	 Fixed32	v;
! 	 Fixed32	dh;
! } SclLineTb;
! 
! typedef struct  SclLineWindowTb {
! 	 Uint16		start;
! 	 Uint16		end;
! } SclLineWindowTb;
! 
! typedef struct SclVramConfig{
! 	Uint32	ktboffsetA;/* 回転ﾊﾟﾗﾒｰﾀA用係数ﾃｰﾌﾞﾙをﾊﾞﾝｸ中のどこに配置するか */
! 	Uint32	ktboffsetB;/* 回転ﾊﾟﾗﾒｰﾀB用係数ﾃｰﾌﾞﾙをﾊﾞﾝｸ中のどこに配置するか */
! 	Uint8	vramModeA; /* VRAM A を２つのバンクに区切るか指定(0/1)  */
! 	Uint8	vramModeB; /* VRAM B を２つのバンクに区切るか指定(0/1)  */
! 	Uint8	vramA0;    /* VRAM A or A0 を回転面の何で使用するか指定 */
! 	Uint8	vramA1;    /* VRAM A1 を回転面の何で使用するか指定      */
! 	Uint8	vramB0;    /* VRAM B or B0 を回転面の何で使用するか指定 */
! 	Uint8	vramB1;    /* VRAM B1 を回転面の何で使用するか指定      */
! 	Uint8	colram;    /* カラーＲＡＭに係数データを置くか？        */
! } SclVramConfig;
! 
! typedef struct SclRotreg{
! 	SclXyz		screenst;
! 	SclXy		screendlt;
! 	SclXy		delta;
! 	Fixed32		matrix_a;
! 	Fixed32		matrix_b;
! 	Fixed32		matrix_c;
! 	Fixed32		matrix_d;
! 	Fixed32		matrix_e;
! 	Fixed32		matrix_f;
! 	SclXyz16	viewp;
! 	Uint16		dummy1;
! 	SclXyz16	rotatecenter;
! 	Uint16		dummy2;
! 	SclXy		move;
! 	SclXy		zoom;
! 	Fixed32		k_tab;
! 	SclXy		k_delta;
! 	Fixed32		dummy3[8];
! } SclRotreg;
! 
! typedef struct SclRotparam{
! 	Uint32		addr;
! 	SclXyz		screenst;
! 	SclXy		screendlt;
! 	SclXy		delta;
! 	Fixed32		matrix_a;
! 	Fixed32		matrix_b;
! 	Fixed32		matrix_c;
! 	Fixed32		matrix_d;
! 	Fixed32		matrix_e;
! 	Fixed32		matrix_f;
! 	Fixed32		matrix_g;
! 	Fixed32		matrix_h;
! 	Fixed32		matrix_i;
! 	Fixed32		drotangle;
! 	SclXyz		viewp;
! 	SclXyz		rotatecenter;
! 	SclXyz		disprotcenter;
! 	SclXyz		move;
! 	SclXy		zoom;
! 	Fixed32		k_tab;
! 	SclXy		k_delta;
! 	Uint16		k_size;
! } SclRotparam;
! 
! /*******************************************
!  *      Scroll Configure Data Structure    *
!  *******************************************/
! typedef	struct	SclConfig {
! 	Uint8		dispenbl;
! 	Uint8		charsize;
! 	Uint8		pnamesize;
! 	Uint8		platesize;
! 	Uint8		bmpsize;
! 	Uint8		coltype;
! 	Uint8		datatype;
! 	Uint8		mapover;
! 	Uint8		flip;
! 	Uint16		patnamecontrl;
! 	Uint32		plate_addr[16];
! } SclConfig;
! 
! /******************************************************
!  *      Line & Cell Scroll Parameter Data Structure   *
!  ******************************************************/
! #define	SCL_MAXLINE	512
! #define	SCL_MAXCELL	64
! 
! typedef	struct	SclLineparam{
! 	Uint8		delta_enbl;
! 	Uint8		v_enbl;
! 	Uint8		h_enbl;
! 	Uint8		cell_enbl;
! 	Uint8		interval;
! 	Uint32		line_addr;
! 	Uint32		cell_addr;
! 	SclLineTb	line_tbl[SCL_MAXLINE];
! 	Fixed32		cell_tbl[SCL_MAXCELL];
! }	SclLineparam;
! 
! typedef	struct	SclLineWin{
! 	Uint16		winum;
! 	Uint16		y[2];
! 	Uint32		addr;
! 	SclXy16		tbl[SCL_MAXLINE];
! }	SclLineWin;
! 
! 
! #define SCL_VDP2_VRAM		0x25e00000
! #define SCL_VDP2_VRAM_A		0x25e00000
! #define SCL_VDP2_VRAM_A0	0x25e00000
! #define SCL_VDP2_VRAM_A1	0x25e20000
! #define SCL_VDP2_VRAM_B		0x25e40000
! #define SCL_VDP2_VRAM_B0	0x25e40000
! #define SCL_VDP2_VRAM_B1	0x25e60000
! #define	SCL_COLRAM_ADDR		0x25F00000	/* Color RAM */
! 
! #define SCL_NON			0   /* RBG0では使用しない        */
! #define SCL_RBG0_K 		1   /* RBG0の係数ﾃｰﾌﾞﾙを置く     */
! #define SCL_RBG0_PN 		2   /* RBG0のﾊﾟﾀｰﾝﾈｰﾑﾃｰﾌﾞﾙを置く */
! #define SCL_RBG0_CHAR 		3   /* RBG0のｷｬﾗｸﾀを置く         */
! #define SCL_RBG1_K 		4   /* RBG1の係数ﾃｰﾌﾞﾙを置く     */
! 
! #define	SCL_CHAR_SIZE_1X1	0
! #define	SCL_CHAR_SIZE_2X2	1
! 
! #define	SCL_PN2WORD		0
! #define	SCL_PN1WORD		1
! 
! #define	SCL_PL_SIZE_1X1		0
! #define	SCL_PL_SIZE_2X1		1
! #define	SCL_PL_SIZE_2X2		3
! 
! #define	SCL_BMP_SIZE_512X256	0
! #define	SCL_BMP_SIZE_512X512	1
! #define	SCL_BMP_SIZE_1024X256	2
! #define	SCL_BMP_SIZE_1024X512	3
! 
! #define	SCL_COL_TYPE_16		0
! #define	SCL_COL_TYPE_256	1
! #define	SCL_COL_TYPE_2048	2
! #define	SCL_COL_TYPE_32K	3
! #define	SCL_COL_TYPE_1M		4
! 
! #define	SCL_CELL		0
! #define	SCL_BITMAP		1
! 
! #define	SCL_OVER_0		0
! #define	SCL_OVER_1		1
! #define	SCL_OVER_2		2
! #define	SCL_OVER_3		3
! 
! #define	SCL_PN_10BIT		0
! #define	SCL_PN_12BIT		1
! 
! #define	SCL_1_LINE		0
! #define	SCL_2_LINE		1
! #define	SCL_4_LINE		2
! 
! #define	SCL_NON_INTER		0
! #define	SCL_SINGLE_INTER	2
! #define	SCL_DOUBLE_INTER	3
! 
! #define	SCL_224LINE		0
! #define	SCL_240LINE		1
! #define	SCL_256LINE		2
! 
! #define	SCL_NORMAL_A		0
! #define	SCL_NORMAL_B		1
! #define	SCL_HIRESO_A		2
! #define	SCL_HIRESO_B		3
! #define	SCL_NORMAL_AE		4
! #define	SCL_NORMAL_BE		5
! #define	SCL_HIRESO_AE		6
! #define	SCL_HIRESO_BE		7
! 
! #define	SCL_X_AXIS		1
! #define	SCL_Y_AXIS		2
! 
! #define	SCL_W0			0
! #define	SCL_W1			1
! 
! #define FIXED(x)	      ((Fixed32)((x) * 65536.0))
! #define MUL_FIXED(a, b)       MTH_Mul(a, b)
! #define DIV_FIXED(a, b)       MTH_Div(a, b)
! 
! #endif	/* ifndef SEGA_SCR_H */
! 
! 
! /*------------------------------------------------------------------------
!  *  
!  *
!  *  DESCRIPTION:
!  *
!  *          Header file for Priority library internal use.
!  *          Each Macro Set a parameter on Register buffer.
!  *          the buffer will copy to REAL regster while V-interval.
!  *          ここにあるマクロは、レジスタバッファに各コントロール値を
!  *          書き込み、書き込んだレジスタバッファのダーティーフラグを
!  *          1 にする。
! -------------------------------------------------------------------------*/
! 
! #ifndef __PRI_GLVAR
! #define __PRI_GLVAR
! 
! #ifndef __PRI_MACRO
! #define __PRI_MACRO
! 
! #ifndef __PRI_REG
! #define __PRI_REG
! 
! /*-----< other group regs >----*/
! typedef struct {
!     volatile Uint16 SpriteControl;		/* 1800E0 */
!     volatile Uint16 ShadowControl;		/* 1800E2 */
!     volatile Uint16 ColorRamOffset0;		/* 1800E4 */
!     volatile Uint16 ColorRamOffset1;		/* 1800E6 */
!     volatile Uint16 LineColorEnable;		/* 1800E8 */
!     volatile Uint16 SpecialPriorityMode;		/* 1800EA */
!     volatile Uint16 ColorMixControl;		/* 1800EC */
!     volatile Uint16 SpecialColorMixMode;		/* 1800EE */
! } SclOtherPriRegister;
! 
! /*----< sprite priority >----*/
! typedef struct {
!     volatile Uint16 PriorityNumberSP01;		/* 1800F0 */
!     volatile Uint16 PriorityNumberSP23;		/* 1800F2 */
!     volatile Uint16 PriorityNumberSP45;		/* 1800F4 */
!     volatile Uint16 PriorityNumberSP67;		/* 1800F6 */
! } SclSpPriNumRegister;
! 
! /*----< scroll priority >----*/
! typedef struct {
!     volatile Uint16 PriorityNumberNBG01;		/* 1800F8 */
!     volatile Uint16 PriorityNumberNBG23;		/* 1800FA */
!     volatile Uint16 PriorityNumberRBG0;		/* 1800FC */
! } SclBgPriNumRegister;
! 
! /*----< sprite color Mix >----*/
! typedef struct {
!     volatile Uint16 ColMixRateSP01;		/* 180100 */
!     volatile Uint16 ColMixRateSP23;		/* 180102 */
!     volatile Uint16 ColMixRateSP45;		/* 180104 */
!     volatile Uint16 ColMixRateSP67;		/* 180106 */
! } SclSpColMixRegister;
! 
! /*----< scroll color Mix >----*/
! typedef struct {
!     volatile Uint16 ColMixRateNBG01;		/* 180108 */
!     volatile Uint16 ColMixRateNBG23;		/* 18010A */
!     volatile Uint16 ColMixRateRBG0;		/* 18010C */
!     volatile Uint16 ColMixRateLCBAK;		/* 18010E */
! } SclBgColMixRegister;
! 
! /*----< color offset >----*/
! typedef struct {
!     volatile Uint16 ColorOffsetEnable;		/* 180110 */
!     volatile Uint16 ColorOffsetSelect;		/* 180112 */
!     volatile Uint16 ColorOffsetA_RED;		/* 180114 */
!     volatile Uint16 ColorOffsetA_GREEN;		/* 180116 */
!     volatile Uint16 ColorOffsetA_BLUE;		/* 180118 */
!     volatile Uint16 ColorOffsetB_RED;		/* 18011A */
!     volatile Uint16 ColorOffsetB_GREEN;		/* 18011E */
!     volatile Uint16 ColorOffsetB_BLUE;		/* 180120 */
! } SclColOffsetRegister;
! 
! /*---- レジスタバッファのダーティー・フラグ */
! typedef struct
! {
!     volatile Uint32 SclOtherPri:1;
!     volatile Uint32 SclSpPriNum:1;
!     volatile Uint32 SclBgPriNum:1;
!     volatile Uint32 SclSpColMix:1;
!     volatile Uint32 SclBgColMix:1;
!     volatile Uint32 SclColOffset:1;
! } SclPriBuffDirtyFlags;
! 
! #endif /* __PRI_REG */
! 
! 
! extern SclOtherPriRegister	SclOtherPri;
! extern SclSpPriNumRegister	SclSpPriNum;
! extern SclBgPriNumRegister	SclBgPriNum;
! extern SclSpColMixRegister	SclSpColMix;
! extern SclBgColMixRegister	SclBgColMix;
! extern SclColOffsetRegister	SclColOffset;
! extern SclPriBuffDirtyFlags	SclPriBuffDirty;
! 
! /* Following macros never check argument value range.*/
! 
! /* VDP-II manual p.129 */
! #define SCL_SET_SPCCCS(/* 2 bits */ spcccs) /* スプライト色演算条件 */\
!   (SclPriBuffDirty.SclOtherPri = 1,\
!    SclOtherPri.SpriteControl \
!    = (SclOtherPri.SpriteControl & 0x0FFF) | ((spcccs) << 12))
! 
! #define SCL_GET_SPCCCS() \
!   ((SclOtherPri.SpriteControl & 0x3000) >> 12)
! 
! #define SCL_SET_SPCCN(/* 3 bits */ spccn) /* スプライト色演算条件ナンバ */\
!   (SclPriBuffDirty.SclOtherPri = 1,\
!    SclOtherPri.SpriteControl \
!    = (SclOtherPri.SpriteControl & 0xF0FF) | ((spccn) << 8))
! 
! #define SCL_GET_SPCCN() \
!   ((SclOtherPri.SpriteControl & 0x0700) >> 8)
! 
! #define SCL_SET_SPCLMD(/* 1 bit */ spclmd) /* スプライトの色形式 */\
!   (SclPriBuffDirty.SclOtherPri = 1,\
!    SclOtherPri.SpriteControl \
!    = (SclOtherPri.SpriteControl & 0xFFDF) | ((spclmd) << 5))
! 
! #define SCL_GET_SPCLMD() \
!   ((SclOtherPri.SpriteControl & 0x0020) >> 5)
! 
! #define SCL_SET_SPWINEN(/* 1 bit */ spwinen) /* スプライトウィンドウイネーブル */\
!   (SclPriBuffDirty.SclOtherPri = 1,\
!    SclOtherPri.SpriteControl \
!    = (SclOtherPri.SpriteControl & 0xFFEF) | ((spwinen) << 4))    /* -> p.121 */
! 
! #define SCL_GET_SPWINEN() \
!   ((SclOtherPri.SpriteControl & 0x0010) >> 4)
! 
! #define SCL_SET_SPTYPE(/* 4bits */ sptype) /* スプライトのタイプ指定 */\
!   (SclPriBuffDirty.SclOtherPri = 1,\
!    SclOtherPri.SpriteControl \
!    = (SclOtherPri.SpriteControl & 0xFFF0) | (sptype))
! 
! #define SCL_GET_SPTYPE() \
!   (SclOtherPri.SpriteControl & 0x000F)
! 
! /* VDP-II manual p.131 */
! /*-------------------- スプライト用プライオリティレジスタ No.0-7 */
! 
! #define SCL_SET_S0PRIN(/* 3 bits */ s0prin) \
!   (SclPriBuffDirty.SclSpPriNum = 1,\
!    SclSpPriNum.PriorityNumberSP01 \
!    = (SclSpPriNum.PriorityNumberSP01 & 0xFFF0) | (s0prin))
! 
! #define SCL_GET_S0PRIN() \
!   ((SclSpPriNum.PriorityNumberSP01 & 0x0007))
! 
! #define SCL_SET_S1PRIN(/* 3 bits */ s1prin) \
!   (SclPriBuffDirty.SclSpPriNum = 1, \
!    SclSpPriNum.PriorityNumberSP01 \
!    = (SclSpPriNum.PriorityNumberSP01 & 0xF0FF) | ((s1prin) << 8))
! 
! #define SCL_GET_S1PRIN() \
!   ((SclSpPriNum.PriorityNumberSP01 & 0x0700) >> 8)
! 
! #define SCL_SET_S2PRIN(/* 3 bits */ s2prin) \
!   (SclPriBuffDirty.SclSpPriNum = 1, \
!    SclSpPriNum.PriorityNumberSP23 \
!    = (SclSpPriNum.PriorityNumberSP23 & 0xFFF0) | ((s2prin)))
! 
! #define SCL_GET_S2PRIN() \
!   ((SclSpPriNum.PriorityNumberSP23 & 0x0007))
! 
! #define SCL_SET_S3PRIN(/* 3 bits */ s3prin) \
!   (SclPriBuffDirty.SclSpPriNum = 1, \
!    SclSpPriNum.PriorityNumberSP23 \
!    = (SclSpPriNum.PriorityNumberSP23 & 0xF0FF) | ((s3prin) << 8))
! 
! #define SCL_GET_S3PRIN() \
!   ((SclSpPriNum.PriorityNumberSP23 & 0x0700) >> 8)
! 
! #define SCL_SET_S4PRIN(/* 3 bits */ s4prin) \
!   (SclPriBuffDirty.SclSpPriNum = 1, \
!    SclSpPriNum.PriorityNumberSP45 \
!    = (SclSpPriNum.PriorityNumberSP45 & 0xFFF0) | ((s4prin)))
! 
! #define SCL_GET_S4PRIN() \
!   ((SclSpPriNum.PriorityNumberSP45 & 0x0007))
! 
! #define SCL_SET_S5PRIN(/* 3 bits */ s5prin) \
!   (SclPriBuffDirty.SclSpPriNum = 1, \
!    SclSpPriNum.PriorityNumberSP45 \
!    = (SclSpPriNum.PriorityNumberSP45 & 0xF0FF) | ((s5prin) << 8))
! 
! #define SCL_GET_S5PRIN() \
!   ((SclSpPriNum.PriorityNumberSP45 & 0x0700) >> 8)
! 
! #define SCL_SET_S6PRIN(/* 3 bits */ s6prin) \
!   (SclPriBuffDirty.SclSpPriNum = 1, \
!    SclSpPriNum.PriorityNumberSP67 \
!    = (SclSpPriNum.PriorityNumberSP67 & 0xFFF0) | ((s6prin)))
! 
! #define SCL_GET_S6PRIN() \
!   ((SclSpPriNum.PriorityNumberSP67 & 0x0007))
! 
! #define SCL_SET_S7PRIN(/* 3 bits */ s7prin) \
!   (SclPriBuffDirty.SclSpPriNum = 1, \
!    SclSpPriNum.PriorityNumberSP67 \
!    = (SclSpPriNum.PriorityNumberSP67 & 0xF0FF) | ((s7prin) << 8))
! 
! #define SCL_GET_S7PRIN() \
!   ((SclSpPriNum.PriorityNumberSP67 & 0x0700) >> 8)
! 
! /* VDP-II manual p.132 */
! /*------------------- スプライト用カラー演算割合レジスタ No.0-7 */
! 
! #define SCL_SET_S0CCRT(/* 5bits */ s0ccrt) \
!   (SclPriBuffDirty.SclSpColMix = 1, \
!    SclSpColMix.ColMixRateSP01 \
!    = (SclSpColMix.ColMixRateSP01 & 0xFF00) | ((s0ccrt)))
! 
! #define SCL_GET_S0CCRT() \
!   ((SclSpColMix.ColMixRateSP01 & 0x001F) >> 0)
! 
! #define SCL_SET_S1CCRT(/* 5bits */ s1ccrt) \
!   (SclPriBuffDirty.SclSpColMix = 1, \
!    SclSpColMix.ColMixRateSP01 \
!    = (SclSpColMix.ColMixRateSP01 & 0x00FF) | ((s1ccrt) << 8))
! 
! #define SCL_GET_S1CCRT() \
!   ((SclSpColMix.ColMixRateSP01 & 0x1F00) >> 8)
! 
! #define SCL_SET_S2CCRT(/* 5bits */ s2ccrt) \
!   (SclPriBuffDirty.SclSpColMix = 1, \
!    SclSpColMix.ColMixRateSP23 \
!    = (SclSpColMix.ColMixRateSP23 & 0xFF00) | ((s2ccrt)))
! 
! #define SCL_GET_S2CCRT() \
!   ((SclSpColMix.ColMixRateSP23 & 0x001F))
! 
! #define SCL_SET_S3CCRT(/* 5bits */ s3ccrt) \
!   (SclPriBuffDirty.SclSpColMix = 1, \
!    SclSpColMix.ColMixRateSP23 \
!    = (SclSpColMix.ColMixRateSP23 & 0x00FF) | ((s3ccrt) << 8))
! 
! #define SCL_GET_S3CCRT() \
!   ((SclSpColMix.ColMixRateSP23 & 0x1F00) >> 8)
! 
! #define SCL_SET_S4CCRT(/* 5bits */ s4ccrt) \
!   (SclPriBuffDirty.SclSpColMix = 1, \
!    SclSpColMix.ColMixRateSP45 \
!    = (SclSpColMix.ColMixRateSP45 & 0xFF00) | ((s4ccrt)))
! 
! #define SCL_GET_S4CCRT() \
!   ((SclSpColMix.ColMixRateSP45 & 0x001F))
! 
! #define SCL_SET_S5CCRT(/* 5bits */ s5ccrt) \
!   (SclPriBuffDirty.SclSpColMix = 1, \
!    SclSpColMix.ColMixRateSP45 \
!    = (SclSpColMix.ColMixRateSP45 & 0x00FF) | ((s5ccrt) << 8))
! 
! #define SCL_GET_S5CCRT() \
!   ((SclSpColMix.ColMixRateSP45 & 0x1F00) >> 8)
! 
! #define SCL_SET_S6CCRT(/* 5bits */ s6ccrt) \
!   (SclPriBuffDirty.SclSpColMix = 1, \
!    SclSpColMix.ColMixRateSP67 \
!    = (SclSpColMix.ColMixRateSP67 & 0xFF00) | ((s6ccrt)))
! 
! #define SCL_GET_S6CCRT() \
!   ((SclSpColMix.ColMixRateSP67 & 0x001F))
! 
! #define SCL_SET_S7CCRT(/* 5bits */ s7ccrt) \
!   (SclPriBuffDirty.SclSpColMix = 1, \
!    SclSpColMix.ColMixRateSP67 \
!    = (SclSpColMix.ColMixRateSP67 & 0x00FF) | ((s7ccrt) << 8))
! 
! #define SCL_GET_S7CCRT() \
!   ((SclSpColMix.ColMixRateSP67 & 0x1F00) >> 8)
! 
! /* VDP-II manual p.138 */
! /*-- カラー RAM アドレスオフセット N0|R1, N1|EXBG, N2, N3, R0, SPRITE */
! 
! #define SCL_SET_N0CAOS(/* 3bits */ n0caos) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorRamOffset0 \
!    = (SclOtherPri.ColorRamOffset0 & 0xFFF0) | ((n0caos)))
! 
! #define SCL_GET_N0CAOS() \
!   ((SclOtherPri.ColorRamOffset0 & 0x0007))
! 
! #define SCL_SET_N1CAOS(/* 3bits */ n1caos) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorRamOffset0 \
!    = (SclOtherPri.ColorRamOffset0 & 0xFF0F) | ((n1caos) << 4))
! 
! #define SCL_GET_N1CAOS() \
!   ((SclOtherPri.ColorRamOffset0 & 0x0070) >> 4)
! 
! #define SCL_SET_N2CAOS(/* 3bits */ n2caos) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorRamOffset0 \
!    = (SclOtherPri.ColorRamOffset0 & 0xF0FF) | ((n2caos) << 8))
! 
! #define SCL_GET_N2CAOS() \
!   ((SclOtherPri.ColorRamOffset0 & 0x0700) >> 8)
! 
! #define SCL_SET_N3CAOS(/* 3bits */ n3caos) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorRamOffset0 \
!    = (SclOtherPri.ColorRamOffset0 & 0x0FFF) | ((n3caos) << 12))
! 
! #define SCL_GET_N3CAOS() \
!   ((SclOtherPri.ColorRamOffset0 & 0x7000) >> 12)
! 
! #define SCL_SET_R0CAOS(/* 3bits */ r0caos) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorRamOffset1 \
!    = (SclOtherPri.ColorRamOffset1 & 0xFFF0) | ((r0caos) << 0))
! 
! #define SCL_GET_R0CAOS() \
!   ((SclOtherPri.ColorRamOffset1 & 0x0007) >> 0)
! 
! #define SCL_SET_SPCAOS(/* 3bits */ spcaos) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorRamOffset1 \
!    = (SclOtherPri.ColorRamOffset1 & 0xFF0F) | ((spcaos) << 4))
! 
! #define SCL_GET_SPCAOS() \
!   ((SclOtherPri.ColorRamOffset1 & 0x0070) >> 4)
! 
! 
! /*----- ラインカラー画面イネーブル N0|R1, N1|EXBG, N2, N3, R0, SPRITE */
! 
! #define SCL_SET_N0LCEN(/* 1bit */ n0lcen) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.LineColorEnable \
!    = (SclOtherPri.LineColorEnable & 0xFFFE) | ((n0lcen)))
! 
! #define SCL_GET_N0LCEN() \
!   ((SclOtherPri.LineColorEnable & 0x0001))
! 
! #define SCL_SET_N1LCEN(/* 1bit */ n1lcen) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.LineColorEnable \
!    = (SclOtherPri.LineColorEnable & 0xFFFD) | ((n1lcen) << 1))
! 
! #define SCL_GET_N1LCEN() \
!   ((SclOtherPri.LineColorEnable & 0x0002) >> 1)
! 
! #define SCL_SET_N2LCEN(/* 1bit */ n2lcen) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.LineColorEnable \
!    = (SclOtherPri.LineColorEnable & 0xFFFB) | ((n2lcen) << 2))
! 
! #define SCL_GET_N2LCEN() \
!   ((SclOtherPri.LineColorEnable & 0x0004) >> 2)
! 
! #define SCL_SET_N3LCEN(/* 1bit */ n3lcen) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.LineColorEnable \
!    = (SclOtherPri.LineColorEnable & 0xFFF7) | ((n3lcen) << 3))
! 
! #define SCL_GET_N3LCEN() \
!   ((SclOtherPri.LineColorEnable & 0x0008) >> 3)
! 
! #define SCL_SET_R0LCEN(/* 1bit */ r0lcen) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.LineColorEnable \
!    = (SclOtherPri.LineColorEnable & 0xFFEF) | ((r0lcen) << 4))
! 
! #define SCL_GET_R0LCEN() \
!   ((SclOtherPri.LineColorEnable & 0x0010) >> 4)
! 
! #define SCL_SET_SPLCEN(/* 1bit */ splcen) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.LineColorEnable \
!    = (SclOtherPri.LineColorEnable & 0xFFDF) | ((splcen) << 5))
! 
! #define SCL_GET_SPLCEN() \
!   ((SclOtherPri.LineColorEnable & 0x0020) >> 5)
! 
! /*-------- 特殊プライオリティモード N0|R1, N1|EXBG, N2, N3, R0 */
! 
! #define SCL_SET_N0SPRM(/* 2bits */ n0sprm) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.SpecialPriorityMode \
!    = (SclOtherPri.SpecialPriorityMode & 0xFFFC) | ((n0sprm)))
! 
! #define SCL_GET_N0SPRM() \
!   ((SclOtherPri.SpecialPriorityMode & 0x0003))
! 
! #define SCL_SET_N1SPRM(/* 2bits */ n1sprm) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.SpecialPriorityMode \
!    = (SclOtherPri.SpecialPriorityMode & 0xFFF3) | ((n1sprm) << 2))
! 
! #define SCL_GET_N1SPRM() \
!   ((SclOtherPri.SpecialPriorityMode & 0x000C) >> 2)
! 
! #define SCL_SET_N2SPRM(/* 2bits */ n2sprm) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.SpecialPriorityMode \
!    = (SclOtherPri.SpecialPriorityMode & 0xFFCF) | ((n2sprm) << 4))
! 
! #define SCL_GET_N2SPRM() \
!   ((SclOtherPri.SpecialPriorityMode & 0x0030) >> 4)
! 
! #define SCL_SET_N3SPRM(/* 2bits */ n3sprm) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.SpecialPriorityMode \
!    = (SclOtherPri.SpecialPriorityMode & 0xFF3F) | ((n3sprm) << 6))
! 
! #define SCL_GET_N3SPRM() \
!   ((SclOtherPri.SpecialPriorityMode & 0x00C0) >> 6)
! 
! #define SCL_SET_R0SPRM(/* 2bits */ r0sprm) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.SpecialPriorityMode \
!    = (SclOtherPri.SpecialPriorityMode & 0xFCFF) | ((r0sprm) << 8))
! 
! #define SCL_GET_R0SPRM() \
!   ((SclOtherPri.SpecialPriorityMode & 0x0300) >> 8)
! 
! /*---------プライオリティー番号 N0|R1, N1|EXBG, N2, N3, R0 */
! 
! #define SCL_SET_N0PRIN(/* 3 bits */ n0prin) \
!   (SclPriBuffDirty.SclBgPriNum = 1, \
!    SclBgPriNum.PriorityNumberNBG01 \
!    = (SclBgPriNum.PriorityNumberNBG01 & 0xFF00) | ((n0prin)))
! 
! #define SCL_GET_N0PRIN() \
!   ((SclBgPriNum.PriorityNumberNBG01 & 0x0007))
! 
! #define SCL_SET_N1PRIN(/* 3 bits */ n1prin) \
!   (SclPriBuffDirty.SclBgPriNum = 1, \
!    SclBgPriNum.PriorityNumberNBG01 \
!    = (SclBgPriNum.PriorityNumberNBG01 & 0x00FF) | ((n1prin) << 8))
! 
! #define SCL_GET_N1PRIN() \
!   ((SclBgPriNum.PriorityNumberNBG01 & 0x0700) >> 8)
! 
! #define SCL_SET_N2PRIN(/* 3 bits */ n2prin) \
!   (SclPriBuffDirty.SclBgPriNum = 1, \
!    SclBgPriNum.PriorityNumberNBG23 \
!    = (SclBgPriNum.PriorityNumberNBG23 & 0xFF00) | ((n2prin)))
! 
! #define SCL_GET_N2PRIN() \
!   ((SclBgPriNum.PriorityNumberNBG23 & 0x0007))
! 
! #define SCL_SET_N3PRIN(/* 3 bits */ n3prin) \
!   (SclPriBuffDirty.SclBgPriNum = 1, \
!    SclBgPriNum.PriorityNumberNBG23 \
!    = (SclBgPriNum.PriorityNumberNBG23 & 0x00FF) | ((n3prin) << 8))
! 
! #define SCL_GET_N3PRIN() \
!   ((SclBgPriNum.PriorityNumberNBG23 & 0x0700) >> 8)
! 
! #define SCL_SET_R0PRIN(/* 3 bits */ r0prin) \
!   (SclPriBuffDirty.SclBgPriNum = 1, \
!    SclBgPriNum.PriorityNumberRBG0 \
!    = ((r0prin)))
! 
! #define SCL_GET_R0PRIN() \
!    ((SclBgPriNum.PriorityNumberRBG0 & 0x0007))
! 
! #define SCL_SET_BOKEN(/* 1 bits */ boken) /* ボカシ演算イネーブル */\
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorMixControl \
!    = (SclOtherPri.ColorMixControl & 0x7FFF) | ((boken) << 15))
! 
! #define SCL_GET_B0KEN() \
!   ((SclOtherPri.ColorMixControl & 0x8000) >> 15)
! 
! #define SCL_SET_BOKN(/* 3 bits */ bokn) /* ボカシ画面番号 */\
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorMixControl \
!    = (SclOtherPri.ColorMixControl & 0x8FFF) | ((bokn) << 12))
! 
! #define SCL_GET_BOKN() \
!   ((SclOtherPri.ColorMixControl & 0x7000) >> 12)
! 
! #define SCL_SET_EXCCEN(/* 1 bit */ exccn) /* 拡張カラー演算イネーブル */\
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorMixControl \
!    = (SclOtherPri.ColorMixControl & 0xFBFF) | ((exccn) << 10))
! 
! #define SCL_GET_EXCCEN() \
!   ((SclOtherPri.ColorMixControl & 0x0400) >> 10)
! 
! #define SCL_SET_CCRTMD(/* 1 bit */ ccrtmd) /* カラー演算割合モード */\
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorMixControl \
!    = (SclOtherPri.ColorMixControl & 0xFDFF) | ((Uint32)(ccrtmd) << 9))
! 
! #define SCL_GET_CCRTMD() \
!   ((SclOtherPri.ColorMixControl & 0x0200) >> 9)
! 
! #define SCL_SET_CCMD(/* 1 bit */ ccmd) /* カラー演算モード */\
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorMixControl \
!    = (SclOtherPri.ColorMixControl & 0xFEFF) | ((Uint32)(ccmd) << 8))
! 
! #define SCL_GET_CCMD() \
!   ((SclOtherPri.ColorMixControl & 0x0100) >> 8)
! 
! /*------ カラー演算イネーブル N0|R1, N1|EXBG, N2, N3, R0, LC, SPRITE */ 
! #define SCL_SET_SPCCEN(/* 1 bit */ spccen) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorMixControl \
!    = (SclOtherPri.ColorMixControl & 0xFFBF) | ((spccen) << 6))
! 
! #define SCL_GET_SPCCEN() \
!   ((SclOtherPri.ColorMixControl & 0x0040) >> 6)
! 
! #define SCL_SET_LCCCEN(/* 1 bit */ lcccen) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorMixControl \
!    = (SclOtherPri.ColorMixControl & 0xFFDF) | ((lcccen) << 5))
! 
! #define SCL_GET_LCCCEN() \
!   ((SclOtherPri.ColorMixControl & 0x0020) >> 5)
! 
! #define SCL_SET_R0CCEN(/* 1 bit */ r0ccen) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorMixControl \
!    = (SclOtherPri.ColorMixControl & 0xFFEF) | ((r0ccen) << 4))
! 
! #define SCL_GET_R0CCEN() \
!   ((SclOtherPri.ColorMixControl & 0x0010) >> 4)
! 
! #define SCL_SET_N3CCEN(/* 1 bit */ n3ccen) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorMixControl \
!    = (SclOtherPri.ColorMixControl & 0xFFF7) | ((n3ccen) << 3))
! 
! #define SCL_GET_N3CCEN() \
!   ((SclOtherPri.ColorMixControl & 0x0008) >> 3)
! 
! #define SCL_SET_N2CCEN(/* 1 bit */ n2ccen) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorMixControl \
!    = (SclOtherPri.ColorMixControl & 0xFFFB) | ((n2ccen) << 2))
! 
! #define SCL_GET_N2CCEN() \
!   ((SclOtherPri.ColorMixControl & 0x0004) >> 2)
! 
! #define SCL_SET_N1CCEN(/* 1 bit */ n1ccen) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorMixControl \
!    = (SclOtherPri.ColorMixControl & 0xFFFD) | ((n1ccen) << 1))
!   
! #define SCL_GET_N1CCEN() \
!   ((SclOtherPri.ColorMixControl & 0x0002) >> 1)
! 
! #define SCL_SET_N0CCEN(/* 1 bit */ n0ccen) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorMixControl \
!    = (SclOtherPri.ColorMixControl & 0xFFFE) | ((n0ccen)))
! 
! #define SCL_GET_N0CCEN() \
!   ((SclOtherPri.ColorMixControl & 0x0001))
! 
! 
! /*-------------- 特殊カラー演算モード N0|R1, N1|EXBG, N2, N3, R0 */
! #define SCL_SET_N0SCCM(/* 2 bits */ n0sccm) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.SpecialColorMixMode \
!    = (SclOtherPri.SpecialColorMixMode & 0xFFFC) | ((n0sccm)))
! 
! #define SCL_GET_N0SCCM() \
!   ((SclOtherPri.SpecialColorMixMode & 0x0003))
! 
! #define SCL_SET_N1SCCM(/* 2 bits */ n1sccm) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.SpecialColorMixMode \
!    = (SclOtherPri.SpecialColorMixMode & 0xFFF3) | ((n1sccm) << 2))
! 
! #define SCL_GET_N1SCCM() \
!   ((SclOtherPri.SpecialColorMixMode & 0x000C) >> 2)
! 
! #define SCL_SET_N2SCCM(/* 2 bits */ n2sccm) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.SpecialColorMixMode \
!    = (SclOtherPri.SpecialColorMixMode & 0xFFCF) | ((n2sccm) << 4))
! 
! #define SCL_GET_N2SCCM() \
!   ((SclOtherPri.SpecialColorMixMode & 0x0030) >> 4)
! 
! #define SCL_SET_N3SCCM(/* 2 bits */ n3sccm) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.SpecialColorMixMode \
!    = (SclOtherPri.SpecialColorMixMode & 0xFF3F) | ((n3sccm) << 6))
! 
! #define SCL_GET_N3SCCM() \
!   ((SclOtherPri.SpecialColorMixMode & 0x00C0) >> 6)
! 
! #define SCL_SET_R0SCCM(/* 2 bits */ r0sccm) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.SpecialColorMixMode \
!   = (SclOtherPri.SpecialColorMixMode & 0xFCFF) | ((r0sccm) << 8))
! 
! #define SCL_GET_R0SCCM() \
!   ((SclOtherPri.SpecialColorMixMode & 0x0300) >> 8)
! 
! /*------ スクロール面用カラー演算割合 N0|R1, N1|EXBG, N2, N3, R0, LC, BACK */
! #define SCL_SET_N0CCRT(/* 5 bits */ n0ccrt) \
!   (SclPriBuffDirty.SclBgColMix = 1, \
!    SclBgColMix.ColMixRateNBG01 \
!    = (SclBgColMix.ColMixRateNBG01 & 0xFF00) | ((n0ccrt)))
! 
! #define SCL_GET_N0CCRT() \
!   ((SclBgColMix.ColMixRateNBG01 & 0x001F))
! 
! #define SCL_SET_N1CCRT(/* 5 bits */ n1ccrt) \
!   (SclPriBuffDirty.SclBgColMix = 1, \
!    SclBgColMix.ColMixRateNBG01 \
!    = (SclBgColMix.ColMixRateNBG01 & 0x00FF) | ((n1ccrt) << 8))
! 
! #define SCL_GET_N1CCRT() \
!   ((SclBgColMix.ColMixRateNBG01 & 0x1F00) >> 8)
! 
! #define SCL_SET_N2CCRT(/* 5 bits */ n2ccrt) \
!   (SclPriBuffDirty.SclBgColMix = 1, \
!    SclBgColMix.ColMixRateNBG23 \
!    = (SclBgColMix.ColMixRateNBG23 & 0xFF00) | ((n2ccrt)))
! 
! #define SCL_GET_N2CCRT() \
!   ((SclBgColMix.ColMixRateNBG23 & 0x001F))
! 
! #define SCL_SET_N3CCRT(/* 5 bits */ n3ccrt) \
!   (SclPriBuffDirty.SclBgColMix = 1, \
!    SclBgColMix.ColMixRateNBG23 \
!    = (SclBgColMix.ColMixRateNBG23 & 0x00FF) | ((n3ccrt) << 8))
! 
! #define SCL_GET_N3CCRT() \
!   ((SclBgColMix.ColMixRateNBG23 & 0x1F00) >> 8)
! 
! #define SCL_SET_R0CCRT(/* 5 bits */ r0ccrt) \
!   (SclPriBuffDirty.SclBgColMix = 1, \
!    SclBgColMix.ColMixRateRBG0 \
!    = ((r0ccrt)))
! 
! #define SCL_GET_R0CCRT() \
!   ((SclBgColMix.ColMixRateRBG0 & 0x001F))
! 
! #define SCL_SET_LCCCRT(/* 5 bits */ lcccrt) \
!   (SclPriBuffDirty.SclBgColMix = 1, \
!    SclBgColMix.ColMixRateLCBAK \
!    = (SclBgColMix.ColMixRateLCBAK & 0xFF00) | ((lcccrt)))
! 
! #define SCL_GET_LCCCRT() \
!   ((SclBgColMix.ColMixRateLCBAK & 0x001F))
! 
! #define SCL_SET_BKCCRT(/* 5 bits */ bkccrt) \
!   (SclPriBuffDirty.SclBgColMix = 1, \
!    SclBgColMix.ColMixRateLCBAK \
!    = (SclBgColMix.ColMixRateLCBAK & 0x00FF) | ((bkccrt) << 8))
! 
! #define SCL_GET_BKCCRT() \
!   ((SclBgColMix.ColMixRateLCBAK & 0x1F00) >> 8)
! 
! /*-- カラーオフセットイネーブル N0|R1, N1|EXBG, N2, N3, R0, BACK, SPRITE */
! 
! #define SCL_SET_N0COEN(/* 1 bit */ n0coen) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetEnable \
!    = (SclColOffset.ColorOffsetEnable & 0xFFFE) | ((n0coen)))
! 
! #define SCL_GET_N0COEN() \
!   ((SclColOffset.ColorOffsetEnable & 0x0001))
! 
! #define SCL_SET_N1COEN(/* 1 bit */ n1coen) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetEnable \
!    = (SclColOffset.ColorOffsetEnable & 0xFFFD) | ((n1coen) << 1))
! 
! #define SCL_GET_N1COEN() \
!   ((SclColOffset.ColorOffsetEnable & 0x0002) >> 1)
! 
! #define SCL_SET_N2COEN(/* 1 bit */ n2coen) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetEnable \
!    = (SclColOffset.ColorOffsetEnable & 0xFFFB) | ((n2coen) << 2))
! 
! #define SCL_GET_N2COEN() \
!   ((SclColOffset.ColorOffsetEnable & 0x0004) >> 2)
! 
! #define SCL_SET_N3COEN(/* 1 bit */ n3coen) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetEnable \
!    = (SclColOffset.ColorOffsetEnable & 0xFFF7) | ((n3coen) << 3))
! 
! #define SCL_GET_N3COEN() \
!   ((SclColOffset.ColorOffsetEnable & 0x0008) >> 3)
! 
! #define SCL_SET_R0COEN(/* 1 bit */ r0coen) \
!    (SclPriBuffDirty.SclColOffset = 1, \
!     SclColOffset.ColorOffsetEnable \
!     = (SclColOffset.ColorOffsetEnable & 0xFFEF) | ((r0coen) << 4))
! 
! #define SCL_GET_R0COEN() \
!   ((SclColOffset.ColorOffsetEnable & 0x0010) >> 4)
! 
! #define SCL_SET_BKCOEN(/* 1 bit */ bkcoen) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetEnable \
!    = (SclColOffset.ColorOffsetEnable & 0xFFDF) | ((bkcoen) << 5))
! 
! #define SCL_GET_BKCOEN() \
!   ((SclColOffset.ColorOffsetEnable & 0x0020) >> 5)
! 
! #define SCL_SET_SPCOEN(/* 1 bit */ spcoen) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetEnable \
!    = (SclColOffset.ColorOffsetEnable & 0xFFBF) | ((spcoen) << 6))
! 
! #define SCL_GET_SPCOEN() \
!   ((SclColOffset.ColorOffsetEnable & 0x0040) >> 6)
! 
! /*--- カラーオフセットレジスタ選択 N0|R1, N1|EXBG, N2, N3, R0, BACK, SPRITE */
! 
! #define SCL_SET_N0COSL(/* 1 bit */ n0cosl) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetSelect \
!    = (SclColOffset.ColorOffsetSelect & 0xFFFE) | (n0cosl))
! 
! #define SCL_GET_N0COSL() \
!   ((SclColOffset.ColorOffsetSelect & 0x0001))
! 
! #define SCL_SET_N1COSL(/* 1 bit */ n1cosl) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetSelect \
!    = (SclColOffset.ColorOffsetSelect & 0xFFFD) | ((n1cosl) << 1))
! 
! #define SCL_GET_N1COSL() \
!   ((SclColOffset.ColorOffsetSelect & 0x0002) >> 1)
! 
! #define SCL_SET_N2COSL(/* 1 bit */ n2cosl) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetSelect \
!    = (SclColOffset.ColorOffsetSelect & 0xFFFB) | ((n2cosl) << 2))
! 
! #define SCL_GET_N2COSL() \
!   ((SclColOffset.ColorOffsetSelect & 0x0004) >> 2)
! 
! #define SCL_SET_N3COSL(/* 1 bit */ n3cosl) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetSelect \
!    = (SclColOffset.ColorOffsetSelect & 0xFFF7) | ((n3cosl) << 3))
! 
! #define SCL_GET_N3COSL() \
!   ((SclColOffset.ColorOffsetSelect & 0x0008) >> 3)
! 
! #define SCL_SET_R0COSL(/* 1 bit */ r0cosl) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetSelect \
!    = (SclColOffset.ColorOffsetSelect & 0xFFEF) | ((r0cosl) << 4))
! 
! #define SCL_GET_R0COSL() \
!   ((SclColOffset.ColorOffsetSelect & 0x0010) >> 4)
! 
! #define SCL_SET_BKCOSL(/* 1 bit */ bkcosl) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetSelect \
!    = (SclColOffset.ColorOffsetSelect & 0xFFDF) | ((bkcosl) << 5))
! 
! #define SCL_GET_BKCOSL() \
!   ((SclColOffset.ColorOffsetSelect & 0x0020) >> 5)
! 
! #define SCL_SET_SPCOSL(/* 1 bit */ spcosl) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetSelect \
!    = (SclColOffset.ColorOffsetSelect & 0xFFBF) | ((spcosl) << 6))
! 
! #define SCL_GET_SPCOSL() \
!   ((SclColOffset.ColorOffsetSelect & 0x0040) >> 6)
! 
! /* カラーオフセットレジスタ A */
! #define SCL_SET_COARD(/* 9 bit */ coard) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetA_RED \
!    = (coard))
! 
! #define SCL_GET_COARD() \
!   (SclColOffset.ColorOffsetA_RED & 0x01FF)
! 
! #define SCL_SET_COAGR(/* 9 bit */ coagr) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetA_GREEN \
!    = (coagr))
! 
! #define SCL_GET_COAGR() \
!   (SclColOffset.ColorOffsetA_GREEN & 0x01FF)
! 
! #define SCL_SET_COABL(/* 9 bit */ coabl) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetA_BLUE \
!    = (coabl))
! 
! #define SCL_GET_COABL() \
!   (SclColOffset.ColorOffsetA_BLUE & 0x01FF)
! 
! /* カラーオフセットレジスタ B*/
! #define SCL_SET_COBRD(/* 9 bit */ cobrd) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetB_RED \
!    = (cobrd))
! 
! #define SCL_GET_COBRD() \
!    (SclColOffset.ColorOffsetB_RED & 0x01FF)
! 
! #define SCL_SET_COBGR(/* 9 bit */ cobgr) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetB_GREEN \
!    = (cobgr))
! 
! #define SCL_GET_COBGR() \
!   (SclColOffset.ColorOffsetB_GREEN & 0x01FF)
! 
! #define SCL_SET_COBBL(/* 9 bit */ cobbl) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetB_BLUE \
!    = (cobbl))
! 
! #define SCL_GET_COBBL() \
!   (SclColOffset.ColorOffsetB_BLUE & 0x01FF)
! 
! /*----------- シャドウコントロール N0|R1, N1|EXBG, N2, N3, R0, BACK */
! 
! #define SCL_SET_N0SDEN(/* 1 bit */ n0sden) \
!    (SclPriBuffDirty.SclOtherPri = 1, \
!     SclOtherPri.ShadowControl \
!     = (SclOtherPri.ShadowControl & 0xFFFE) | ((n0sden)))
! 
! #define SCL_GET_N0SDEN() \
!   ((SclOtherPri.ShadowControl & 0x0001))
! 
! #define SCL_SET_N1SDEN(/* 1 bit */ n1sden) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ShadowControl \
!    = (SclOtherPri.ShadowControl & 0xFFFD) | ((n1sden) << 1))
! 
! #define SCL_GET_N1SDEN() \
!   ((SclOtherPri.ShadowControl & 0x0002) >> 1)
! 
! #define SCL_SET_N2SDEN(/* 1 bit */ n2sden) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ShadowControl \
!    = (SclOtherPri.ShadowControl & 0xFFFB) | ((n2sden) << 2))
! 
! #define SCL_GET_N2SDEN() \
!   ((SclOtherPri.ShadowControl & 0x0004) >> 2)
! 
! #define SCL_SET_N3SDEN(/* 1 bit */ n3sden) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ShadowControl \
!    = (SclOtherPri.ShadowControl & 0xFFF7) | ((n3sden) << 3))
! 
! #define SCL_GET_N3SDEN() \
!   ((SclOtherPri.ShadowControl & 0x0008) >> 3)
! 
! #define SCL_SET_R0SDEN(/* 1 bit */ r0sden) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ShadowControl \
!    = (SclOtherPri.ShadowControl & 0xFFEF) | ((r0sden) << 4))
! 
! #define SCL_GET_R0SDEN() \
!   ((SclOtherPri.ShadowControl & 0x0010) >> 4)
! 
! #define SCL_SET_BKSDEN(/* 1 bit */ bksden) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ShadowControl \
!    = (SclOtherPri.ShadowControl & 0xFFDF) | ((bksden) << 5))
! 
! #define SCL_GET_BKSDEN() \
!   ((SclOtherPri.ShadowControl & 0x0020) >> 5)
! 
! /*--------------------------------------- 透明シャドウセレクト */
! #define SCL_SET_TPSDSL(/* 1 bit */ tpsden) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ShadowControl \
!    = (SclOtherPri.ShadowControl & 0xFEFF) | ((tpsden) << 8))
! 
! #define SCL_GET_TPSDSL() \
!   ((SclOtherPri.ShadowControl & 0x0100) >> 8)
! 
! /*---------------------------カラー RAM モード */
! /* 0x1800E 番地にあるので スクロールライブラリで設定する */
! 
! /* 値の定義 */
! 
! #define SCL_RBG0	0x00000001
! #define SCL_RBG1	0x00000002
! #define SCL_NBG0	0x00000004
! #define SCL_NBG1	0x00000008
! #define SCL_NBG2	0x00000010
! #define SCL_NBG3	0x00000020
! 
! #define SCL_EXBG	0x00000080
! #define SCL_SPR 	0x00000100
! #define SCL_SP0 	0x00000100
! #define SCL_SP1 	0x00000200
! #define SCL_SP2 	0x00000400
! #define SCL_SP3 	0x00000800
! #define SCL_SP4 	0x00001000
! #define SCL_SP5 	0x00002000
! #define SCL_SP6 	0x00004000
! #define SCL_SP7 	0x00008000
! #define SCL_RP  	0x00010000
! #define SCL_RP_R	0xfffeffff
! #define SCL_CC  	0x00020000
! #define SCL_LNCL	0x00040000
! #define SCL_BACK	0x00080000
! 
! #define SCL_RBG_TB_A	SCL_RBG0
! #define SCL_RBG_TB_B	SCL_RBG1
! 
! #define SCL_CRM15_1024 0
! #define SCL_CRM15_2048 1
! #define SCL_CRM24_1024 2
! 
! /* スプライトのタイプ指定 */
! #define SCL_TYPE0	0
! #define SCL_TYPE1	1
! #define SCL_TYPE2	2
! #define SCL_TYPE3	3
! #define SCL_TYPE4	4
! #define SCL_TYPE5	5
! #define SCL_TYPE6	6
! #define SCL_TYPE7	7
! #define SCL_TYPE8	8
! #define SCL_TYPE9	9
! #define SCL_TYPEA	10
! #define SCL_TYPEB	11
! #define SCL_TYPEC	12
! #define SCL_TYPED	13
! #define SCL_TYPEE	14
! #define SCL_TYPEF	15
! 
! #define SCL_PALETTE	0
! #define SCL_MIX 	1
! 
! #define SCL_MSB_SHADOW	0
! #define SCL_SP_WINDOW	1
! 
! #define SCL_IF_BEHIND	0
! #define SCL_IF_EQUAL	1
! #define SCL_IF_FRONT	2
! #define SCL_MSB_ON	3
! 
! #define SCL_OFFSET_A	0
! #define SCL_OFFSET_B	1
! 
! #endif /* __PRI_MACRO */
! 
! extern SclOtherPriRegister  SclOtherPri;  /* いろいろ */
! 
! extern SclSpPriNumRegister  SclSpPriNum;  /* スプライトのプライオリティ番号 */
! 
! extern SclBgPriNumRegister  SclBgPriNum;  /* スクロールのプライオリティ番号 */
! 
! extern SclSpColMixRegister  SclSpColMix;  /* スプライトの色演算 */
! 
! extern SclBgColMixRegister  SclBgColMix;  /* スクロールの色演算 */
! 
! extern SclColOffsetRegister SclColOffset; /* カラーオフセット */
! 
! extern SclPriBuffDirtyFlags SclPriBuffDirty; /* レジスタバッファのダーティー・フラグ */
! 
! /*--- REAL Priority Registers (Pointer) ---*/
! 
! extern SclOtherPriRegister  *SclRealOtherPri;
! 
! extern SclSpPriNumRegister  *SclRealSpPriNum;
! 
! extern SclBgPriNumRegister  *SclRealBgPriNum;
! 
! extern SclSpColMixRegister  *SclRealSpColMix;
! 
! extern SclBgColMixRegister  *SclRealBgColMix;
! 
! extern SclColOffsetRegister *SclRealColOffset;
! 
! #endif /* __PRI_GLVAR */
! 
! /* ＶＤＰ２ライブラリのプロトタイプ宣言 */
! #ifndef	SEGA_SCL_PROTO
! #define SEGA_SCL_PROTO
! 
! extern	void	SCL_Vdp2Init(void);
! extern	void	SCL_SetDisplayMode(Uint8 interlace,Uint8 vertical,Uint8 horizontal);
! extern	void	SCL_InitVramConfigTb(SclVramConfig *tp);
! extern	void	SCL_InitConfigTb(SclConfig *scfg);
! extern	void	SCL_InitLineParamTb(SclLineparam *lp);
! extern	void	SCL_SetVramConfig(SclVramConfig *tp);
! extern	void	SCL_SetConfig(Uint16 sclnum, SclConfig *scfg);
! extern	void	SCL_SetCycleTable(Uint16 *tp);
! extern	void	SCL_Open(Uint32 sclnum);
! extern	void	SCL_Close(void);
! extern	void	SCL_SetLineParam(SclLineparam *lp);
! extern	void	SCL_MoveTo(Fixed32 x,Fixed32 y,Fixed32 z);
! extern	void	SCL_Move(Fixed32 x,Fixed32 y,Fixed32 z);
! extern	void	SCL_Scale(Fixed32 Sx, Fixed32 Sy);
! extern	void	SCL_SetColRamMode(Uint32 ComRamMode);
! extern	Uint32	SCL_InitRotateTable(Uint32 Address,Uint16 Mode,Uint32 rA,Uint32 rB);
! extern	void	SCL_RotateTo(Fixed32 xy,Fixed32 z,Fixed32 disp,Uint16 mode);
! extern	void	SCL_Rotate(Fixed32 xy,Fixed32 z,Fixed32 disp);
! extern	void	SCL_SetRotateViewPoint(Uint16 x,Uint16 y,Uint16 z);
! extern	void    SCL_SetRotateZoom(Fixed32 x,Fixed32 y);
! extern	void	SCL_SetRotateCenter(Uint16 x,Uint16 y,Uint16 z);
! extern	void	SCL_SetRotateCenterDisp(Uint16 x,Uint16 y);
! extern	void	SCL_SetCoefficientData(Uint32 sclnum,Uint16 *data,Uint16 x,Uint16 y);
! extern	void	SCL_SetLncl(Uint32 addr,Uint16 tbnum,Uint16 *palNumTb);
! extern	void	SCL_SetBack(Uint32 addr,Uint16 dataSize,Uint16 *dataTb);
! extern	void	SCL_SetMosaic(Uint32 surface,Uint8 x,Uint8 y);
! extern	void	SCL_SetSpriteMode(Uint8 Type, Uint8 ColMode, Uint8 WinMode);
! extern	Uint32	SCL_GetColRamMode(void);
! extern	void	SCL_SetColRam(Uint32 Object, Uint32 Index,Uint32 num,void *Color);
! extern	Uint32	SCL_AllocColRam(Uint32 Surface, Uint32 NumOfColors, Uint8 transparent);
! extern	void	SCL_FreeColRam(Uint32 Surface);
! extern	void	SCL_SetAutoColChg(Uint32 Surface,Uint32 Interval,Uint32 Index,
! 			Uint32 NumOfCol,Uint32 NumOfTbl,Uint32 *ChangeTbl);
! extern	Uint32	SCL_GetColRamOffset(Uint32 Object);
! extern	void	SCL_SetPriority(Uint32 Object, Uint8 Priority);
! extern	Uint8	SCL_GetPriority(Uint32 Object);
! extern	void	SCL_SetColMixMode(Uint32 ColMixPriority, Uint8 Mode);
! extern	void	SCL_SetColMixRate(Uint32 Surfaces, Uint8 Rate);
! extern	void	SCL_SetAutoColMix(Uint32 Surfaces,Uint32 Interval,Uint32 Time,
! 			Uint8 StartRate,Uint8 EndRate);
! extern	void	SCL_SetColOffset(Uint32 OffsetReg, Uint32 Surfaces,
! 			Sint16 red, Sint16 green, Sint16 blue);
! extern	void	SCL_IncColOffset(Uint32 OffsetReg,Sint16 red,Sint16 green,Sint16 blue);
! extern	void	SCL_SetAutoColOffset(Uint32 OffsetReg,Uint32 Interval,Uint32 Time,
! 				SclRgb *start,SclRgb *end);
! extern	void	SCL_EnableBlur(Uint32 Surface);
! extern	void	SCL_DisableBlur(void);
! extern	void	SCL_EnableLineCol(Uint32 Surface);
! extern	void	SCL_DisableLineCol(Uint32 Surface);
! extern	void	SCL_SetWindow(Uint8 win,Uint32 logic,Uint32 enable,Uint32 area,
! 			Uint16 sx,Uint16 sy,Uint16 ex,Uint16 ey);
! extern	void	SCL_SetLineWindow(Uint8 win,Uint32 logic,Uint32 enable,Uint32 area,
! 			Uint32 addr,Uint32 sy,Uint32 tbSize,SclLineWindowTb *tp);
! extern	void	SCL_SetSpriteWindow(Uint32 logic,Uint32 enable,Uint32 area);
! extern	void	SCL_SetFrameInterval(Uint16 count);
! extern	void	SCL_DisplayFrame(void);
! extern	void	SCL_VblankStart(void);
! extern	void	SCL_VblankEnd(void);
! extern	void	SCL_AbortAutoVe(void);
! 
! /* 画面サイズデフォルト */
! extern	Uint16	SclDisplayX;
! extern	Uint16	SclDisplayY;
! 
! /* レジスタバッファ */
! extern	SclSysreg	Scl_s_reg;
! extern	SclDataset	Scl_d_reg;
! extern	SclNorscl	Scl_n_reg;
! extern	SclRotscl	Scl_r_reg;
! extern	SclWinscl	Scl_w_reg;
! extern	Uint16		SclProcess;
! 
! #endif /* SEGA_SCL_PROTO */
diff -crB --binary sbl6/segalib/include/sega_spr.h sbl6_patch/segalib/include/sega_spr.h
*** sbl6/segalib/include/sega_spr.h	1996-02-08 05:23:50.000000000 -0500
--- sbl6_patch/segalib/include/sega_spr.h	2021-11-17 07:11:02.000000000 -0500
***************
*** 1,787 ****
! /*----------------------------------------------------------------------------
!  *  sega_spr.h -- SPR ライブラリ インクルードファイル
!  *  Copyright(c) 1994 SEGA
!  *  Written by H.E on 1994-07-25 Ver.1.00
!  *  Updated by H.E on 1994-07-25 Ver.1.00
!  *  Updated by H.O on 1995-11-14 Ver.1.00a SSHOFF対策
!  *
!  *  スプライト表示用インクルードファイルで使用スプライト表示ライブラリの種別に
!  *  より以下のように定義します。
!  *
!  *  （１）スプライト表示基本処理のみの場合
!  *
!  *        #include "sega_spr.h"
!  *
!  *  （２）スプライト表示拡張処理の場合
!  *
!  *        #define  _SPR2_
!  *        #include "sega_spr.h"
!  *
!  *  （３）スプライト３Ｄ表示処理の場合
!  *
!  *        #define  _SPR3_
!  *        #include "sega_spr.h"
!  *
!  *
!  *----------------------------------------------------------------------------
!  */
! 
! #ifndef SEGA_SPR_H
! #define SEGA_SPR_H
! 
! #include        "sega_xpt.h"
! #include        "sega_def.h"
! #include        "sega_mth.h"
! 
! /*------------------------------------------
!  * Select 3D & Sprite Execute Environment
!  *----------------------------------------*/
! #define  SPR_SYNC_VB_OUT
! #define  USE_SLAVE
! #define  USE_DSP
! #define  USE_INBETWEEN_OBJECT
! #define  USE_DEBUG_INFO
! 
! /*-----------------------------------
!  * Select 3D Execute Machine
!  *---------------------------------*/
! #define  _PC_         0
! #define  _INDIGO2_    1
! #define  _SH_         2
! 
! 
! /*
!  * Set Machine Environment
!  */
! #define NO_EXIST    0
! #define    EXIST    1
! 
! #if defined(_PC)
!    #define _MACHINE  _PC_
!    #define _DSP      NO_EXIST
!    #define _MATH        EXIST
! #endif
! 
! #if defined(_INDIGO2)
!    #define _MACHINE  _INDIGO2_
!    #define _DSP      NO_EXIST
!    #define _MATH        EXIST
! #endif
! 
! #if defined(_SH)
!    #define _MACHINE  _SH_
!    #define _DSP         EXIST
!    #define _MATH     NO_EXIST
! #endif
! 
! #ifdef _SPR3_
!    #define _SPR2_
! #endif
! 
! 
! /*
!  * EXTERNAL FUNCTION PROTOTYPE DECLARATIONS
!  */
! typedef void PARA_RTN(void *parm);
! void  SPR_InitSlaveSH(void);
! void  SPR_RunSlaveSH(PARA_RTN *routine, void *parm);
! void  SPR_WaitEndSlaveSH(void);
! 
! 
! /**************** SEGA_SP1.H *************************************************/
! /*
!  * GLOBAL DEFINES/MACROS DEFINES
!  */
! 
! #define  VRAM_SIZE           512*1024   /* 512 Kbyte                        */
! #define  FBUF_SIZE           256*1024   /* 256 Kbyte * 2 bank               */
! 
! #define  AUTO_FRAME_CHG           0     /* auto frame change mode           */
! #define  MANUAL_FRAME_CHG         1     /* manual frame change mode         */
! #define  NO_INTER_FRAME_CHG       2     /* no interval frame change mode    */
! #define  NO_INTER_VBE_FRAME_CHG   3     /* v-blank erase no interval frm chg*/
! 
! #define  SPR_FBCR_MANUAL     0x0003     /* frame buffer manual change       */
! #define  SPR_FBCR_AUTO       0x0000     /* frame buffer auto change         */
! #define  SPR_FBCR_ERASE      0x0002     /* frame buffer next erase on       */
! #define  SPR_FBCR_DIE        0x0008     /* double interlace on              */
! #define  SPR_FBCR_DIL        0x0004     /* double interlace plot line       */
! #define  SPR_FBCR_EOS        0x0010     /* even/odd data sampling select bit*/
! 
! #define  SPR_TV_NORMAL       0          /* Normal TV mode                   */
! #define  SPR_TV_HIRESO       1          /* High Resolution TV mode          */
! #define  SPR_TV_ROT16        2          /* Rotate 16 bit TV mode            */
! #define  SPR_TV_ROT8         3          /* Rotate 8 bit TV mode             */
! #define  SPR_TV_HDTV         4          /* HDTV TV mode                     */
! 
! #define  SPR_TV_320X224      0          /* Screen size 320 x 224            */
! #define  SPR_TV_320X240      1          /* Screen size 320 x 240            */
! #define  SPR_TV_352X224      2          /* Screen size 352 x 224            */
! #define  SPR_TV_352X240      3          /* Screen size 352 x 240            */
! #define  SPR_TV_640X224      4          /* Screen size 640 x 224            */
! #define  SPR_TV_640X240      5          /* Screen size 640 x 240            */
! #define  SPR_TV_704X224      6          /* Screen size 704 x 224            */
! #define  SPR_TV_704X240      7          /* Screen size 704 x 240            */
! 
! #define  SPR_W_TVMR          0x00000000 /* TV mode selection                */
! #define  SPR_W_FBCR          0x00000002 /* Frame buf change mode            */
! #define  SPR_W_PTMR          0x00000004 /* Draw start control               */
! #define  SPR_W_EWDR          0x00000006 /* Erase write data                 */
! #define  SPR_W_EWLR          0x00000008 /* Erase write area left top point  */
! #define  SPR_W_EWRR          0x0000000A /* Erase write area right bot point */
! #define  SPR_W_ENDR          0x0000000C /* Stop VDP1                        */
! #define  SPR_R_EDSR          0x00000010 /* Transfer complete status         */
! #define  SPR_R_LOPR          0x00000012 /* End command table address        */
! #define  SPR_R_COPR          0x00000014 /* Executing command table address  */
! #define  SPR_R_MODR          0x00000016 /* Write register Mode status       */
! 
! #define  SPR_R_EXTEN         0x00000002 /* VDP2 External Signal Enable Reg  */
! #define  SPR_R_TVSTAT        0x00000004 /* VDP2 TV Status Reg               */
! #define  SPR_R_VCNT          0x0000000A /* VDP2 V Counter Reg               */
! 
! #define  VRAM_ADDR           0x25C00000 /* Sprite IC VRAM area address      */
! #define  FBUF_ADDR           0x25C80000 /* Sprite frame buffer address      */
! #define  VDP1_REG_BASE       0x25D00000 /* Sprite IC Register base address  */
! #define  VDP2_REG_BASE       0x25F80000 /* Sprite IC Register base address  */
! 
! struct SprSpStatus {
!     Uint16  frameChgMode;             /* Frame Change Mode                 */
!     Uint16  frameEraseMode;           /* Frame Erase  Mode                 */
!     Uint16  vbInterval;               /* V-Blank Interval for Frame Change */
!     Uint16  eraseData;
!     Uint16  eraseLeftX;
!     Uint16  eraseTopY;
!     Uint16  eraseRightX;
!     Uint16  eraseBotY;
! };
! 
! typedef struct SprSpStatus SprSpStatus;
! 
! #define SPR_WRITE_REG(reg, val) \
!       *(volatile Uint16*)(VDP1_REG_BASE+(reg)) = (val)
! #define SPR_READ_REG(reg) \
!       (*(volatile Uint16*)(VDP1_REG_BASE+(reg)))
! #define SPR_SCLWRITE_REG(reg, val) \
!       *(volatile Uint16*)(VDP2_REG_BASE+(reg)) = (val)
! #define SPR_SCLREAD_REG(reg) \
!       (*(volatile Uint16*)(VDP2_REG_BASE+(reg)))
! 
! /*
!  * EXTERNAL VARIABLE DECLARATIONS
!  */
! #if	0
! /*
! **■1995-09-19	高橋智延
! **	幾つかのオブジェクトは、割り込み処理の中で触られるので、volatile にする。
! */
! extern Sint32  SpScreenX;               /* TV Screen X Size                  */
! extern Sint32  SpScreenY;               /* TV Screen Y Size                  */
! extern Uint16  SpFrameChgMode;          /* Frame Change Mode                 */
! extern Sint32  SpFrameEraseMode;        /* Frame Erase  Mode                 */
! extern Sint32  VBInterval;              /* V-Blank Interval for Frame Change */
! extern Sint32  VBIntervalCounter;       /* V-Blank Interval Counter          */
! extern Sint32  ReqDisplayFlag;          /* Display Request flag              */
! extern Uint16  SpTvMode;                /* TV Mode                           */
! extern Uint16  SpFbcrMode;              /* Frame Buffer Chane Mode           */
! extern Uint16  SpDie;                   /* Double Interlace Enable Flag      */
! extern Uint16  SpDil;                   /* Double Interlace Plot Line        */
! #else
! extern Sint32			SpScreenX;			/* TV Screen X Size                  */
! extern Sint32			SpScreenY;			/* TV Screen Y Size                  */
! extern volatile Uint16	SpFrameChgMode;		/* Frame Change Mode                 */
! extern volatile Sint32	SpFrameEraseMode;	/* Frame Erase  Mode                 */
! extern volatile Sint32	VBInterval;			/* V-Blank Interval for Frame Change */
! extern volatile Sint32	VBIntervalCounter;	/* V-Blank Interval Counter          */
! extern volatile Sint32	ReqDisplayFlag;		/* Display Request flag              */
! extern Uint16			SpTvMode;			/* TV Mode                           */
! extern Uint16			SpFbcrMode;			/* Frame Buffer Chane Mode           */
! extern Uint16			SpDie;				/* Double Interlace Enable Flag      */
! extern Uint16			SpDil;				/* Double Interlace Plot Line        */
! #endif
! 
! /*
!  * EXTERNAL FUNCTION PROTOTYPE DECLARATIONS
!  */
! void SPR_Initial (Uint8 **VRAM);
! void SPR_SetTvMode(Uint16 mode, Uint16 screenSize, Uint16 doubleInterlace);
! void SPR_GetStatus (SprSpStatus *spStatus);
! void SPR_SetEraseData (Uint16 eraseData, Uint16 leftX,  Uint16 topY,
!                                          Uint16 rightX, Uint16 botY);
! void SPR_WaitDrawEnd (void);
! void SPR_SetEosMode(Sint32 eosFlag);
! void sprMemCpyL(void *dst, void *src, int count);
! void sprMemCpyW(void *dst, void *src, int count);
! 
! 
! #ifdef _SPR2_
! /**************** SEGA_SP2.H *************************************************/
! /*
!  * GLOBAL DEFINES/MACROS DEFINES
!  */
! #define  FIXED32_MIN         0x80000000
! #define  FIXED32_MAX         0x7fffffff
! 
! #define  CTRL_END            0x8000     /* control word end bit mask        */
! #define  CTRL_SKIP           0x4000     /* control word skip bit mask       */
! #define  CTRL_JUMP           0x3000     /* control word jump bit mask       */
! #define  CTRL_ZOOM           0x0f00     /* control word zoom point bit mask */
! #define  CTRL_FUNC           0x000f     /* control word function bit mask   */
! #define  CTRL_DIR            0x0030     /* control word char read bit mask  */
! 
! #define  DRAW_COMPO          0x0003     /* draw mode word color compose mask*/
! #define  DRAW_GOURAU         0x0004     /* draw mode word gouraud shading   */
! #define  DRAW_GOURAU_GRAY    0x0804     /* draw mode word gray gour shading */
! #define  DRAW_COLOR          0x0038     /* draw mode word color mode mask   */
! #define  DRAW_MESH           0x0100     /* draw mode word mesh on           */
! 
! #define  COMPO_REP           0x0000     /* color compose reprace mode       */
! #define  COMPO_SHADOW        0x0001     /* color compose shadow mode        */
! #define  COMPO_HARF          0x0002     /* color compose harf luminance mode*/
! #define  COMPO_TRANS         0x0003     /* color compose trunslucent mode   */
! 
! #define  FUNC_NORMALSP       0x0000     /* draw normal sprite function      */
! #define  FUNC_SCALESP        0x0001     /* draw scaled sprite function      */
! #define  FUNC_DISTORSP       0x0002     /* draw distorted sprite function   */
! #define  FUNC_POLYGON        0x0004     /* draw polygon function            */
! #define  FUNC_POLYLINE       0x0005     /* draw polyline function           */
! #define  FUNC_LINE           0x0006     /* draw line function               */
! #define  FUNC_SCLIP          0x0009     /* set system clipping function     */
! #define  FUNC_UCLIP          0x0008     /* set user clipping function       */
! #define  FUNC_LCOORD         0x000a     /* set local coordinate function    */
! #define  FUNC_TEXTURE        0x0004     /* texture command group mask       */
! 
! #define  JUMP_NEXT           0x0000     /* jump next command                */
! #define  JUMP_ASSIGN         0x1000     /* jump assign command              */
! #define  JUMP_CALL           0x2000     /* call assign command              */
! #define  JUMP_RETURN         0x3000     /* return command subroutine        */
! #define  SKIP_NEXT           0x4000     /* skip next command                */
! #define  SKIP_ASSIGN         0x5000     /* skip assign command              */
! #define  SKIP_CALL           0x6000     /* skip call assign command         */
! #define  SKIP_RETURN         0x7000     /* skip return command subroutine   */
! 
! #define  ZOOM_NOPOINT        0x0000     /* zoom no point                    */
! #define  ZOOM_TL             0x0500     /* zoom point top left              */
! #define  ZOOM_TM             0x0600     /* zoom point top middle            */
! #define  ZOOM_TR             0x0700     /* zoom point top right             */
! #define  ZOOM_ML             0x0900     /* zoom point middle left           */
! #define  ZOOM_MM             0x0a00     /* zoom point center                */
! #define  ZOOM_MR             0x0b00     /* zoom point middle right          */
! #define  ZOOM_BL             0x0c00     /* zoom point bottom left           */
! #define  ZOOM_BM             0x0e00     /* zoom point bottom middle         */
! #define  ZOOM_BR             0x0f00     /* zoom point bottom right          */
! 
! #define  DIR_NOREV           0x0000     /* char read not reverse            */
! #define  DIR_TBREV           0x0020     /* char read top/bottom reverse     */
! #define  DIR_LRREV           0x0010     /* char read left/right reverse     */
! #define  DIR_LRTBREV         0x0030     /* char read left/right/top/bot rev */
! 
! #define  ECD_DISABLE         0x0080     /* ECD disabe & SPD enable          */
! #define  SPD_DISABLE         0x0040     /* ECD enable & SPD disable         */
! #define  ECDSPD_DISABLE      0x00c0     /* ECD & SPD disable                */
! #define  UCLPIN_ENABLE       0x0400     /* CLIP IN enable                   */
! #define  UCLPOUT_ENABLE      0x0600     /* CLIP OUT enable                  */
! #define  HSS_ENABLE          0x1000     /* HSS enable                       */
! #define  PCLP_ENABLE         0x0800     /* PCLP disable                     */
! 
! #define  COLOR_0             0x0000     /* 4 bit/pixel & 16 color bank mode */
! #define  COLOR_1             0x0008     /* 4 bit/pixel & 16 color lookup tbl*/
! #define  COLOR_2             0x0010     /* 8 bit/pixel &  64 color bank mode*/
! #define  COLOR_3             0x0018     /* 8 bit/pixel & 128 color bank mode*/
! #define  COLOR_4             0x0020     /* 8 bit/pixel & 256 color bank mode*/
! #define  COLOR_5             0x0028     /* 16 bit/pixel & RGB mode          */
! 
! #define  NO_GOUR             0xffff     /* no use Gouraud Shading Table No. */
! 
! #define  SPR_2DRAW_PRTY_ON   1          /* command draw priority on         */
! #define  SPR_2DRAW_PRTY_OFF  0          /* command draw priority off        */
! #define  SPR_2MOST_FAR       0          /* draw sprite most far position    */
! #define  SPR_2MOST_NEAR      0x7fffffff /* draw sprite most near position   */
! 
! 
! /*
!  * STRUCTURE DECLARATIONS
!  */
! struct SprSpCmd {                       /* Sprite Command Table             */
!     Uint16  control;                    /* control word                     */
!     Uint16  link;                       /* command link                     */
!     Uint16  drawMode;                   /* draw mode                        */
!     Uint16  color;                      /* color info.                      */
!     Uint16  charAddr;                   /* character address                */
!     Uint16  charSize;                   /* character size                   */
!     Sint16  ax;                         /* point A x                        */
!     Sint16  ay;                         /* point A y                        */
!     Sint16  bx;                         /* point B x                        */
!     Sint16  by;                         /* point B y                        */
!     Sint16  cx;                         /* point C x                        */
!     Sint16  cy;                         /* point C y                        */
!     Sint16  dx;                         /* point D x                        */
!     Sint16  dy;                         /* point D y                        */
!     Uint16  grshAddr;                   /* gouraud shading table address    */
!     Uint16  dummy;                      /* dummy area                       */
! };
! 
! struct SprSpCmdR {
!     Uint32  dummy[8];                   /* dummy area                       */
! };
! 
! 
! struct SprGourTbl {
!     Uint16  entry[4];
! };
! 
! struct SprGourTblR {
!     Uint32  entry[2];
! };
! 
! struct SprLookupTbl {
!     Uint16  entry[16];
! };
! 
! /*
!  * TYPEDEFS
!  */
! typedef Uint16 Vaddr;                       /* Relative Address in The VRAM  */
! typedef struct SprSpCmd     SprSpCmd;
! typedef struct SprSpCmdR    SprSpCmdR;
! typedef struct SprGourTbl   SprGourTbl;
! typedef struct SprGourTblR  SprGourTblR;
! typedef struct SprLookupTbl SprLookupTbl;
! typedef struct SprAreaSize  SprAreaSize;
! /* internal data type */
! typedef	struct SprCharTbl    SprCharTbl;
! typedef struct SprDrawPrtyBlk SprDrawPrtyBlk;
! typedef	struct Spr2WorkArea   Spr2WorkArea;
! 
! struct SprCharTbl {                         /* Character Entry Table         */
!     Vaddr     addr;                         /* Character Relative Address    */
!     Uint16    xySize;                       /* Charcter Size (X * Y)         */
!     Uint16    mode;                         /* Charcter Mode (0-5)           */
!     Uint16    color;                        /* Color Bank or LookUp Tbl No   */
!     Uint16    size;                         /* Charcter Size (by the 32 byte)*/
! };
! 
! struct SprDrawPrtyBlk {         /* 描画プライオリティブロックテーブル        */
!     Uint16      topNo;          /* 先頭コマンドチェインエントリ番号          */
!     Uint16      botNo;          /* 末尾コマンドチェインエントリ番号          */
! };
! 
! struct Spr2WorkArea {                    /* SP2 Work Area Define             */
!     Uint16         commandMax;           /* Command Max                      */
!     Uint16         gourTblMax;           /* Gour Tbl Max                     */
!     Uint16         lookupTblMax;         /* Lookup Tbl Max                   */
!     Uint16         charMax;              /* Char Max                         */
!     Uint16         drawPrtyBlkMax;       /* Draw Priority Block Max          */
!     SprCharTbl     *charTbl;             /* Character Tbl Pointer            */
!     SprSpCmd       *mstCmd;              /* Master Command Buffer            */
!     SprDrawPrtyBlk *mstDrawPrtyBlk;      /* Master Draw Priority Block       */
!     SprSpCmd       *slvCmd;              /* Slave Command Buffer             */
!     SprDrawPrtyBlk *slvDrawPrtyBlk;      /* Slave Draw Priority Block        */
!     SprGourTbl     *gourTbl;             /* Gour Tbl Max                     */
! };
! 
! struct SprAreaSize {                     /* SP2 Work Area Size               */
!     Uint16         commandMax;           /* Command Max                      */
!     Uint16         gourTblMax;           /* Gour Tbl Max                     */
!     Uint16         lookupTblMax;         /* Lookup Tbl Max                   */
!     Uint16         charMax;              /* Char Max                         */
!     Uint16         drawPrtyBlkMax;       /* Draw Priority Block Max          */
!     Uint16         useCommandCount;      /* Using Command Block Count        */
!     Uint16         charRemainBlkCount;   /* Char Total Remain Null Blk Count */
!     Uint16         charNullBlkMaxSize;   /* Char Null Block Max Size         */
! };
! 
! /*
!  * EXTERNAL VARIABLE DECLARATIONS
!  */
! extern Sint32  SpLCoordX;                   /* Local Origin X Position       */
! extern Sint32  SpLCoordY;                   /* Local Origin Y Position       */
! 
! #ifdef _SPR3_
! #define   SPR_2DefineWork(sp2WorkArea, sp2CommandMax, sp2GourTblMax, \
! 			  sp2LookupTblMax, sp2CharMax, sp2DrawPrtyBlkMax) \
! static SprCharTbl      sp2CharTbl         [sp2CharMax]; \
! static SprSpCmdR       sp2MstSpCmd        [sp2CommandMax/2]; \
! static SprDrawPrtyBlk  sp2MstDrawPrtyBlk  [sp2DrawPrtyBlkMax]; \
! static SprSpCmdR       sp2SlvSpCmd        [sp2CommandMax/2]; \
! static SprDrawPrtyBlk  sp2SlvDrawPrtyBlk  [sp2DrawPrtyBlkMax]; \
! static SprGourTblR     sp2GourTbl         [sp2GourTblMax+32]; \
! static Spr2WorkArea sp2WorkArea  = {  \
! 	sp2CommandMax, sp2GourTblMax+32, sp2LookupTblMax, sp2CharMax, \
! 	sp2DrawPrtyBlkMax, sp2CharTbl, \
! 	(SprSpCmd*)sp2MstSpCmd, sp2MstDrawPrtyBlk, (SprSpCmd*)sp2SlvSpCmd, \
!         sp2SlvDrawPrtyBlk, (SprGourTbl*)sp2GourTbl };
! #else
! #define   SPR_2DefineWork(sp2WorkArea, sp2CommandMax, sp2GourTblMax, \
! 			  sp2LookupTblMax, sp2CharMax, sp2DrawPrtyBlkMax) \
! static SprCharTbl      sp2CharTbl         [sp2CharMax]; \
! static SprSpCmdR       sp2MstSpCmd        [sp2CommandMax]; \
! static SprDrawPrtyBlk  sp2MstDrawPrtyBlk  [sp2DrawPrtyBlkMax]; \
! static SprGourTblR     sp2GourTbl         [sp2GourTblMax+1]; \
! static Spr2WorkArea sp2WorkArea  = {  \
! 	sp2CommandMax, sp2GourTblMax, sp2LookupTblMax, sp2CharMax, \
! 	sp2DrawPrtyBlkMax, sp2CharTbl, \
! 	(SprSpCmd*)sp2MstSpCmd, sp2MstDrawPrtyBlk, NULL, \
!         NULL, (SprGourTbl*)sp2GourTbl };
! #endif
! 
! /*
!  * PROTOTYPE DECLARATIONS
!  */
! void   SPR_2Initial (Spr2WorkArea  *workArea);
! /** SSHOFF対策。SPR_2Initial2追加 '95-11/14 **/
! void   SPR_2Initial2(Spr2WorkArea  *workArea);
! void   SPR_2SetTvMode(Uint16 mode, Uint16 screenSize, Uint16 doubleInterlace);
! void   SPR_2FrameChgIntr (Uint16);
! void   SPR_2FrameEraseData (Uint16);
! void   SPR_2SetGourTbl (Uint16, SprGourTbl *);
! void   SPR_2SetLookupTbl (Uint16, SprLookupTbl *);
! #if	0
! /*
! **■1995-09-11	高橋智延
! **	＜仕様変更＞
! **	領域の確保に失敗したら、あるいは、確保されている領域のサイズよりもセッ
! **	トしようとするデータのサイズが大きい場合には、エラーコードを返すように
! **	する。
! */
! void   SPR_2SetChar (Uint16, Uint16, Uint16, Uint16, Uint16, Uint8 *);
! #else
! int		SPR_2SetChar(Uint16, Uint16, Uint16, Uint16, Uint16, Uint8 *);
! #endif
! void   SPR_2ClrChar (Uint16);
! void   SPR_2ClrAllChar (void);
! Uint16 SPR_2GourTblNoToVram (Uint16);
! Uint16 SPR_2LookupTblNoToVram (Uint16);
! Uint16 SPR_2CharNoToVram (Uint16);
! void   SPR_2GetAreaSizeInfo(SprAreaSize  *areaSizeInfo);
! void   SPR_2OpenCommand (Uint16);
! void   SPR_2CloseCommand (void);
! void   SPR_2FlushDrawPrty (void);
! void   SPR_2LocalCoord (Sint32, XyInt *);
! void   SPR_2SysClip (Sint32, XyInt *);
! void   SPR_2UserClip (Sint32, XyInt *);
! void   SPR_2Line (Sint32, Uint16, Uint16, XyInt *, Uint16);
! void   SPR_2PolyLine (Sint32, Uint16, Uint16, XyInt *, Uint16);
! void   SPR_2Polygon (Sint32, Uint16, Uint16, XyInt *, Uint16);
! void   SPR_2NormSpr (Sint32, Uint16, Uint16, Uint16, Uint16, XyInt *, Uint16);
! void   SPR_2ScaleSpr (Sint32, Uint16, Uint16, Uint16, 
!                                       Uint16, XyInt *xy, Uint16);
! void   SPR_2DistSpr (Sint32, Uint16, Uint16, Uint16,
!                                      Uint16, XyInt *xy, Uint16);
! void   SPR_2Cmd (Sint32, SprSpCmd *);
! 
! #endif /* _SPR2_ */
! 
! #ifdef _SPR3_
! /**************** SEGA_SP3.H *************************************************/
! /*
!  * TYPEDEFS
!  */
! typedef	struct SprCluster   SprCluster;
! typedef	struct SprObject3D  SprObject3D;
! typedef	struct SprSurface   SprSurface;
! typedef	struct SprInbetInf  SprInbetInf;
! typedef	struct SprTexture   SprTexture;
! typedef struct Spr3dStatus  Spr3dStatus;
! /* internal data type */
! typedef	struct Spr3WorkArea Spr3WorkArea;
! 
! 
! /*
!  * STRUCTURE DECLARATIONS
!  */
! struct SprCluster {
!     Uint16	no;             /* クラスタ番号                              */
!     Uint16	angleSeq;       /* 回転順序                                  */
!     MthXyz	angle;	        /* 親クラスタの座標系における回転            */
!     MthXyz	point;	        /* 親クラスタの座標系における原点の座標      */
!     SprObject3D	*object;        /* ３Ｄオブジェクト                          */
!     SprCluster	*next;       	/* 次クラスタ                                */
!     SprCluster	*child;      	/* 子クラスタ                                */
!     SprInbetInf *inbetInf;     	/* ３Ｄオブジェクト間接続ポリゴン情報        */
!     void        (*transStart)(SprCluster*);
!                                 /* 座標変換開始前ユーザコールバックルーチン  */
!     void        (*transEnd)(SprCluster*, SprObject3D*, MthMatrix*, MthXyz*);
!                                 /* 座標変換終了後ユーザコールバックルーチン  */
!     void        *context;       /* ユーザコンテキストエリア                  */
! };
! 
! struct SprObject3D {
!     Uint16	no;             /* オブジェクト番号                          */
!     Uint16      dispFlag;       /* 表示フラグ                                */
!     Uint16      vertCount;      /* 頂点数                                    */
!     Uint16      surfaceCount;   /* 面数                                      */
!     MthXyz      *vertPoint;     /* 頂点座標テーブル                          */
!     MthXyz      *vertNormal;    /* 頂点の法線ベクトルテーブル                */
!     SprSurface  *surface;       /* 面定義テーブル                            */
!     MthXyz      *surfaceNormal; /* 面の法線ベクトルテーブル                  */
!     void        *filler;        /* 未使用                                    */
!     Uint16      **shdIdxTbl;    /* シェーディングインデックステーブル        */
!     Fixed32     surfNormK;      /* 面法線ベクトルの計算補正値                */
!     SprObject3D *next;          /* 次３Ｄオブジェクト                        */
! };
! 
! struct SprSurface {
!     Uint16     vertNo[4];       /* 面を構成する頂点番号                      */
!     Uint16     drawMode;        /* 描画モード                                */
!     Uint16     color;           /* カラーデータ                              */
! };
! 
! struct SprInbetInf {
!     Sint32       vertCount;     /* 取り出し頂点数                            */
!     SprObject3D  *fromObj;      /* 接続頂点データ取り出しオブジェクト        */
!     Uint16       *fromVertNo;   /* 取り出し頂点番号配列                      */
!     SprObject3D  *toObj;        /* 接続頂点データ設定オブジェクト            */
!     Uint16       *toVertNo;     /* 設定頂点番号配列                          */
!     SprInbetInf  *next;         /* 次３Ｄオブジェクト間接続ポリゴン情報      */
! };
! 
! struct SprTexture {
!     Uint16       charNo;        /* キャラクタ番号                            */
!     Uint16       colorMode;     /* カラーモード                              */
!     Uint16       color;         /* カラーデータ（ｶﾗｰﾊﾞﾝｸorﾙｯｸｱｯﾌﾟﾃｰﾌﾞﾙNo）   */
!     Uint16       width;         /* キャラクタの幅                            */
!     Uint16       height;        /* キャラクタの高さ                          */
!     Uint8        *charData;     /* キャラクタデータのポインタ                */
!     SprLookupTbl *lookupTbl;    /* ルックアップテーブルのポインタ            */
! };
! 
! struct Spr3WorkArea {
!     Uint16      objSurfMax;        /* オブジェクト内最大面数                 */
!     Uint16      objVertMax;        /* オブジェクト内最大頂点数               */
!     Sint32      *surfBright;       /* 面輝度テーブル                         */
!     Sint32      *vertBright;       /* 頂点輝度テーブル                       */
!     MthXyz      *coordView3D;      /* ３Ｄ視点座標変換後テーブル             */
!     XyInt       *coord2D;          /* ２Ｄ透視変換後テーブル                 */
!     MthXyz      *coordWorld3D;     /* ３Ｄワールド座標変換後テーブル         */
! };
! 
! struct Spr3dStatus {
!     MthXyz    lightAngle;       /* 光源アングル                           */
!     MthXyz    viewCoordPoint;   /* 視点座標系内の視点位置                 */
!     MthXyz    viewPoint;        /* 視点座標                               */
!     MthXyz    viewAngle;        /* 視点アングル                           */
!     Sint32    viewAngleSeq;     /* 視点アングル回転操作                   */
!     Sint32    zSortMode;        /* ＺソートＺ座標値の採用モード           */
!     Fixed32   zSortZMin;        /* フラッシュ単位現Ｚ座標最小値           */
!     Fixed32   zSortZMax;        /* フラッシュ単位現Ｚ座標最大値           */
!     Fixed32   clipZMin;         /* 視点座標系クリップＺ最小値座標         */
!     Fixed32   clipZMax;         /* 視点座標系クリップＺ最大値座標         */
!     Sint32    clipLevel;        /* クリッピングレベル                     */
!     Sint32    unitPixelX;       /* X 1.0 に対するスクリーンのピクセル数   */
!     Sint32    unitPixelY;       /* Y 1.0 に対するスクリーンのピクセル数   */
! };
! 
! typedef struct TComTbl  TComTbl;
! struct TComTbl {
!     Fixed32     zSortBZMin;     /* i   フラッシュ単位前Ｚ座標最小値          */
!     int         zSftCnt;        /* i   ＺソートＺシフト数                    */
!     int         zSortBlkCnt;    /* i   Ｚソートブロック数                    */
!     Sint32      spriteDrawFlag; /* i   変形スプライト描画フラグ              */
!     Sint32      otherDrawFlag;  /* i   その他ポリゴン描画フラグ              */
!     Sint32      *unitPixel;     /* i   X,Y 1.0に対するスクリーンのピクセル数 */
!     Fixed32     *clipRatio;     /* i   ３Ｄクリッピング率 [0]=X, [1]=Y       */
!     Fixed32     *clipZ;         /* i   視点座標系クリップＺ [0]=min, [1]=max */
!     SprCharTbl  *charTbl;       /* i   スプライトキャラクタテーブル          */
!     Sint32      *vertBright;    /* i   頂点輝度テーブル                      */
!     MthXyz      *coordView3D;   /* i   ３Ｄ視点座標変換後テーブル            */
!     XyInt       *coord2D;       /* i   ２Ｄ透視変換後テーブル                */
!     int         dispFlag;       /* i   表示フラグ                            */
!     Uint16      **shdIdxTbl;    /* i   シェーディングインデックステーブル    */
!     Uint32      gourGrayTopR;   /* i   グーログレイ先頭ＶＲＡＭアドレス      */
!     Uint32      lookupTblR;     /* i   ルックアップテーブルＶＲＡＭ内位置    */
!     MthXyz      *lightVector;   /* i   光源ベクタ                            */
!     MthMatrix   *viewMatrix;    /* i   視点座標系への座標変換マトリックス    */
!     MthMatrix   *worldMatrix;   /* i   ワールド座標系への座標変換マトリックス*/
! };
! 
! typedef struct T3Dto2D  T3Dto2D;
! struct T3Dto2D {
!     int         vertCount;      /* i   頂点数                                */
!     int         surfaceCount;   /* i   面数                                  */
!     SprSurface  *surfInfo;      /* i   面定義テーブル                        */
!     MthXyz      *vertPoint;     /* i   頂点座標テーブル                      */
!     MthXyz      *surfaceNormal; /* i   面の法線ベクトルテーブル              */
!     MthXyz      *vertNormal;    /* i   頂点の法線ベクトルテーブル            */
!     MthXyz      *coordView3D;   /* o   ３Ｄ視点座標変換後テーブル            */
!     XyInt       *coord2D;       /* o   ２Ｄ透視変換後テーブル                */
!     Sint32      *surfBright;    /* o   面輝度テーブル                        */
!     Sint32      *vertBright;    /* o   頂点輝度テーブル                      */
!     MthXyz      *coordWorld3D;  /* o   頂点のワールド座標テーブル            */
! };
! 
! typedef struct T2DtoCmd  T2DtoCmd;
! struct T2DtoCmd {
!     int         surfaceCount;   /* i   面数                                  */
!     SprSurface  *surface;       /* i   面定義テーブル                        */
!     Sint32      *surfBright;    /* i   面輝度テーブル                        */
!     Fixed32     zSortZMin;      /* i/o フラッシュ単位現Ｚ座標最小値          */
!     Fixed32     zSortZMax;      /* i/o フラッシュ単位現Ｚ座標最大値          */
!     SprDrawPrtyBlk *prtyTbl;    /* i/o 描画プライオリティブロックテーブル    */
!     SprSpCmd    *cmdBuf;        /* o   スプライトコマンドバッファ            */
!     int         outCmdPos;      /* o   書き込みコマンド数                    */
!     SprGourTbl  *gourTblCur;    /* i/o グーロテーブルカレントアドレス        */
!     Uint32      gourTblCurR;    /* i/o グーロカレントＶＲＡＭアドレス        */
! };
! 
! typedef struct GetSurfNormPara  GetSurfNormPara;
! struct GetSurfNormPara {
!     int         surfaceCount;   /* i   面数                                  */
!     SprSurface  *surface;       /* i   面定義テーブル                        */
!     MthXyz      *vertPoint;     /* i   頂点座標テーブル                      */
!     Fixed32     surfNormK;      /* i   面法線ベクトルの計算補正値            */
!     MthXyz      *surfaceNormal; /* o   面の法線ベクトルテーブル              */
! };
! 
! 
! 
! /*
!  * GLOBAL DEFINES/MACROS DEFINES
!  */
! #define   ROT_SEQ_ZYX       0x0000
! #define   ROT_SEQ_ZXY       0x0001
! #define   ROT_SEQ_YZX       0x0002
! #define   ROT_SEQ_YXZ       0x0003
! #define   ROT_SEQ_XYZ       0x0004
! #define   ROT_SEQ_XZY       0x0005
! 
! #define   DISP_POLYGON      0x0000
! #define   DISP_POLYLINE     0x8000
! #define   DISP_MASK         0xc000
! #define   BOTH_FACE         0x1000
! 
! #define   NO_SHADING        0x0000
! #define   FLAT_SHADING      0x0100
! #define   GOURAUD_SHADING   0x0200
! #define   SHADING_MASK      0x0300
! #define   INBETWEEN_OBJECT  0x0010
! 
! #define   MATE_COLOR        0x0000
! #define   MATE_TEXTURE      0x4000
! #define   MATE_SHADING_TBL  0x8000
! #define   MATE_AUTO_SHADING 0xc000
! #define   MATE_MASK         0xc000
! 
! #define   ZSORT_MIN         0x0000
! #define   ZSORT_MAX         0x1000
! #define   ZSORT_MID         0x2000
! #define   ZSORT_MASK        0x3000
! #define   ZSORT_FLOAT_MODE  0
! #define   ZSORT_FIXED_MODE  1
! 
! #define   DRAW_MODE_MASK    0x07ff
! 
! 
! #define   SPR_3mac1(sp3ObjSurfMax) \
! static Sint32    sp3SurfBright [sp3ObjSurfMax];
! 
! #ifdef SPR_3NEED_WORLD_VERT
! #define   SPR_3mac2(sp3ObjVertMax) \
! static MthXyz    sp3CoordView3D   [sp3ObjVertMax];   \
! static XyInt     sp3Coord2D       [sp3ObjVertMax];   \
! static Sint32    sp3VertBright    [sp3ObjVertMax];   \
! static MthXyz    sp3CoordWorld3D  [sp3ObjVertMax];
! #else
! #define   SPR_3mac2(sp3ObjVertMax) \
! static MthXyz    sp3CoordView3D   [sp3ObjVertMax];   \
! static XyInt     sp3Coord2D       [sp3ObjVertMax];   \
! static Sint32    sp3VertBright    [sp3ObjVertMax];
! #endif
! 
! 
! 
! #ifdef SPR_3NEED_WORLD_VERT
! #define   SPR_3mac3(sp3WorkArea, sp3ObjSurfMax, sp3ObjVertMax) \
! static Spr3WorkArea  sp3WorkArea = {                          \
!    sp3ObjSurfMax, sp3ObjVertMax, sp3SurfBright, \
!    sp3VertBright, sp3CoordView3D, sp3Coord2D, sp3CoordWorld3D };
! #else
! #define   SPR_3mac3(sp3WorkArea, sp3ObjSurfMax, sp3ObjVertMax) \
! static Spr3WorkArea  sp3WorkArea = {                          \
!    sp3ObjSurfMax, sp3ObjVertMax, sp3SurfBright, \
!    sp3VertBright, sp3CoordView3D, sp3Coord2D, NULL };
! #endif
! 
! #define   SPR_3DefineWork(sp3WorkArea, sp3ObjSurfMax, sp3ObjVertMax) \
!  SPR_3mac1(sp3ObjSurfMax) \
!  SPR_3mac2(sp3ObjVertMax) \
!  SPR_3mac3(sp3WorkArea, sp3ObjSurfMax, sp3ObjVertMax)
! 
! 
! #ifdef USE_DEBUG_INFO
! extern int  dbgComputePol;
! extern int  dbgDrawPol;
! #endif
! 
! /*
!  * PROTOTYPE DECLARATIONS
!  */
! void   SPR_3Initial       (Spr3WorkArea  *workArea);
! void   SPR_3SetLight      (Uint16 moveKind, MthXyz *lightAngle);
! void   SPR_3SetView       (Uint16 moveKind, MthXyz *viewPoint,
!                            MthXyz *viewAngle, Uint16 angleSeq,
!                            MthXyz *viewCoordPoint);
! void   SPR_3MoveCluster   (SprCluster *cluster, Uint16 moveKind,
! 					   MthXyz *angle, MthXyz *point);
! void   SPR_3DrawModel     (SprCluster *rootCluster);
! void   SPR_3Flush         (void);
! void   SPR_3SetTexture    (SprTexture *texture);
! void   SPR_3ChangeTexColor(Uint16 charNo, Uint16 color,
!                                           SprLookupTbl *lookupTbl);
! void   SPR_3ClrTexture    (SprTexture *texture);
! void   SPR_3SetZSortMinMax(Uint16 pZSortMode,
!                                        Fixed32 pZSortZMin, Fixed32 pZSortZMax);
! void   SPR_3SetClipLevel  (Uint16 pClipLevel,
! 				       Fixed32 pClipZMin, Fixed32 pClipZMax);
! void   SPR_3SetPixelCount (Uint16 pixelCountX, Uint16 pixelCountY);
! void   SPR_3GetStatus (Spr3dStatus *spr3dStatus);
! void   SPR_3CallAllCluster(SprCluster *cluster, void (*userFunc)(SprCluster*));
! void   SPR_3SetSurfNormVect(SprObject3D  *obj);
! void   SPR_3SetDrawSpeed(Sint32 hssFlag, Sint32 eosFlag, Sint32 pclpFlag);
! void   SPR_3AllCoordTransClipPers(MthMatrix *matrix,
!                        MthXyz *src, MthXyz *ans, XyInt *ans2D, int vertCnt,
!                        Sint32 *unitPixel, Fixed32 *clipRatio, Fixed32 *clipZ);
! void   SPR_3AllCoordTrans(MthMatrix *matrix, MthXyz *src, int vertCnt,
!                           MthXyz *ans);
! void   SPR_3AllSurfaceBright(MthMatrix *matrix, SprSurface *surfInfo,
!                           MthXyz *surfaceNormal, Sint32 *surfaceBright,
!                      MthXyz *lightVector, Sint32 surfCnt, MthXyz *coordView3D);
! void   SPR_3AllVertBright(MthMatrix *matrix, MthXyz *vertNormal,
!                       Sint32 *vertBright, MthXyz *lightVector, Sint32 vertCnt);
! 
! 
! /*
!  * ＤＳＰによるマトリックス合成
!  */
! #define MTX_OP_CLEAR	1            /*　出力マトリックスエリアのクリア      */
! #define MTX_OP_REV_Z	2            /*　Ｚの符号反転合成                    */
! #define MTX_OP_MOV_XYZ	3            /*　平行移動合成                        */
! #define MTX_OP_ROT_X	4            /*　Ｘ回転移動合成                      */
! #define MTX_OP_ROT_Y	5            /*　Ｙ回転移動合成                      */
! #define MTX_OP_ROT_Z	6            /*　Ｚ回転移動合成                      */
! #define MTX_OP_END	7            /*　処理終了                            */
! 
! typedef struct  SprDspMatrixOp {     /* マトリックス合成オペレーション       */
!          Fixed32     x;              /* Ｘ値                                 */
!          Fixed32     y;              /* Ｙ値                                 */
!          Fixed32     z;              /* Ｚ値                                 */
!          Sint32      opCode;         /* オペレーションコード                 */
! } SprDspMatrixOp;
! 
! typedef struct  SprDspMatrixParm {   /* ＤＳＰ用マトリックス合成パラメータ   */
!          MthMatrix   *inputMatrix;   /* 入力マトリックスのアドレス           */
!          MthMatrix   *outputMatrix;  /* 出力マトリックスのアドレス           */
!          SprDspMatrixOp  op[15];     /* マトリックス合成オペレーション       */
! } SprDspMatrixParm;
! 
! void    SPR_3MatrixCompoInit(void);
! void    SPR_3MatrixCompoExec(SprDspMatrixParm *dspMatrixParm);
! void    SPR_3MatrixCompoCheck(void);
! 
! 
! #endif /* _SPR3_ */
! 
! 
! #endif /* ifndef SEGA_SPR_H */
! #define SLAVE
! /*  end of file */
! 
\ No newline at end of file
--- 1,642 ----
! /*----------------------------------------------------------------------------
!  *  sega_spr.h -- SPR ライブラリ インクルードファイル
!  *  Copyright(c) 1994 SEGA
!  *  Written by H.E on 1994-07-25 Ver.1.00
!  *  Updated by H.E on 1994-07-25 Ver.1.00
!  *
!  *  スプライト表示用インクルードファイルで使用スプライト表示ライブラリの種別に
!  *  より以下のように定義します。
!  *
!  *  （１）スプライト表示基本処理のみの場合
!  *
!  *        #include "sega_spr.h"
!  *
!  *  （２）スプライト表示拡張処理の場合
!  *
!  *        #define  _SPR2_
!  *        #include "sega_spr.h"
!  *
!  *  （３）スプライト３Ｄ表示処理の場合
!  *
!  *        #define  _SPR3_
!  *        #include "sega_spr.h"
!  *
!  *
!  *----------------------------------------------------------------------------
!  */
! 
! #ifndef SEGA_SPR_H
! #define SEGA_SPR_H
! 
! #include        "sega_xpt.h"
! #include        "sega_def.h"
! #include        "sega_mth.h"
! 
! /*-----------------------------------
!  * Select 3D Execute Machine
!  *---------------------------------*/
! #define  _PC_         0
! #define  _INDIGO2_    1
! #define  _SH_         2
! 
! 
! /*
!  * Set Machine Environment
!  */
! #define NO_EXIST    0
! #define    EXIST    1
! 
! #if defined(_PC)
!    #define _MACHINE  _PC_
!    #define _DSP      NO_EXIST
!    #define _MATH        EXIST
! #endif
! 
! #if defined(_INDIGO2)
!    #define _MACHINE  _INDIGO2_
!    #define _DSP      NO_EXIST
!    #define _MATH        EXIST
! #endif
! 
! #if defined(_SH)
!    #define _MACHINE  _SH_
!    #define _DSP         EXIST
!    #define _MATH     NO_EXIST
! #endif
! 
! #ifdef _SPR3_
!    #define _SPR2_
! #endif
! 
! 
! /**************** SEGA_SP1.H *************************************************/
! /*
!  * GLOBAL DEFINES/MACROS DEFINES
!  */
! 
! #define  VRAM_SIZE           512*1024   /* 512 Kbyte                        */
! #define  FBUF_SIZE           256*1024   /* 256 Kbyte * 2 bank               */
! 
! #define  AUTO_FRAME_CHG           0     /* auto frame change mode           */
! #define  MANUAL_FRAME_CHG         1     /* manual frame change mode         */
! #define  NO_INTER_FRAME_CHG       2     /* no interval frame change mode    */
! #define  NO_INTER_VBE_FRAME_CHG   3     /* v-blank erase no interval frm chg*/
! 
! #define  SPR_FBCR_MANUAL     0x0003     /* frame buffer manual change       */
! #define  SPR_FBCR_AUTO       0x0000     /* frame buffer auto change         */
! #define  SPR_FBCR_ERASE      0x0002     /* frame buffer next erase on       */
! #define  SPR_FBCR_DIE        0x0008     /* double interlace on              */
! #define  SPR_FBCR_DIL        0x0004     /* double interlace plot line       */
! #define  SPR_FBCR_EOS        0x0010     /* even/odd data sampling select bit*/
! 
! #define  SPR_TV_NORMAL       0          /* Normal TV mode                   */
! #define  SPR_TV_HIRESO       1          /* High Resolution TV mode          */
! #define  SPR_TV_ROT16        2          /* Rotate 16 bit TV mode            */
! #define  SPR_TV_ROT8         3          /* Rotate 8 bit TV mode             */
! #define  SPR_TV_HDTV         4          /* HDTV TV mode                     */
! 
! #define  SPR_TV_320X224      0          /* Screen size 320 x 224            */
! #define  SPR_TV_320X240      1          /* Screen size 320 x 240            */
! #define  SPR_TV_352X224      2          /* Screen size 352 x 224            */
! #define  SPR_TV_352X240      3          /* Screen size 352 x 240            */
! #define  SPR_TV_640X224      4          /* Screen size 640 x 224            */
! #define  SPR_TV_640X240      5          /* Screen size 640 x 240            */
! #define  SPR_TV_704X224      6          /* Screen size 704 x 224            */
! #define  SPR_TV_704X240      7          /* Screen size 704 x 240            */
! 
! #define  SPR_W_TVMR          0x00000000 /* TV mode selection                */
! #define  SPR_W_FBCR          0x00000002 /* Frame buf change mode            */
! #define  SPR_W_PTMR          0x00000004 /* Draw start control               */
! #define  SPR_W_EWDR          0x00000006 /* Erase write data                 */
! #define  SPR_W_EWLR          0x00000008 /* Erase write area left top point  */
! #define  SPR_W_EWRR          0x0000000A /* Erase write area right bot point */
! #define  SPR_W_ENDR          0x0000000C /* Stop VDP1                        */
! #define  SPR_R_EDSR          0x00000010 /* Transfer complete status         */
! #define  SPR_R_LOPR          0x00000012 /* End command table address        */
! #define  SPR_R_COPR          0x00000014 /* Executing command table address  */
! #define  SPR_R_MODR          0x00000016 /* Write register Mode status       */
! 
! #define  SPR_R_EXTEN         0x00000002 /* VDP2 External Signal Enable Reg  */
! #define  SPR_R_TVSTAT        0x00000004 /* VDP2 TV Status Reg               */
! #define  SPR_R_VCNT          0x0000000A /* VDP2 V Counter Reg               */
! 
! #define  VRAM_ADDR           0x25C00000 /* Sprite IC VRAM area address      */
! #define  FBUF_ADDR           0x25C80000 /* Sprite frame buffer address      */
! #define  VDP1_REG_BASE       0x25D00000 /* Sprite IC Register base address  */
! #define  VDP2_REG_BASE       0x25F80000 /* Sprite IC Register base address  */
! 
! struct SprSpStatus {
!     Uint16  frameChgMode;             /* Frame Change Mode                 */
!     Uint16  frameEraseMode;           /* Frame Erase  Mode                 */
!     Uint16  vbInterval;               /* V-Blank Interval for Frame Change */
!     Uint16  eraseData;
!     Uint16  eraseLeftX;
!     Uint16  eraseTopY;
!     Uint16  eraseRightX;
!     Uint16  eraseBotY;
! };
! 
! typedef struct SprSpStatus SprSpStatus;
! 
! #define SPR_WRITE_REG(reg, val) \
!       *(Uint16*)(VDP1_REG_BASE+(reg)) = (val)
! #define SPR_READ_REG(reg) \
!       (*(volatile Uint16*)(VDP1_REG_BASE+(reg)))
! #define SPR_SCLWRITE_REG(reg, val) \
!       *(Uint16*)(VDP2_REG_BASE+(reg)) = (val)
! #define SPR_SCLREAD_REG(reg) \
!       (*(volatile Uint16*)(VDP2_REG_BASE+(reg)))
! 
! /*
!  * EXTERNAL VARIABLE DECLARATIONS
!  */
! extern Sint32  SpScreenX;               /* TV Screen X Size                  */
! extern Sint32  SpScreenY;               /* TV Screen Y Size                  */
! extern volatile Uint16  SpFrameChgMode;          /* Frame Change Mode                 */
! extern volatile Sint32  SpFrameEraseMode;        /* Frame Erase  Mode                 */
! extern volatile Sint32  VBInterval;              /* V-Blank Interval for Frame Change */
! extern volatile Sint32  VBIntervalCounter;       /* V-Blank Interval Counter          */
! extern volatile Sint32  ReqDisplayFlag;          /* Display Request flag              */
! extern Uint16  SpTvMode;                /* TV Mode                           */
! extern Uint16  SpFbcrMode;              /* Frame Buffer Chane Mode           */
! extern Uint16  SpDie;                   /* Double Interlace Enable Flag      */
! extern Uint16  SpDil;                   /* Double Interlace Plot Line        */
! 
! /*
!  * EXTERNAL FUNCTION PROTOTYPE DECLARATIONS
!  */
! void SPR_Initial (Uint8 **VRAM);
! void SPR_SetTvMode(Uint16 mode, Uint16 screenSize, Uint16 doubleInterlace);
! void SPR_GetStatus (SprSpStatus *spStatus);
! void SPR_SetEraseData (Uint16 eraseData, Uint16 leftX,  Uint16 topY,
!                                          Uint16 rightX, Uint16 botY);
! void SPR_WaitDrawEnd (void);
! void SPR_SetEosMode(Sint32 eosFlag);
! 
! 
! #ifdef _SPR2_
! /**************** SEGA_SP2.H *************************************************/
! /*
!  * GLOBAL DEFINES/MACROS DEFINES
!  */
! #define  CTRL_END            0x8000     /* control word end bit mask        */
! #define  CTRL_SKIP           0x4000     /* control word skip bit mask       */
! #define  CTRL_JUMP           0x3000     /* control word jump bit mask       */
! #define  CTRL_ZOOM           0x0f00     /* control word zoom point bit mask */
! #define  CTRL_FUNC           0x000f     /* control word function bit mask   */
! #define  CTRL_DIR            0x0030     /* control word char read bit mask  */
! 
! #define  DRAW_COMPO          0x0003     /* draw mode word color compose mask*/
! #define  DRAW_GOURAU         0x0004     /* draw mode word gouraud shading   */
! #define  DRAW_GOURAU_GRAY    0x0804     /* draw mode word gray gour shading */
! #define  DRAW_COLOR          0x0038     /* draw mode word color mode mask   */
! #define  DRAW_MESH           0x0100     /* draw mode word mesh on           */
! 
! #define  COMPO_REP           0x0000     /* color compose reprace mode       */
! #define  COMPO_SHADOW        0x0001     /* color compose shadow mode        */
! #define  COMPO_HARF          0x0002     /* color compose harf luminance mode*/
! #define  COMPO_TRANS         0x0003     /* color compose trunslucent mode   */
! 
! #define  FUNC_NORMALSP       0x0000     /* draw normal sprite function      */
! #define  FUNC_SCALESP        0x0001     /* draw scaled sprite function      */
! #define  FUNC_DISTORSP       0x0002     /* draw distorted sprite function   */
! #define  FUNC_POLYGON        0x0004     /* draw polygon function            */
! #define  FUNC_POLYLINE       0x0005     /* draw polyline function           */
! #define  FUNC_LINE           0x0006     /* draw line function               */
! #define  FUNC_SCLIP          0x0009     /* set system clipping function     */
! #define  FUNC_UCLIP          0x0008     /* set user clipping function       */
! #define  FUNC_LCOORD         0x000a     /* set local coordinate function    */
! #define  FUNC_TEXTURE        0x0004     /* texture command group mask       */
! 
! #define  JUMP_NEXT           0x0000     /* jump next command                */
! #define  JUMP_ASSIGN         0x1000     /* jump assign command              */
! #define  JUMP_CALL           0x2000     /* call assign command              */
! #define  JUMP_RETURN         0x3000     /* return command subroutine        */
! 
! #define  ZOOM_NOPOINT        0x0000     /* zoom no point                    */
! #define  ZOOM_TL             0x0500     /* zoom point top left              */
! #define  ZOOM_TM             0x0600     /* zoom point top middle            */
! #define  ZOOM_TR             0x0700     /* zoom point top right             */
! #define  ZOOM_ML             0x0900     /* zoom point middle left           */
! #define  ZOOM_MM             0x0a00     /* zoom point center                */
! #define  ZOOM_MR             0x0b00     /* zoom point middle right          */
! #define  ZOOM_BL             0x0c00     /* zoom point bottom left           */
! #define  ZOOM_BM             0x0e00     /* zoom point bottom middle         */
! #define  ZOOM_BR             0x0f00     /* zoom point bottom right          */
! 
! #define  DIR_NOREV           0x0000     /* char read not reverse            */
! #define  DIR_TBREV           0x0020     /* char read top/bottom reverse     */
! #define  DIR_LRREV           0x0010     /* char read left/right reverse     */
! #define  DIR_LRTBREV         0x0030     /* char read left/right/top/bot rev */
! 
! #define  ECD_DISABLE         0x0080     /* ECD disabe & SPD enable          */
! #define  SPD_DISABLE         0x0040     /* ECD enable & SPD disable         */
! #define  ECDSPD_DISABLE      0x00c0     /* ECD & SPD disable                */
! #define  UCLPIN_ENABLE       0x0400     /* CLIP IN enable                   */
! #define  UCLPOUT_ENABLE      0x0600     /* CLIP OUT enable                  */
! #define  HSS_ENABLE          0x1000     /* HSS enable                       */
! #define  PCLP_ENABLE         0x0800     /* PCLP disable                     */
! 
! #define  COLOR_0             0x0000     /* 4 bit/pixel & 16 color bank mode */
! #define  COLOR_1             0x0008     /* 4 bit/pixel & 16 color lookup tbl*/
! #define  COLOR_2             0x0010     /* 8 bit/pixel &  64 color bank mode*/
! #define  COLOR_3             0x0018     /* 8 bit/pixel & 128 color bank mode*/
! #define  COLOR_4             0x0020     /* 8 bit/pixel & 256 color bank mode*/
! #define  COLOR_5             0x0028     /* 16 bit/pixel & RGB mode          */
! 
! #define  NO_GOUR             0xffff     /* no use Gouraud Shading Table No. */
! 
! #define  SPR_2DRAW_PRTY_ON   1          /* command draw priority on         */
! #define  SPR_2DRAW_PRTY_OFF  0          /* command draw priority off        */
! #define  SPR_2MOST_FAR       0          /* draw sprite most far position    */
! #define  SPR_2MOST_NEAR      0x7fffffff /* draw sprite most near position   */
! 
! 
! /*
!  * STRUCTURE DECLARATIONS
!  */
! struct SprSpCmd {                       /* Sprite Command Table             */
!     Uint16  control;                    /* control word                     */
!     Uint16  link;                       /* command link                     */
!     Uint16  drawMode;                   /* draw mode                        */
!     Uint16  color;                      /* color info.                      */
!     Uint16  charAddr;                   /* character address                */
!     Uint16  charSize;                   /* character size                   */
!     Sint16  ax;                         /* point A x                        */
!     Sint16  ay;                         /* point A y                        */
!     Sint16  bx;                         /* point B x                        */
!     Sint16  by;                         /* point B y                        */
!     Sint16  cx;                         /* point C x                        */
!     Sint16  cy;                         /* point C y                        */
!     Sint16  dx;                         /* point D x                        */
!     Sint16  dy;                         /* point D y                        */
!     Uint16  grshAddr;                   /* gouraud shading table address    */
!     Uint16  dummy;                      /* dummy area                       */
! };
! 
! struct SprGourTbl {
!     Uint16  entry[4];
! };
! 
! struct SprLookupTbl {
!     Uint16  entry[16];
! };
! 
! /*
!  * TYPEDEFS
!  */
! typedef Uint16 Vaddr;                       /* Relative Address in The VRAM  */
! typedef struct SprSpCmd     SprSpCmd;
! typedef struct SprGourTbl   SprGourTbl;
! typedef struct SprLookupTbl SprLookupTbl;
! /* internal data type */
! typedef	struct SprCharTbl     SprCharTbl;
! typedef	struct SprCmdChain    SprCmdChain;
! typedef struct SprDrawPrtyBlk SprDrawPrtyBlk;
! typedef	struct Spr2WorkArea   Spr2WorkArea;
! typedef	struct SprAreaSize    SprAreaSize;
! 
! struct SprCharTbl {                         /* Character Entry Table         */
!     Vaddr     addr;                         /* Character Relative Address    */
!     Uint16    xySize;                       /* Charcter Size (X * Y)         */
!     Uint16    mode;                         /* Charcter Mode (0-5)           */
!     Uint16    color;                        /* Color Bank or LookUp Tbl No   */
!     Uint16    size;                         /* Charcter Size (by the 32 byte)*/
! };
! 
! struct SprCmdChain {            /* コマンドチェイン管理テーブル              */
!     Uint16      nextNo;         /* 次のコマンドチェインエントリ番号          */
!     Uint16      cmdNo;          /* 対応するコマンド番号                      */
! };
! 
! struct SprDrawPrtyBlk {         /* 描画プライオリティブロックテーブル        */
!     Uint16      topNo;          /* 先頭コマンドチェインエントリ番号          */
!     Uint16      botNo;          /* 末尾コマンドチェインエントリ番号          */
! };
! 
! struct Spr2WorkArea {                    /* SP2 Work Area Define             */
!     Uint16         commandMax;           /* Command Max                      */
!     Uint16         gourTblMax;           /* Gour Tbl Max                     */
!     Uint16         lookupTblMax;         /* Lookup Tbl Max                   */
!     Uint16         charMax;              /* Char Max                         */
!     Uint16         drawPrtyBlkMax;       /* Draw Priority Block Max          */
!     SprCharTbl     *charTbl;             /* Character Tbl Pointer            */
!     SprCmdChain    *cmdChain;            /* Command Draw Priority Chain Tbl  */
!     SprDrawPrtyBlk *drawPrtyBlk;         /* Draw Priority Block Start        */
! };
! 
! struct SprAreaSize {                     /* SP2 Work Area Size               */
!     Uint16         commandMax;           /* Command Max                      */
!     Uint16         gourTblMax;           /* Gour Tbl Max                     */
!     Uint16         lookupTblMax;         /* Lookup Tbl Max                   */
!     Uint16         charMax;              /* Char Max                         */
!     Uint16         drawPrtyBlkMax;       /* Draw Priority Block Max          */
!     Uint16         useCommandCount;      /* Using Command Block Count        */
!     Uint16         charRemainBlkCount;   /* Char Total Remain Null Blk Count */
!     Uint16         charNullBlkMaxSize;   /* Char Null Block Max Size         */
! };
! 
! /*
!  * EXTERNAL VARIABLE DECLARATIONS
!  */
! extern Sint32  SpLCoordX;                   /* Local Origin X Position       */
! extern Sint32  SpLCoordY;                   /* Local Origin Y Position       */
! 
! 
! #define   SPR_2DefineWork(sp2WorkArea, sp2CommandMax, sp2GourTblMax, \
! 		          sp2LookupTblMax, sp2CharMax, sp2DrawPrtyBlkMax) \
! static SprCharTbl      sp2CharTbl      [sp2CharMax]; \
! static SprCmdChain     sp2CmdChain     [sp2CommandMax]; \
! static SprDrawPrtyBlk  sp2DrawPrtyBlk  [sp2DrawPrtyBlkMax]; \
! static Spr2WorkArea sp2WorkArea  = {  \
!         sp2CommandMax, sp2GourTblMax, sp2LookupTblMax, sp2CharMax, \
!         sp2DrawPrtyBlkMax, sp2CharTbl, sp2CmdChain, sp2DrawPrtyBlk };
! 
! 
! /*
!  * PROTOTYPE DECLARATIONS
!  */
! void   SPR_2Initial (Spr2WorkArea  *workArea);
! void   SPR_2SetTvMode(Uint16 mode, Uint16 screenSize, Uint16 doubleInterlace);
! void   SPR_2FrameChgIntr (Uint16);
! void   SPR_2FrameEraseData (Uint16);
! void   SPR_2SetGourTbl (Uint16, SprGourTbl *);
! void   SPR_2SetLookupTbl (Uint16, SprLookupTbl *);
! void   SPR_2SetChar (Uint16, Uint16, Uint16, Uint16, Uint16, Uint8 *);
! void   SPR_2ClrChar (Uint16);
! void   SPR_2ClrAllChar (void);
! Uint16 SPR_2GourTblNoToVram (Uint16);
! Uint16 SPR_2LookupTblNoToVram (Uint16);
! Uint16 SPR_2CharNoToVram (Uint16);
! void   SPR_2GetAreaSizeInfo(SprAreaSize  *areaSizeInfo);
! void   SPR_2OpenCommand (Uint16);
! void   SPR_2CloseCommand (void);
! void   SPR_2FlushDrawPrty (void);
! void   SPR_2LocalCoord (Sint32, XyInt *);
! void   SPR_2SysClip (Sint32, XyInt *);
! void   SPR_2UserClip (Sint32, XyInt *);
! void   SPR_2Line (Sint32, Uint16, Uint16, XyInt *, Uint16);
! void   SPR_2PolyLine (Sint32, Uint16, Uint16, XyInt *, Uint16);
! void   SPR_2Polygon (Sint32, Uint16, Uint16, XyInt *, Uint16);
! void   SPR_2NormSpr (Sint32, Uint16, Uint16, Uint16, Uint16, XyInt *, Uint16);
! void   SPR_2ScaleSpr (Sint32, Uint16, Uint16, Uint16, 
!                                       Uint16, XyInt *xy, Uint16);
! void   SPR_2DistSpr (Sint32, Uint16, Uint16, Uint16,
!                                      Uint16, XyInt *xy, Uint16);
! void   SPR_2Cmd (Sint32, SprSpCmd *);
! 
! #endif /* _SPR2_ */
! 
! #ifdef _SPR3_
! /**************** SEGA_SP3.H *************************************************/
! /*
!  * TYPEDEFS
!  */
! typedef	struct SprCluster   SprCluster;
! typedef	struct SprObject3D  SprObject3D;
! typedef	struct SprSurface   SprSurface;
! typedef	struct SprInbetInf  SprInbetInf;
! typedef	struct SprTexture   SprTexture;
! typedef struct Spr3dStatus  Spr3dStatus;
! /* internal data type */
! typedef	struct Spr3WorkArea Spr3WorkArea;
! 
! 
! /*
!  * STRUCTURE DECLARATIONS
!  */
! struct SprCluster {
!     Uint16	no;             /* クラスタ番号                              */
!     Uint16	angleSeq;       /* 回転順序                                  */
!     MthXyz	angle;	        /* 親クラスタの座標系における回転            */
!     MthXyz	point;	        /* 親クラスタの座標系における原点の座標      */
!     SprObject3D	*object;        /* ３Ｄオブジェクト                          */
!     SprCluster	*next;       	/* 次クラスタ                                */
!     SprCluster	*child;      	/* 子クラスタ                                */
!     SprInbetInf *inbetInf;     	/* ３Ｄオブジェクト間接続ポリゴン情報        */
!     void        (*transStart)(SprCluster*);
!                                 /* 座標変換開始前ユーザコールバックルーチン  */
!     void        (*transEnd)(SprCluster*, SprObject3D*, MthMatrix*, MthXyz*);
!                                 /* 座標変換終了後ユーザコールバックルーチン  */
!     void        *context;       /* ユーザコンテキストエリア                  */
! };
! 
! struct SprObject3D {
!     Uint16	no;             /* オブジェクト番号                          */
!     Uint16      dispFlag;       /* 表示フラグ                                */
!     Uint16      vertCount;      /* 頂点数                                    */
!     Uint16      surfaceCount;   /* 面数                                      */
!     MthXyz      *vertPoint;     /* 頂点座標テーブル                          */
!     MthXyz      *vertNormal;    /* 頂点の法線ベクトルテーブル                */
!     SprSurface  *surface;       /* 面定義テーブル                            */
!     MthXyz      *surfaceNormal; /* 面の法線ベクトルテーブル                  */
!     MthXyz      *surfaceVert;   /* 面の代表頂点座標テーブル                  */
!     Uint16      **shdIdxTbl;    /* シェーディングインデックステーブル        */
!     Fixed32     surfNormK;      /* 面法線ベクトルの計算補正値                */
!     SprObject3D *next;          /* 次３Ｄオブジェクト                        */
! };
! 
! struct SprSurface {
!     Uint16     vertNo[4];       /* 面を構成する頂点番号                      */
!     Uint16     drawMode;        /* 描画モード                                */
!     Uint16     color;           /* カラーデータ                              */
! };
! 
! struct SprInbetInf {
!     Sint32       vertCount;     /* 取り出し頂点数                            */
!     SprObject3D  *fromObj;      /* 接続頂点データ取り出しオブジェクト        */
!     Uint16       *fromVertNo;   /* 取り出し頂点番号配列                      */
!     SprObject3D  *toObj;        /* 接続頂点データ設定オブジェクト            */
!     Uint16       *toVertNo;     /* 設定頂点番号配列                          */
!     SprInbetInf  *next;         /* 次３Ｄオブジェクト間接続ポリゴン情報      */
! };
! 
! struct SprTexture {
!     Uint16       charNo;        /* キャラクタ番号                            */
!     Uint16       colorMode;     /* カラーモード                              */
!     Uint16       color;         /* カラーデータ（ｶﾗｰﾊﾞﾝｸorﾙｯｸｱｯﾌﾟﾃｰﾌﾞﾙNo）   */
!     Uint16       width;         /* キャラクタの幅                            */
!     Uint16       height;        /* キャラクタの高さ                          */
!     Uint8        *charData;     /* キャラクタデータのポインタ                */
!     SprLookupTbl *lookupTbl;    /* ルックアップテーブルのポインタ            */
! };
! 
! struct Spr3WorkArea {
!     Uint16      objSurfMax;        /* オブジェクト内最大面数                 */
!     Uint16      objVertMax;        /* オブジェクト内最大頂点数               */
!     Sint32      *surfBright[2];    /* 面輝度テーブル                         */
!     Sint32      *vertBright[2];    /* 頂点輝度テーブル                       */
!     MthXyz      *coordView3D[2];   /* ３Ｄ視点座標変換後テーブル             */
!     MthXyz      *coordWorld3D[2];  /* ３Ｄワールド座標変換後テーブル         */
!     XyInt       *coord2D;          /* ２Ｄ透視変換後テーブル                 */
!     Uint8       *coord2DFlag;      /* ２Ｄ透視変換処理フラグテーブル         */
! };
! 
! struct Spr3dStatus {
!     MthXyz    lightAngle;       /* 光源アングル                           */
!     MthXyz    viewCoordPoint;   /* 視点座標系内の視点位置                 */
!     MthXyz    viewPoint;        /* 視点座標                               */
!     MthXyz    viewAngle;        /* 視点アングル                           */
!     Sint32    viewAngleSeq;     /* 視点アングル回転操作                   */
!     Sint32    zSortMode;        /* ＺソートＺ座標値の採用モード           */
!     Fixed32   zSortZMin;        /* フラッシュ単位現Ｚ座標最小値           */
!     Fixed32   zSortZMax;        /* フラッシュ単位現Ｚ座標最大値           */
!     Fixed32   clipZMin;         /* 視点座標系クリップＺ最小値座標         */
!     Fixed32   clipZMax;         /* 視点座標系クリップＺ最大値座標         */
!     Sint32    clipLevel;        /* クリッピングレベル                     */
!     MthXy     unitPixel;        /* X,Y 1.0 に対するスクリーンのピクセル数 */
! };
! 
! 
! 
! /*
!  * GLOBAL DEFINES/MACROS DEFINES
!  */
! #define   ROT_SEQ_ZYX       0x0000
! #define   ROT_SEQ_ZXY       0x0001
! #define   ROT_SEQ_YZX       0x0002
! #define   ROT_SEQ_YXZ       0x0003
! #define   ROT_SEQ_XYZ       0x0004
! #define   ROT_SEQ_XZY       0x0005
! 
! #define   DISP_POLYGON      0x0000
! #define   DISP_POLYLINE     0x8000
! #define   DISP_MASK         0xc000
! #define   BOTH_FACE         0x1000
! 
! #define   NO_SHADING        0x0000
! #define   FLAT_SHADING      0x0100
! #define   GOURAUD_SHADING   0x0200
! #define   SHADING_MASK      0x0300
! #define   INBETWEEN_OBJECT  0x0010
! 
! #define   MATE_COLOR        0x0000
! #define   MATE_TEXTURE      0x4000
! #define   MATE_SHADING_TBL  0x8000
! #define   MATE_AUTO_SHADING 0xc000
! #define   MATE_MASK         0xc000
! 
! #define   ZSORT_MIN         0x0000
! #define   ZSORT_MAX         0x1000
! #define   ZSORT_MID         0x2000
! #define   ZSORT_MASK        0x3000
! #define   ZSORT_FLOAT_MODE  0
! #define   ZSORT_FIXED_MODE  1
! 
! #define   DRAW_MODE_MASK    0x07ff
! 
! #ifdef SPR_3USE_DOUBLE_BUF
! #define   SPR_3mac1(sp3ObjSurfMax) \
! static Sint32    sp3SurfBright1 [sp3ObjSurfMax]; \
! static Sint32    sp3SurfBright2 [sp3ObjSurfMax];
! #else
! #define   SPR_3mac1(sp3ObjSurfMax) \
! static Sint32    sp3SurfBright1 [sp3ObjSurfMax];
! #endif
! 
! #ifdef SPR_3USE_DOUBLE_BUF
!   #ifdef SPR_3NEED_WORLD_VERT
! #define   SPR_3mac2(sp3ObjVertMax) \
! static Sint32    sp3VertBright1   [sp3ObjVertMax];   \
! static MthXyz    sp3CoordView3D1  [sp3ObjVertMax];   \
! static MthXyz    sp3CoordWorld3D1 [sp3ObjVertMax];   \
! static Sint32    sp3VertBright2   [sp3ObjVertMax];   \
! static MthXyz    sp3CoordView3D2  [sp3ObjVertMax];   \
! static MthXyz    sp3CoordWorld3D2 [sp3ObjVertMax];   \
! static XyInt     sp3Coord2D       [sp3ObjVertMax];   \
! static Uint8     sp3Coord2DFlag   [sp3ObjVertMax];
!   #else
! #define   SPR_3mac2(sp3ObjVertMax) \
! static Sint32    sp3VertBright1   [sp3ObjVertMax];   \
! static MthXyz    sp3CoordView3D1  [sp3ObjVertMax];   \
! static Sint32    sp3VertBright2   [sp3ObjVertMax];   \
! static MthXyz    sp3CoordView3D2  [sp3ObjVertMax];   \
! static XyInt     sp3Coord2D       [sp3ObjVertMax];   \
! static Uint8     sp3Coord2DFlag   [sp3ObjVertMax];
!   #endif
! #else
!   #ifdef SPR_3NEED_WORLD_VERT
! #define   SPR_3mac2(sp3ObjVertMax) \
! static Sint32    sp3VertBright1   [sp3ObjVertMax];   \
! static MthXyz    sp3CoordView3D1  [sp3ObjVertMax];   \
! static MthXyz    sp3CoordWorld3D1 [sp3ObjVertMax];   \
! static XyInt     sp3Coord2D       [sp3ObjVertMax];   \
! static Uint8     sp3Coord2DFlag   [sp3ObjVertMax];
!   #else
! #define   SPR_3mac2(sp3ObjVertMax) \
! static Sint32    sp3VertBright1   [sp3ObjVertMax];   \
! static MthXyz    sp3CoordView3D1  [sp3ObjVertMax];   \
! static XyInt     sp3Coord2D       [sp3ObjVertMax];   \
! static Uint8     sp3Coord2DFlag   [sp3ObjVertMax];
!   #endif
! #endif
! 
! #ifdef SPR_3USE_DOUBLE_BUF
!   #ifdef SPR_3NEED_WORLD_VERT
! #define   SPR_3mac3(sp3WorkArea, sp3ObjSurfMax, sp3ObjVertMax)  \
! static Spr3WorkArea  sp3WorkArea = {                          \
!    sp3ObjSurfMax, sp3ObjVertMax, \
!    sp3SurfBright1, sp3SurfBright2, sp3VertBright1, sp3VertBright2, \
!    sp3CoordView3D1, sp3CoordView3D2, sp3CoordWorld3D1, sp3CoordWorld3D2, \
!    sp3Coord2D, sp3Coord2DFlag };
!   #else
! #define   SPR_3mac3(sp3WorkArea, sp3ObjSurfMax, sp3ObjVertMax)  \
! static Spr3WorkArea  sp3WorkArea = {                          \
!    sp3ObjSurfMax, sp3ObjVertMax, \
!    sp3SurfBright1, sp3SurfBright2, sp3VertBright1, sp3VertBright2, \
!    sp3CoordView3D1, sp3CoordView3D2,              NULL,            NULL, \
!    sp3Coord2D, sp3Coord2DFlag };
!   #endif
! #else
!   #ifdef SPR_3NEED_WORLD_VERT
! #define   SPR_3mac3(sp3WorkArea, sp3ObjSurfMax, sp3ObjVertMax) \
! static Spr3WorkArea  sp3WorkArea = {                          \
!    sp3ObjSurfMax, sp3ObjVertMax, \
!    sp3SurfBright1,           NULL, sp3VertBright1,           NULL, \
!    sp3CoordView3D1,          NULL, sp3CoordWorld3D1,         NULL, \
!    sp3Coord2D, sp3Coord2DFlag };
!   #else
! #define   SPR_3mac3(sp3WorkArea, sp3ObjSurfMax, sp3ObjVertMax) \
! static Spr3WorkArea  sp3WorkArea = {                          \
!    sp3ObjSurfMax, sp3ObjVertMax, \
!    sp3SurfBright1,            NULL, sp3VertBright1,           NULL, \
!    sp3CoordView3D1,           NULL,             NULL,             NULL, \
!    sp3Coord2D, sp3Coord2DFlag };
!   #endif
! #endif
! 
! #define   SPR_3DefineWork(sp3WorkArea, sp3ObjSurfMax, sp3ObjVertMax) \
!  SPR_3mac1(sp3ObjSurfMax) \
!  SPR_3mac2(sp3ObjVertMax) \
!  SPR_3mac3(sp3WorkArea, sp3ObjSurfMax, sp3ObjVertMax)
! 
! /*
!  * PROTOTYPE DECLARATIONS
!  */
! void   SPR_3Initial       (Spr3WorkArea  *workArea);
! void   SPR_3SetLight      (Uint16 moveKind, MthXyz *lightAngle);
! void   SPR_3SetView       (Uint16 moveKind, MthXyz *viewPoint,
!                            MthXyz *viewAngle, Uint16 angleSeq,
!                            MthXyz *viewCoordPoint);
! void   SPR_3MoveCluster   (SprCluster *cluster, Uint16 moveKind,
! 					   MthXyz *angle, MthXyz *point);
! void   SPR_3DrawModel     (SprCluster *rootCluster);
! void   SPR_3Flush         (void);
! void   SPR_3SetTexture    (SprTexture *texture);
! void   SPR_3ChangeTexColor(Uint16 charNo, Uint16 color,
!                                           SprLookupTbl *lookupTbl);
! void   SPR_3ClrTexture    (SprTexture *texture);
! void   SPR_3SetZSortMinMax(Uint16 pZSortMode,
!                                        Fixed32 pZSortZMin, Fixed32 pZSortZMax);
! void   SPR_3SetClipLevel  (Uint16 pClipLevel,
! 				       Fixed32 pClipZMin, Fixed32 pClipZMax);
! void   SPR_3SetPixelCount (Uint16 pixelCountX, Uint16 pixelCountY);
! void   SPR_3GetStatus (Spr3dStatus *spr3dStatus);
! void   SPR_3CallAllCluster(SprCluster *cluster, void (*userFunc)(SprCluster*));
! void   SPR_3SetSurfNormVect(SprObject3D  *obj);
! void   SPR_3SetDrawSpeed(Sint32 hssFlag, Sint32 eosFlag, Sint32 pclpFlag);
! #endif /* _SPR3_ */
! 
! #endif /* ifndef SEGA_SPR_H */
! 
! /*  end of file */
diff -crB --binary sbl6/segalib/include/sega_sys.h sbl6_patch/segalib/include/sega_sys.h
*** sbl6/segalib/include/sega_sys.h	1996-02-08 05:23:50.000000000 -0500
--- sbl6_patch/segalib/include/sega_sys.h	2021-11-21 17:38:42.000000000 -0500
***************
*** 3,20 ****
   *
   * ファイル名:  sega_sys.h
   *
-  * 日付:        1994/05/06  for BOOT 0.90,0.901,0.91  by T. S.
-  *              1994/07/16  for BOOT 0.92x,0.95       by T. S.
-  *              1994/07/29  for BOOT 0.96x,1.00       by T. S.
-  *              1994/08/31  how to exec CD multi-player
-  *              1994/09/21  for Ver.1.00 BOOT ROM
-  *              1995/03/31  MPEG check service
-  *              1995/09/26  Ver.2.01 : sega_sys.lib   by M. M.
-  *              1995/12/06  Ver.2.04 : SYS_Exit修正   by M. M.
-  *              1996/01/31  Ver.2.10 : SYS_Exit修正   by M. M.
-  *
-  * バージョン:  Ver.2.10
-  *
   * 目的:        BOOT ROM のサービスルーチンを定義します。
   *
   *              (1) SCU 割り込みサービスルーチンの登録参照
--- 3,8 ----
***************
*** 25,33 ****
   *              (6) SCU 割り込みルーチン優先度の変更(SCU2.1以降)
   *              (7) CD  マルチプレーヤの起動実行(CD付きモデル用)
   *              (8) パワーオンクリアメモリの操作 (ROM V1.00以降)
-  *              (9) MPEG チェック(完了復帰型)    (ROM V1.00以降)
-  *
-  *              sega_sys.lib内の関数を宣言します。（Ver.2.01以降）
   *
   * 使用方法:
   *
--- 13,18 ----
***************
*** 41,49 ****
   *      void  test()
   *      {
   *           void (*tmp)();
!  *           Sint32 rep;
!  *           Uint32 msk, clk, lval1;
!  *           Uint8  p0;
   *           const Uint32 PriTab[32] = {
   *              0x00f0ffff, 0x00e0fffe, 0x00d0fffc, 0x00c0fff8,
   *              0x00b0fff0, 0x00a0ffe0, 0x0090ffc0, 0x0080ff80,
--- 26,34 ----
   *      void  test()
   *      {
   *           void (*tmp)();
!  *           Sint32	rep;
!  *           Uint32	msk, clk, lval1;
!  *           Uint8 	p0;
   *           const Uint32 PriTab[32] = {
   *              0x00f0ffff, 0x00e0fffe, 0x00d0fffc, 0x00c0fff8,
   *              0x00b0fff0, 0x00a0ffe0, 0x0090ffc0, 0x0080ff80,
***************
*** 82,90 ****
   *
   *           p0 = SYS_PCLRMEM;          // パワーオンクリアメモリ先頭バイト  //
   *           lval1 = *((Uint32*)&SYS_PCLRMEM+1); // と後半ロングワードを参照 //
-  *
-  *           rep = SYS_CHKMPEG(0);      // 引数は必ず 0. mansys.txt の使用例 //
-  *                                      // に従ってください                  //
   *      }
   *
   *      // ... 別のファイル ... //
--- 67,72 ----
***************
*** 94,167 ****
   *           // ... 実行文 ... //
   *      }
   *
   */
  
! #ifndef SEGA_SYS_H
  #define SEGA_SYS_H
  
- /***********************************************************************
-  *      インクルードファイル
-  ***********************************************************************/
  #include "sega_xpt.h"
  
- /*****************************************************************************
-  *      定数マクロ
-  *****************************************************************************/
- 
- /* バージョン */
-                     /*             1         2         3         4    */
-                     /*    1234567890123456789012345678901234567890    */
-                     /*    ++++++++++++++++++++++++++++++++            */
- #define SYS_VERSION_STR ("SYS Version 2.10 1996-01-31")
- #define SYS_VERSION_LEN         (32)
- 
- /***********************************************************************
-  *      処理マクロ
-  ***********************************************************************/
  #define SYS_SETUINT(_Num_, _Hdr_) \
!         ((**(volatile void(**)(Uint32, void*))0x6000300)((_Num_), (_Hdr_)))
  #define SYS_GETUINT(_Num_) \
          ((void*)(**(void(*(**)(Uint32))(Uint32))0x6000304)(_Num_))
  
  #define SYS_SETSINT(_Num_, _Hdr_) \
!         ((**(volatile void(**)(Uint32, void*))0x6000310)((_Num_), (_Hdr_)))
  #define SYS_GETSINT(_Num_) \
          ((void*)(**(void(*(**)(Uint32))(Uint32))0x6000314)(_Num_))
  
  #define SYS_TASSEM(_Num_) \
!         ((**(volatile Uint32(**)(Uint32))0x6000330)(_Num_))
  #define SYS_CLRSEM(_Num_) \
!         ((**(volatile void(**)(Uint32))0x6000334)(_Num_))
  
  #define SYS_SETSCUIM(_MaskPat_) \
!         ((**(volatile void(**)(Uint32))0x6000340)(_MaskPat_))
  #define SYS_CHGSCUIM(_AndMask_, _OrMask_) \
!         ((**(volatile void(**)(Uint32, Uint32))0x6000344)((_AndMask_), (_OrMask_)))
  #define SYS_GETSCUIM \
!         (*(volatile Uint32*)0x6000348)
  
  #define SYS_CHGSYSCK(_CkMode_) \
!         ((**(volatile void(**)(Uint32))0x6000320)(_CkMode_))
  #define SYS_GETSYSCK \
!         (*(volatile Uint32*)0x6000324)
  
  #define SYS_CHGUIPR(_IprTab_) \
!         ((**(volatile void(**)(Uint32*))0x6000280)(_IprTab_))
  
  #define SYS_EXECDMP \
!         (**(volatile void(**)(void))0x600026C)
  
  #define SYS_PCLRMEM \
!         (*(volatile Uint8*)0x6000210)
! 
! #define SYS_CHKMPEG(_dummy_) \
!         ((**(volatile Sint32(**)(Sint32))0x6000274)(_dummy_))
! 
! /***********************************************************************
!  *      関数の宣言
!  ***********************************************************************/
! void SYS_CheckTrack(Sint32 tno);
! void SYS_Exit(Sint32 code);
  
  #endif
- 
\ No newline at end of file
--- 76,128 ----
   *           // ... 実行文 ... //
   *      }
   *
+  *
+  * 日付:        1994/05/06  for BOOT 0.90,0.901,0.91  by T. S.
+  *              1994/07/16  for BOOT 0.92x,0.95       by T. S.
+  *              1994/07/29  for BOOT 0.96x,1.00       by T. S.
+  *              1994/08/31  how to exec CD multi-player
+  *              1994/09/21  for Ver.1.00 BOOT ROM
   */
  
! #ifndef	SEGA_SYS_H
  #define SEGA_SYS_H
  
  #include "sega_xpt.h"
  
  #define SYS_SETUINT(_Num_, _Hdr_) \
!         ((**(void(**)(Uint32, void*))0x6000300)((_Num_), (_Hdr_)))
  #define SYS_GETUINT(_Num_) \
          ((void*)(**(void(*(**)(Uint32))(Uint32))0x6000304)(_Num_))
  
  #define SYS_SETSINT(_Num_, _Hdr_) \
!         ((**(void(**)(Uint32, void*))0x6000310)((_Num_), (_Hdr_)))
  #define SYS_GETSINT(_Num_) \
          ((void*)(**(void(*(**)(Uint32))(Uint32))0x6000314)(_Num_))
  
  #define SYS_TASSEM(_Num_) \
!         ((**(Uint32(**)(Uint32))0x6000330)(_Num_))
  #define SYS_CLRSEM(_Num_) \
!         ((**(void(**)(Uint32))0x6000334)(_Num_))
  
  #define SYS_SETSCUIM(_MaskPat_) \
!         ((**(void(**)(Uint32))0x6000340)(_MaskPat_))
  #define SYS_CHGSCUIM(_AndMask_, _OrMask_) \
!         ((**(void(**)(Uint32, Uint32))0x6000344)((_AndMask_), (_OrMask_)))
  #define SYS_GETSCUIM \
!         (*(Uint32*)0x6000348)
  
  #define SYS_CHGSYSCK(_CkMode_) \
!         ((**(void(**)(Uint32))0x6000320)(_CkMode_))
  #define SYS_GETSYSCK \
!         (*(Uint32*)0x6000324)
  
  #define SYS_CHGUIPR(_IprTab_) \
!         ((**(void(**)(Uint32*))0x6000280)(_IprTab_))
  
  #define SYS_EXECDMP \
!         (**(void(**)(void))0x600026C)
  
  #define SYS_PCLRMEM \
!         (*(Uint8*)0x6000210)
  
  #endif
diff -crB --binary sbl6/segalib/mth/mth_dsp.c sbl6_patch/segalib/mth/mth_dsp.c
*** sbl6/segalib/mth/mth_dsp.c	1996-02-08 05:25:02.000000000 -0500
--- sbl6_patch/segalib/mth/mth_dsp.c	2021-11-14 20:09:08.000000000 -0500
***************
*** 15,20 ****
--- 15,24 ----
   */
  
  /*
+  * C STANDARD LIBRARY FUNCTIONS/MACROS DEFINES
+  */
+ #include <string.h>
+ /*
   * USER SUPPLIED INCLUDE FILES
   */
  #include "sega_mth.h"
***************
*** 160,163 ****
  }
  
  /*  end of file */
! 
\ No newline at end of file
--- 164,167 ----
  }
  
  /*  end of file */
! 
Only in sbl6_patch/segalib/mth: mth_fixd.s
Only in sbl6_patch/segalib/mth: mth_mtrx.s
Only in sbl6_patch/segalib/mth: mth_norm.s
Only in sbl6_patch/segalib/mth: mth_ps2d.s
Only in sbl6_patch/segalib/mth: mth_tri.s
diff -crB --binary sbl6/segalib/scl/scl_func.c sbl6_patch/segalib/scl/scl_func.c
*** sbl6/segalib/scl/scl_func.c	1996-04-01 07:31:58.000000000 -0500
--- sbl6_patch/segalib/scl/scl_func.c	2021-11-17 07:35:52.000000000 -0500
***************
*** 22,29 ****
  
  #include <sega_scl.h> 
  #include <sega_dma.h> 
! #include	<sgl_work.h>
! #include	<sgl.h>
  
  #define	DMAOFF
  
--- 22,29 ----
  
  #include <sega_scl.h> 
  #include <sega_dma.h> 
! //#include	<sgl_work.h>
! //#include	<sgl.h>
  
  #define	DMAOFF
  
***************
*** 53,59 ****
  	SclNorscl	Scl_n_reg;
  	SclRotscl	Scl_r_reg;
  	SclWinscl	Scl_w_reg;
! 	SclSblSgl	Scl_flag;
  
  /* このファイルが参照する大域変数の宣言 */
  extern	SclPriBuffDirtyFlags	SclPriBuffDirty;
--- 53,59 ----
  	SclNorscl	Scl_n_reg;
  	SclRotscl	Scl_r_reg;
  	SclWinscl	Scl_w_reg;
! 	//SclSblSgl	Scl_flag;
  
  /* このファイルが参照する大域変数の宣言 */
  extern	SclPriBuffDirtyFlags	SclPriBuffDirty;
***************
*** 102,109 ****
  	void	SCL_ScrollShow(void);
  	void	SCL_PriIntProc(void);
  	void	SCL_Memcpyw(void *dest,void *src,Uint32 tcnt);
! 	void	SCL_SglOn(void);		/*	use SGL	*/
! 	void	SCL_SglOff(void);		/*	use SGL	*/
  
  extern	void   SCL_Rotate(Fixed32 xy,Fixed32 z,Fixed32 disp);
  
--- 102,109 ----
  	void	SCL_ScrollShow(void);
  	void	SCL_PriIntProc(void);
  	void	SCL_Memcpyw(void *dest,void *src,Uint32 tcnt);
! 	//void	SCL_SglOn(void);		/*	use SGL	*/
! 	//void	SCL_SglOff(void);		/*	use SGL	*/
  
  extern	void   SCL_Rotate(Fixed32 xy,Fixed32 z,Fixed32 disp);
  
***************
*** 828,840 ****
  
  }
  
! void SCL_SglOn(void){
  	SclRotregBuff = ( SclRotreg * )RotScrParA;
  	Scl_flag.sgl_flag=0x0001;
! }
  
! void SCL_SglOff(void){
  	Scl_flag.sgl_flag=0x0000;
  	SclRotregBuff = _SclRotregBuff;
! }
  
--- 828,840 ----
  
  }
  
! /*void SCL_SglOn(void){
  	SclRotregBuff = ( SclRotreg * )RotScrParA;
  	Scl_flag.sgl_flag=0x0001;
! }*/
  
! /*void SCL_SglOff(void){
  	Scl_flag.sgl_flag=0x0000;
  	SclRotregBuff = _SclRotregBuff;
! }*/
  
diff -crB --binary sbl6/segalib/spr/spr_3c.c sbl6_patch/segalib/spr/spr_3c.c
*** sbl6/segalib/spr/spr_3c.c	1996-02-08 05:25:40.000000000 -0500
--- sbl6_patch/segalib/spr/spr_3c.c	2021-04-21 19:17:26.000000000 -0400
***************
*** 1,2185 ****
! /*----------------------------------------------------------------------------
!  *  spr_3c.c -- SPR ライブラリ 3C モジュール
!  *  Copyright(c) 1994 SEGA
!  *  Written by H.E on 1994-02-15 Ver.0.80
!  *  Updated by H.E on 1994-07-25 Ver.1.00
!  *
!  *  このライブラリはスプライト３Ｄ表示処理モジュールで、以下のルーチンを含む。
!  *
!  *  SPR_3Initial            -  ３Ｄスプライト表示の初期化
!  *  SPR_3SetLight           -  光源ベクタのセット        
!  *  SPR_3SetView            -  視点のセット              
!  *  SPR_3CallAllCluster     -  全クラスタに対するファンクションコール
!  *  SPR_3MoveCluster        -  クラスタの移動
!  *  SPR_3DrawModel          -  モデルの登録
!  *  SPR_3Flush              -  モデルの描画              
!  *  SPR_3SetTexture         -  テクスチャのセット
!  *  SPR_3ChangeTexColor     -  テクスチャカラーデータの変更
!  *  SPR_3ClrTexture         -  テクスチャエリアの解放
!  *  SPR_3SetClipLevel       -  クリッピングレベルのセット    
!  *  SPR_3SetZSortMinMax     -  視点座標系Ｚソート範囲の最小・最大値をセット
!  *  SPR_3SetPixelCount      -  単位ピクセル数のセット    
!  *  SPR_3SetTransPostRtn    -  座標変換結果通知ルーチンのセット    
!  *  SPR_3GetStatus          -  現３Ｄ環境データの取得
!  *  SPR_3SetSurfNormVect    -  ３Ｄオブジェクトの面法線を計算しセット
!  *  SPR_3SetDrawSpeed       -  ＶＤＰ１の高速描画パラメータをセット
!  *
!  *  このライブラリを使用するには次のインクルードファイルとワークエリアを定義す
!  *  る必要がある。
!  *
!  *   #include "sega_scl.h"
!  *   #define  _SPR3_
!  *   #include "sega_spr.h"
!  *
!  *   #define CommandMax    100          // 最大コマンド数
!  *   #define GourTblMax    100          // 最大グーローテーブル数
!  *   #define LookupTblMax  100          // 最大ルックアップテーブル数
!  *   #define CharMax       100          // 最大キャラクタ数
!  *   #define DrawPrtyMax   256          // 最大プライオリティブロック数
!  *   SPR_2DefineWork(work2D,
!  *                CommandMax, GourTblMax, LookupTblMax, CharMax, DrawPrtyMax)
!  *                                      // ２Ｄワークエリア定義
!  *
!  *   #define ObjSurfMax     16          // ３Ｄオブジェクトの最大面数
!  *   #define ObjVertMax     16          // ３Ｄオブジェクトの最大頂点数
!  *   SPR_3DefineWork(work3D, ObjSurfMax, ObjVertMax)
!  *                                      // ３Ｄワークエリア定義
!  *
!  *----------------------------------------------------------------------------
!  */
! 
! /*
!  * USER SUPPLIED INCLUDE FILES
!  */
! #define  _SPR3_
! #include "sega_spr.h"
! 
! #ifdef _SH
! #include <machine.h>
! #endif
! 
! /*
!  * GLOBAL DEFINES/MACROS DEFINES
!  */
! #define   SCREEN_W_SIZE     256
! #define   SCREEN_H_SIZE     256
! 
! #define   FRMBUF_MIN_X     -1000
! #define   FRMBUF_MAX_X      1000
! #define   FRMBUF_MIN_Y     -1000
! #define   FRMBUF_MAX_Y      1000
! 
! #define   FIXED_MIN        0x80000000
! #define   FIXED_MAX        0x7fffffff
! #define   CLIP_MIN_Z       FIXED_MIN
! #define   CLIP_MAX_Z       MTH_FIXED(-0.005)
! #define   ZSORT_MIN_Z      MTH_FIXED(-10.0)
! #define   ZSORT_MAX_Z      MTH_FIXED(0)
! 
! #define	WORLD_MATRIX_STACK_SIZE	32
! 
! /*
!  * DATA TYPE DECLARATIONS
!  */
! typedef struct PolTbl  PolTbl;
! struct PolTbl {
!     Uint16     dispFlag;        /* 表示フラグ                                */
!     Uint16     surfBright;      /* 面輝度                                    */
!     Uint16     drawMode;        /* 描画モード                                */
!     Uint16     color;           /* カラーデータ                              */
!     Uint16     polyCnt;         /* ２Ｄポリゴン数                            */
!     XyInt      xy[16];          /* ２Ｄポリゴン座標                          */
!     SprGourTbl gourTbl;         /* グーローテーブル                          */
!     Fixed32    z;               /* 描画ポリゴンＺ                            */
! };
! typedef struct DoubleBufArea  DoubleBufArea;
! struct DoubleBufArea {
!     SprCluster  *cluster;       /* クラスタ                                  */
!     SprObject3D *object;        /* ３Ｄオブジェクト                          */
!     Sint32      *surfBright;    /* 面輝度テーブル                            */
!     Sint32      *vertBright;    /* 頂点輝度テーブル                          */
!     MthXyz      *coordView3D;   /* ３Ｄ視点座標変換後テーブル                */
!     MthXyz      *coordWorld3D;  /* ３Ｄワールド座標変換後テーブル            */
! };
! 
! /*
!  * GLOBAL DECLARATIONS
!  */
! extern Sint32      Sp2OpenFlag;             /* Open Command Exec Flag        */
! extern SprCharTbl *SpCharTbl;               /* Character Table Pointer       */
! extern Sint32      SpCharMax;               /* Character Table Entry Count   */
! extern Sint32      SpDrawPrtyBlkMax;        /* Draw Priority Block Max Count */
! 
! /*
!  * STATIC DECLARATIONS
!  */
! static MthMatrix    viewMatrix;
! static MthMatrix    lightMatrix;
! static MthMatrix    worldMatrix [WORLD_MATRIX_STACK_SIZE];
! static MthMatrixTbl viewMatrixTbl;
! static MthMatrixTbl lightMatrixTbl;
! static MthMatrixTbl worldMatrixTbl;
! 
! static MthViewLight      viewLight;
! static MthPolyTransParm  polyTransParm;
! 
! static DoubleBufArea dBuf[2];      /* 座標変換ダブルバッファエリア管理       */
! static DoubleBufArea *cBuf;        /* カレント座標変換バッファ               */
! static Sint32    doubleBufFlag;    /* ダブルバッファ有りフラグ               */
! static Sint32    bufSW;            /* カレントダブルバッファＳＷ  0 or 1     */
! static Sint32    dbFirstFlag;      /* ダブルバッファ操作ファーストフラグ     */
! static Sint32    firstDrawFlag;    /* フラッシュ後最初のモデル描画フラグ     */
! static MthXy     unitPixel;        /* X,Y 1.0 に対するスクリーンのピクセル数 */
! static MthXyz    lightAngle;       /* 光源アングル                           */
! static MthXyz	 worldLightVector; /* ワールド座標系での光源ベクトル         */
! static MthXyz    viewCoordPoint;   /* 視点座標系内の視点位置                 */
! static MthXyz    viewPoint;        /* 視点座標                               */
! static MthXyz    viewAngle;        /* 視点アングル                           */
! static Sint32	 viewAngleSeq;     /* 視点アングル回転操作                   */
! static XyInt     *coord2D;         /* ２Ｄ透視変換後テーブル                 */
! static Uint8     *coord2DFlag;     /* ２Ｄ透視変換処理フラグテーブル         */
! static Sint32    gourTblNo;        /* フラッシュ単位グーローテーブルカウンタ */
! static Fixed32   zSortZMinOrg;     /* フラッシュ単位元Ｚ座標最小値           */
! static Fixed32   zSortZMaxOrg;     /* フラッシュ単位元Ｚ座標最大値           */
! static Fixed32   zSortZMin;        /* フラッシュ単位現Ｚ座標最小値           */
! static Fixed32   zSortZMax;        /* フラッシュ単位現Ｚ座標最大値           */
! static Fixed32   zSortBZMin;       /* フラッシュ単位前Ｚ座標最小値           */
! static Fixed32   zSortBZMax;       /* フラッシュ単位前Ｚ座標最大値           */
! static Uint16    zSortBlkCnt;      /* Ｚソートブロック数                     */
! static Sint32    zSortMode;        /* ＺソートＺ座標値の採用モード           */
! static int       blkSftCnt;        /* Ｚソートブロックハッシュ用シフト数     */
! static int       zSftCnt;          /* ＺソートＺシフト数                     */
! static Sint16    clipScrXMin;      /* スクリーン境界Ｘ最小値座標             */
! static Sint16    clipScrXMax;      /* スクリーン境界Ｘ最大値座標             */
! static Sint16    clipScrYMin;      /* スクリーン境界Ｙ最小値座標             */
! static Sint16    clipScrYMax;      /* スクリーン境界Ｙ最大値座標             */
! static Fixed32   clipZMin;         /* 視点座標系クリップＺ最小値座標         */
! static Fixed32   clipZMax;         /* 視点座標系クリップＺ最大値座標         */
! static Sint32    clipLevel;        /* クリッピングレベル                     */
! 				   /*   ０＝クリッピングなし                 */
! 				   /*   １＝視点座標系のＺ範囲でクリップ     */
!                                    /*       （座標変換後）                   */
!                                    /*   ２＝スクリーンに掛からないポリゴンの */
! 				   /*       削除（透視変換後）               */
!                                    /*   ３＝フレームバッファの境界でクリップ */
!                                    /*       （透視変換後）                   */
! static Uint16   postWorldDataFlag; /* ワールド座標通知要フラグ               */
! static Sint32   spriteDrawFlag;    /* 変形スプライト描画フラグ               */
! static Sint32   otherDrawFlag;     /* その他ポリゴン描画フラグ               */
! 
! static	MthXyz	orgLightVect =
! 	    { MTH_FIXED(0.0), MTH_FIXED(0.0), MTH_FIXED(-1.0)};
! 
! 
! static void   initDraw(void);
! static void   drawPol(PolTbl *polTbl);
! static void   transCluster(SprCluster *cluster);
! static void   setInbetPolygons(DoubleBufArea *buf);
! static int    clip2DLevel2(PolTbl *polTbl);
! static Sint32 clipScrCheck(XyInt *xy1, XyInt *xy2, Sint32 chkCnt);
! static Sint32 outcodeScr(XyInt *xy1, XyInt *xy2);
! static int    clip2DLevel3(PolTbl *polTbl);
! static Sint32 clipFrmCheck(XyInt *xy1, XyInt *xy2, Sint32 chkCnt);
! static Sint32 outcodeFrm(XyInt *xy1, XyInt *xy2);
! static int    clipFrame(PolTbl *polTbl);
! static int    frmCrossChk(int frmNo, XyInt *p1, XyInt *p2, XyInt *cp);
! static void   transPolygons(DoubleBufArea *buf, XyInt *vert2d);
! static void   viewCoordMatrix(void);
! static void   setLightAngle(void);
! extern Uint16 SPR_3GetShdColor(Uint16 baseRgbColor, Uint16 bright);
! 
! 
! 
! /*****************************************************************************
!  *
!  * NAME:  SPR_3Initial()  - Initial 3D Sprite Display Environment
!  *
!  * PARAMETERS :
!  *
!  * 　　(1) Spr3WorkArea *workArea - <i> ３Ｄスプライトワークエリア定義
!  *
!  * DESCRIPTION:
!  *
!  *     ３Ｄスプライト表示の初期化処理
!  *
!  *
!  * POSTCONDITIONS:
!  *
!  *     No exist.
!  *
!  * CAVEATS:
!  *
!  *****************************************************************************
!  */
! void
! SPR_3Initial(Spr3WorkArea  *workArea)
! {
!     MthXyz  w0,w1;
! 
!     /** BEGIN ***************************************************************/
!     SPR_3SetDrawSpeed(0, 0, 0);
!     
!     dBuf[0].surfBright   = workArea->surfBright[0];
!     dBuf[1].surfBright   = workArea->surfBright[1];
!     dBuf[0].vertBright   = workArea->vertBright[0];
!     dBuf[1].vertBright   = workArea->vertBright[1];
!     dBuf[0].coordView3D  = workArea->coordView3D[0];
!     dBuf[1].coordView3D  = workArea->coordView3D[1];
!     dBuf[0].coordWorld3D = workArea->coordWorld3D[0];
!     dBuf[1].coordWorld3D = workArea->coordWorld3D[1];
!     if(workArea->surfBright[1])
!         doubleBufFlag = 1;
!     else
!         doubleBufFlag = 0;
!     if(workArea->coordWorld3D[0])
!         postWorldDataFlag = 1;
!     else
!         postWorldDataFlag = 0;
! 
!     if(!dBuf[1].surfBright)   dBuf[1].surfBright   = dBuf[0].surfBright;
!     if(!dBuf[1].vertBright)   dBuf[1].vertBright   = dBuf[0].vertBright;
!     if(!dBuf[1].coordView3D)  dBuf[1].coordView3D  = dBuf[0].coordView3D;
!     if(!dBuf[1].coordWorld3D) dBuf[1].coordWorld3D = dBuf[0].coordWorld3D;
! 
!     coord2D      = workArea->coord2D;
!     coord2DFlag  = workArea->coord2DFlag;
! 
!     zSortBlkCnt = SpDrawPrtyBlkMax;
!     for(blkSftCnt=0; blkSftCnt<16; blkSftCnt++)
!        if((zSortBlkCnt<<=1) & 0x8000) break;
!     zSortBlkCnt = SpDrawPrtyBlkMax;
!     zSortZMin = ZSORT_MIN_Z;
!     zSortZMax = ZSORT_MAX_Z;
!     zSortMode = ZSORT_FLOAT_MODE;
! 
!     clipLevel = 2;
!     clipZMin  = CLIP_MIN_Z;
!     clipZMax  = CLIP_MAX_Z;
! 
!     w0.x = MTH_FIXED(0.0);   w0.y = MTH_FIXED(0.0);     w0.z = MTH_FIXED(0.0);
!     SPR_3SetLight(1, &w0);
!     w0.x = MTH_FIXED(0.0);   w0.y = MTH_FIXED(0.0);     w0.z = MTH_FIXED(0.0);
!     w1.x = MTH_FIXED(0.0);   w1.y = MTH_FIXED(0.0);     w1.z = MTH_FIXED(0.0);
!     SPR_3SetView(1, &w0, &w1, ROT_SEQ_XYZ, &w0);
! 
!     firstDrawFlag = 1;
!     MTH_InitialMatrix(&worldMatrixTbl, WORLD_MATRIX_STACK_SIZE,	worldMatrix);
!     MTH_PolyDataTransInit();
!     SPR_3SetPixelCount(SCREEN_W_SIZE, SCREEN_H_SIZE);
! }
! 
! 
! /*****************************************************************************
!  *
!  * NAME:  SPR_3SetLight()  - Set Light Angle
!  *
!  * PARAMETERS :
!  *
!  *     (1) Uint16      moveKind  - <i> 移動量の種別ーブルポインタ
!  *                       　　　　　    0 = 相対移動、1 = 絶対移動タ
!  *     (2) MthXyz *pLightAngler  - <i>  平行光源のアングル
!  *
!  * DESCRIPTION:
!  *
!  *     光源アングルセット
!  *
!  * POSTCONDITIONS:
!  *
!  *     No exist.
!  *
!  * CAVEATS:
!  *
!  *****************************************************************************
!  */
! void
! SPR_3SetLight(Uint16 moveKind, MthXyz *pLightAngle)
! {
!     Fixed32 angleX, angleY, angleZ;
!     
!     /** BEGIN ***************************************************************/
!     if(moveKind & 0x0002) {
!         angleX = MTH_Atan(pLightAngle->y, pLightAngle->z);
!         angleY = MTH_Atan(pLightAngle->z, pLightAngle->x);
!         angleZ = MTH_Atan(pLightAngle->y, pLightAngle->x);
!     } else  {
!         angleX = pLightAngle->x;
!         angleY = pLightAngle->y;
!         angleZ = pLightAngle->z;
!     }
!     if(moveKind & 0x0001) {
! 	lightAngle.x  = angleX;
! 	lightAngle.y  = angleY;
! 	lightAngle.z  = angleZ;
!     } else       {
! 	lightAngle.x  += angleX;
! 	lightAngle.y  += angleY;
! 	lightAngle.z  += angleZ;
!     }
!     if(lightAngle.x > MTH_FIXED( 180)) lightAngle.x -= MTH_FIXED(360);  else
!     if(lightAngle.x < MTH_FIXED(-180)) lightAngle.x += MTH_FIXED(360);
!     if(lightAngle.y > MTH_FIXED( 180)) lightAngle.y -= MTH_FIXED(360);  else
!     if(lightAngle.y < MTH_FIXED(-180)) lightAngle.y += MTH_FIXED(360);
!     if(lightAngle.z > MTH_FIXED( 180)) lightAngle.z -= MTH_FIXED(360);  else
!     if(lightAngle.z < MTH_FIXED(-180)) lightAngle.z += MTH_FIXED(360);
!     setLightAngle();
! }
! 
! 
! /*****************************************************************************
!  *
!  * NAME:  SPR_3SetView()  - Set View Point and Angle
!  *
!  * PARAMETERS :
!  *
!  *     (1) Uint16  moveKind         - <i> 移動量の種別ーブルポインタ
!  *                       　　　　　       0 = 相対移動、1 = 絶対移動タ
!  *     (2) MthXyz *pViewPoint       - <i> 視点座標
!  *     (3) MthXyz *pViewAngle       - <i> 視点のアングル（度）
!  *     (4) Uint16  pViewAngleSeq    - <i> アングルの回転操作
!  *　　　　　　　　　　　    　            ROT_SEQ_ZYX
!  *　　　　　　　　　　　    　            ROT_SEQ_ZXY
!  *　　　　　　　　　　　    　            ROT_SEQ_YZX
!  *　　　　　　　　　　　    　            ROT_SEQ_YXZ
!  *　　　　　　　　　　　    　            ROT_SEQ_XYZ
!  *　　　　　　　　　　　    　            ROT_SEQ_XZY
!  *     (5) MthXyz *pViewCoordPoint  - <i> 視点座標系内の視点位置
!  *
!  * DESCRIPTION:
!  *
!  *     視点のセット
!  *
!  * POSTCONDITIONS:
!  *
!  *     No exist.
!  *
!  * CAVEATS:
!  *
!  *****************************************************************************
!  */
! void
! SPR_3SetView(Uint16 moveKind, MthXyz *pViewPoint, MthXyz *pViewAngle,
!                               Uint16 pViewAngleSeq, MthXyz *pViewCoordPoint)
! {
!     Fixed32 angleX, angleY, angleZ;
!     
!     /** BEGIN ***************************************************************/
!     viewAngleSeq = pViewAngleSeq;
! 
!     if(pViewCoordPoint) {
!         if(moveKind & 0x0001) {
! 	    viewCoordPoint.x  = pViewCoordPoint->x;
! 	    viewCoordPoint.y  = pViewCoordPoint->y;
! 	    viewCoordPoint.z  = pViewCoordPoint->z;
!         } else       {
! 	    viewCoordPoint.x += pViewCoordPoint->x;
! 	    viewCoordPoint.y += pViewCoordPoint->y;
! 	    viewCoordPoint.z += pViewCoordPoint->z;
!         }
!     }
! 
!     if(pViewPoint) {
!         if(moveKind & 0x0001) {
! 	    viewPoint.x  = pViewPoint->x;
! 	    viewPoint.y  = pViewPoint->y;
! 	    viewPoint.z  = pViewPoint->z;
!         } else       {
! 	    viewPoint.x += pViewPoint->x;
! 	    viewPoint.y += pViewPoint->y;
! 	    viewPoint.z += pViewPoint->z;
!         }
!     }
! 
!     if(pViewAngle) {
!         if(moveKind & 0x0002) {
!             angleX = MTH_Atan(pViewAngle->y, pViewAngle->z);
!             angleY = MTH_Atan(pViewAngle->z, pViewAngle->x);
!             angleZ = MTH_Atan(pViewAngle->y, pViewAngle->x);
!         } else  {
!             angleX = pViewAngle->x;
!             angleY = pViewAngle->y;
!             angleZ = pViewAngle->z;
!         }
!         if(moveKind & 0x0001) {
! 	    viewAngle.x  = angleX;
! 	    viewAngle.y  = angleY;
! 	    viewAngle.z  = angleZ;
!         } else       {
! 	    viewAngle.x += angleX;
! 	    viewAngle.y += angleY;
! 	    viewAngle.z += angleZ;
!         }
!         if(viewAngle.x > MTH_FIXED( 180)) viewAngle.x -= MTH_FIXED(360);  else
!         if(viewAngle.x < MTH_FIXED(-180)) viewAngle.x += MTH_FIXED(360);
!         if(viewAngle.y > MTH_FIXED( 180)) viewAngle.y -= MTH_FIXED(360);  else
!         if(viewAngle.y < MTH_FIXED(-180)) viewAngle.y += MTH_FIXED(360);
!         if(viewAngle.z > MTH_FIXED( 180)) viewAngle.z -= MTH_FIXED(360);  else
!         if(viewAngle.z < MTH_FIXED(-180)) viewAngle.z += MTH_FIXED(360);
!     }
! 
! }
! 
! 
! /*****************************************************************************
!  *
!  * NAME:  SPR_3CallAllCluster()  - Call User Function with all Cluster
!  *
!  * PARAMETERS :
!  *
!  *     (1) SprCluster *cluster           - <i> ルートクラスタテーブルのポインタ
!  *     (2) void (*userFunc)(SprCluster*) - <i> ユーザファンクション
!  *
!  * DESCRIPTION:
!  *
!  *     ルートクラスタにつながる全クラスタをパラメータとして指定ファンクション
!  *     を呼び出す
!  *
!  * POSTCONDITIONS:
!  *
!  *     No exist.
!  *
!  * CAVEATS:
!  *
!  *****************************************************************************
!  */
! void   SPR_3CallAllCluster(SprCluster *cluster, void (*userFunc)(SprCluster*))
! {
!     /** BEGIN ***************************************************************/
!     while(cluster) {
!         userFunc(cluster);
! 	/* 子クラスタの処理 */
! 	if(cluster->child) SPR_3CallAllCluster(cluster->child, userFunc);
!         cluster = cluster->next;
!     }
! }
! 
! 
! /*****************************************************************************
!  *
!  * NAME:  SPR_3MoveCluster()  - Move Specify Cluster
!  *
!  * PARAMETERS :
!  *
!  *     (1) SprCluster *cluster   - <i> 移動すべきクラスタテーブルのポインタ
!  *     (2) Uint16      moveKind  - <i> 移動量の種別ーブルポインタ
!  *                       　　　　　    0 = 相対移動、1 = 絶対移動タ
!  *     (3) MthXyz     *angle     - <i> 回転移動量（度）
!  *     (4) MthXyz     *point     - <i> 平行移動量テーブルポインタ
!  *
!  * DESCRIPTION:
!  *
!  *     クラスタの移動
!  *
!  * POSTCONDITIONS:
!  *
!  *     No exist.
!  *
!  * CAVEATS:
!  *
!  *****************************************************************************
!  */
! void
! SPR_3MoveCluster(SprCluster *cluster, Uint16 moveKind,
! 				      MthXyz *angle, MthXyz *point)
! {
!     Fixed32 angleX, angleY, angleZ;
!     
!     /** BEGIN ***************************************************************/
!     if(angle) {
!         if(moveKind & 0x0002) {
!             angleX = MTH_Atan(angle->y, angle->z);
!             angleY = MTH_Atan(angle->z, angle->x);
!             angleZ = MTH_Atan(angle->y, angle->x);
!         } else  {
! 	    angleX = angle->x;
! 	    angleY = angle->y;
! 	    angleZ = angle->z;
!         }
!         if(moveKind & 0x0001) {
!    	    cluster->angle.x  = angleX;
! 	    cluster->angle.y  = angleY;
! 	    cluster->angle.z  = angleZ;
!         } else       {
! 	    cluster->angle.x += angleX;
! 	    cluster->angle.y += angleY;
! 	    cluster->angle.z += angleZ;
!         }
!         if(cluster->angle.x > MTH_FIXED( 180)) 
!             cluster->angle.x -= MTH_FIXED(360);
!         else
!         if(cluster->angle.x < MTH_FIXED(-180))
!             cluster->angle.x += MTH_FIXED(360);
!         if(cluster->angle.y > MTH_FIXED( 180))
!             cluster->angle.y -= MTH_FIXED(360);
!         else
!         if(cluster->angle.y < MTH_FIXED(-180))
!             cluster->angle.y += MTH_FIXED(360);
!         if(cluster->angle.z > MTH_FIXED( 180))
!             cluster->angle.z -= MTH_FIXED(360);
!         else
!         if(cluster->angle.z < MTH_FIXED(-180))
!             cluster->angle.z += MTH_FIXED(360);
!     }
!     if(point)
!         if(moveKind & 0x0001) {
! 	    cluster->point.x  = point->x;
! 	    cluster->point.y  = point->y;
! 	    cluster->point.z  = point->z;
!         } else       {
! 	    cluster->point.x += point->x;
! 	    cluster->point.y += point->y;
! 	    cluster->point.z += point->z;
!         }
! }
! 
! 
! /*****************************************************************************
!  *
!  * NAME:  SPR_3DrawModel()  - Set Specify Model
!  *
!  * PARAMETERS :
!  *
!  *     (1) SprCluster *rootCluster  - <i>  表示すべきモデルのルートクラスタ
!  *                                         テーブルのポインタ
!  *
!  * DESCRIPTION:
!  *
!  *     モデルの登録
!  *
!  * POSTCONDITIONS:
!  *
!  *     No exist.
!  *
!  * CAVEATS:
!  *
!  *****************************************************************************
!  */
! void
! SPR_3DrawModel(SprCluster *rootCluster)
! {
!     /** BEGIN ***************************************************************/
!     if(firstDrawFlag) {
! 	firstDrawFlag = 0;
! 	viewCoordMatrix();
! 	initDraw();
!     }
! 
!     transCluster(rootCluster);
! }
! 
! 
! /*****************************************************************************
!  *
!  * NAME:  SPR_3Flush()  - Draw End All Seted Cluster
!  *
!  * PARAMETERS :
!  *
!  *     No exist.
!  *
!  * DESCRIPTION:
!  *
!  *     登録された全モデルの描画終了処理
!  *
!  * POSTCONDITIONS:
!  *
!  *     No exist.
!  *
!  * CAVEATS:
!  *
!  *****************************************************************************
!  */
! void
! SPR_3Flush(void)
! {
!     /** BEGIN ***************************************************************/
!     if(doubleBufFlag) {
! 	cBuf = &dBuf[bufSW^1];
! 	transPolygons(cBuf, coord2D);
!     }
!     SPR_2FlushDrawPrty();
!     firstDrawFlag = 1;
! }
! 
! 
! /*****************************************************************************
!  *
!  * NAME:  SPR_3SetTexture()  - Set Texture Data
!  *
!  * PARAMETERS :
!  *
!  *     (1) SprTexture *texture  - <i>  テクスチャテーブルのポインタ
!  *
!  * DESCRIPTION:
!  *
!  *     テクスチャのセット
!  *
!  * POSTCONDITIONS:
!  *
!  *     No exist.
!  *
!  * CAVEATS:
!  *
!  *****************************************************************************
!  */
! void
! SPR_3SetTexture(SprTexture *texture)
! {
!     SprTexture   *wTex;
! 
!     /** BEGIN ***************************************************************/
!     for(wTex = texture; wTex->charNo != 0xffff; wTex++) {
! 	SPR_2SetChar(wTex->charNo, wTex->colorMode, wTex->color,
!                      wTex->width, wTex->height, wTex->charData);
! 	if(wTex->lookupTbl)
! 	    SPR_2SetLookupTbl(wTex->color, wTex->lookupTbl);
!     }
! }
! 
! 
! /*****************************************************************************
!  *
!  * NAME:  SPR_3ChangeTexColor()  - Change Texture Color
!  *
!  * PARAMETERS :
!  *
!  *     (1) Uint16      charNo    - <i>  キャラクタ番号
!  *     (2) Uint16      color     - <i>  カラーデータ（ｶﾗｰﾊﾞﾝｸorﾙｯｸｱｯﾌﾟﾃｰﾌﾞﾙNo）
!  *     (2) SprLookupTbl *lookupTbl   - <i>  ルックアップテーブルポインタ
!  *
!  * DESCRIPTION:
!  *
!  *     テクスチャカラーデータの変更
!  *
!  * POSTCONDITIONS:
!  *
!  *     No exist.
!  *
!  * CAVEATS:
!  *
!  *****************************************************************************
!  */
! void
! SPR_3ChangeTexColor(Uint16 charNo, Uint16 color, SprLookupTbl *lookupTbl)
! {
!     /** BEGIN ***************************************************************/
!     SpCharTbl[charNo].color = color;
!     if(lookupTbl)
!         SPR_2SetLookupTbl(color, lookupTbl);
! }
! 
! 
! /*****************************************************************************
!  *
!  * NAME:  SPR_3ClrTexture()  - Clear Texture Data
!  *
!  * PARAMETERS :
!  *
!  *     (1) SprTexture *texture  - <i>  テクスチャテーブルのポインタ
!  *
!  * DESCRIPTION:
!  *
!  *     テクスチャエリアの解放
!  *
!  * POSTCONDITIONS:
!  *
!  *     No exist.
!  *
!  * CAVEATS:
!  *
!  *****************************************************************************
!  */
! void
! SPR_3ClrTexture(SprTexture *texture)
! {
!     SprTexture  *wTex;
! 
!     /** BEGIN ***************************************************************/
!     for(wTex = texture; wTex->charNo != 0xffff; wTex++)
!         SPR_2ClrChar(wTex->charNo);
! }
! 
! 
! /*****************************************************************************
!  *
!  * NAME:  SPR_3SetZSortMinMax()  - Set Z Sort Min/Max Z Value
!  *
!  * PARAMETERS :
!  *
!  *     (1) Uint16   pZSortMode  - <i>  ＺソートＺ座標値の採用モード
!  *                                     ０＝浮動モード
!  *                                     １＝固定モード
!  *     (2) Fixed32  pZSortMin   - <i>  視点座標系ＺソートＺ最小値座標
!  *     (3) Fixed32  pZSortMax   - <i>  視点座標系ＺソートＺ最大値座標
!  *
!  *
!  * DESCRIPTION:
!  *
!  *     視点座標系Ｚソート範囲の最小・最大値をセット
!  *
!  * POSTCONDITIONS:
!  *
!  *     No exist.
!  *
!  * CAVEATS:
!  *
!  *****************************************************************************
!  */
! void
! SPR_3SetZSortMinMax(Uint16 pZSortMode, Fixed32 pZSortMin, Fixed32 pZSortMax)
! {
! 
!     /** BEGIN ***************************************************************/
!     zSortMode    = pZSortMode;
!     zSortZMin    = pZSortMin;
!     zSortZMax    = pZSortMax;
!     zSortZMinOrg = pZSortMin;
!     zSortZMaxOrg = pZSortMax;
! }
! 
! 
! /*****************************************************************************
!  *
!  * NAME:  SPR_3SetClipLevel()  - Set Cliping Level
!  *
!  * PARAMETERS :
!  *
!  *     (1) Uint16   pClipLevel  - <i>  クリッピングのレベル番号
!  *                                     ０＝クリッピングなし
!  *                                     １＝視点座標系のＺ範囲でクリップ
!  *                                         （座標変換後）
!  *                                     ２＝スクリーンに掛からないポリゴンの
!  *                                         削除（透視変換後）
!  *                                     ３＝フレームバッファの境界でクリップ
!  *                                         （透視変換後）
!  *     (2) Fixed32  pClipZMin   - <i>  視点座標系クリップＺ最小値座標
!  *     (3) Fixed32  pClipZMax   - <i>  視点座標系クリップＺ最大値座標
!  *
!  * DESCRIPTION:
!  *
!  *     クリッピングレベルのセット
!  *
!  * POSTCONDITIONS:
!  *
!  *     No exist.
!  *
!  * CAVEATS:
!  *
!  *****************************************************************************
!  */
! void
! SPR_3SetClipLevel(Uint16 pClipLevel, Fixed32 pClipZMin, Fixed32 pClipZMax)
! {
! 
!     /** BEGIN ***************************************************************/
!     clipLevel = pClipLevel;
!     clipZMin  = pClipZMin;
!     clipZMax  = pClipZMax;
! }
! 
! 
! /*****************************************************************************
!  *
!  * NAME:  SPR_3SetPixelCount()  - Set Screen Pixel Count
!  *
!  * PARAMETERS :
!  *
!  *     (1) Uint16   pixelCountX  - <i>  スクリーンＸの単位ピクセル数
!  *     (2) Uint16   pixelCountY  - <i>  スクリーンＹの単位ピクセル数
!  *
!  * DESCRIPTION:
!  *
!  *     スクリーンへの透視変換時のＸＹ各々 1.0 に対するスクリーンのピクセル数
!  *     を設定する。
!  *
!  * POSTCONDITIONS:
!  *
!  *     No exist.
!  *
!  * CAVEATS:
!  *
!  *****************************************************************************
!  */
! void SPR_3SetPixelCount(Uint16 pixelCountX, Uint16 pixelCountY)
! {
! 
!     /** BEGIN ***************************************************************/
!     unitPixel.x = MTH_IntToFixed(pixelCountX);
!     unitPixel.y = MTH_IntToFixed(pixelCountY);
! }
! 
! 
! /*****************************************************************************
!  *
!  * NAME:  SPR_3GetStatus()  - Get 3D Environment Value
!  *
!  * PARAMETERS :
!  *
!  *     (1) Spr3dStatus *spr3dStatus  - <o>  ３Ｄ環境データテーブルのポインタ
!  *
!  * DESCRIPTION:
!  *
!  *     現３Ｄ環境データの取得。
!  *
!  *
!  * POSTCONDITIONS:
!  *
!  *     No exist.
!  *
!  * CAVEATS:
!  *
!  *****************************************************************************
!  */
! void   SPR_3GetStatus(Spr3dStatus *spr3dStatus)
! {
!     /** BEGIN ***************************************************************/
!     spr3dStatus->lightAngle      = lightAngle;
!     spr3dStatus->viewCoordPoint  = viewCoordPoint;
!     spr3dStatus->viewPoint       = viewPoint;     
!     spr3dStatus->viewAngle       = viewAngle;     
!     spr3dStatus->viewAngleSeq    = viewAngleSeq;  
!     spr3dStatus->zSortMode       = zSortMode;     
!     spr3dStatus->zSortZMin       = zSortZMin;     
!     spr3dStatus->zSortZMax       = zSortZMax;     
!     spr3dStatus->clipZMin        = clipZMin;      
!     spr3dStatus->clipZMax        = clipZMax;      
!     spr3dStatus->clipLevel       = clipLevel;     
!     spr3dStatus->unitPixel       = unitPixel;
! }
! 
! 
! /*****************************************************************************
!  *
!  * NAME:  SPR_3SetSurfNormVect() - Compute Surface Normal Vector in the Object
!  *
!  * PARAMETERS :
!  *
!  *     (1)  SprObject3D  *obj  - <i/o>  ３Ｄオブジェクトのポインタ
!  *
!  * DESCRIPTION:
!  *
!  *     指定３Ｄオブジェクトの面の法線を計算し、セットする。
!  *
!  *
!  * POSTCONDITIONS:
!  *
!  *     No exist.
!  *
!  * CAVEATS:
!  *
!  *****************************************************************************
!  */
! void   SPR_3SetSurfNormVect(SprObject3D  *obj)
! {
!     Sint32      i, p1, p2, p3;
!     MthXyz      *wVertPoint;
!     SprSurface  *wSurface;
!     MthXyz      *wSurfNormal;
! 
!     /** BEGIN ***************************************************************/
!     wSurface    = obj->surface;
!     wVertPoint  = obj->vertPoint;
!     wSurfNormal = obj->surfaceNormal;
!     for(i = 0; i < obj->surfaceCount; i++) {
! 	p1 = wSurface->vertNo[0];
! 	p2 = wSurface->vertNo[1];
! 	p3 = wSurface->vertNo[2];
! 	MTH_ComputeNormVect(obj->surfNormK, &wVertPoint[p1], &wVertPoint[p2],
! 			                    &wVertPoint[p3], wSurfNormal);
! 	wSurface++;
! 	wSurfNormal++;
!     }
! }
! 
! 
! /*****************************************************************************
!  *
!  * NAME:  SPR_3SetDrawSpeed() - Set VDP1 Drawing Speed up Parameter
!  *
!  * PARAMETERS :
!  *
!  *     (1)  Sint32    hssFlag  - <i>  ハイスピードシュリンクフラグ
!  *                                    テクスチャポリゴンの描画モード
!  *                                    ０＝精度優先描画（デフォルト）
!  *                                    １＝速度優先描画
!  *     (2)  Sint32    eosFlag  - <i>  hss=1 で速度優先描画を指定した時の
!  *                                    元絵テクスチャのサンプリング座標
!  *                                    ０＝偶数座標をサンプリング（デフォルト）
!  *                                    １＝奇数座標をサンプリング
!  *     (3)  Sint32    pclpFlag - <i>  プリクリッピング有効・無効フラグ
!  *                                    ０＝有効（デフォルト）
!  *                                    １＝無効
!  *
!  *
!  * DESCRIPTION:
!  *
!  *     ＶＤＰ１の高速描画パラメータをセット
!  *
!  *
!  * POSTCONDITIONS:
!  *
!  *     No exist.
!  *
!  * CAVEATS:
!  *
!  *****************************************************************************
!  */
! void   SPR_3SetDrawSpeed(Sint32 hssFlag, Sint32 eosFlag, Sint32 pclpFlag)
! {
!     Sint32      i, p1, p2, p3;
!     MthXyz      *wVertPoint;
!     SprSurface  *wSurface;
!     MthXyz      *wSurfNormal;
! 
!     /** BEGIN ***************************************************************/
!     if(hssFlag) 
!        spriteDrawFlag  = HSS_ENABLE;
!     else
!        spriteDrawFlag  = 0;
! 
!     if(pclpFlag) {
!        spriteDrawFlag |= PCLP_ENABLE;
!        otherDrawFlag   = PCLP_ENABLE;
!     } else {
!        spriteDrawFlag &= ~PCLP_ENABLE;
!        otherDrawFlag   = 0;
!     }
! 
!     SPR_SetEosMode(eosFlag);
! }
! 
! 
! /*****************************************************************************
!  *
!  * NAME:  initDraw()  - Initial Draw Environment
!  *
!  * PARAMETERS :
!  *
!  *     No exist.
!  *
!  * DESCRIPTION:
!  *
!  *     ３Ｄ表示のテーブル初期化
!  *
!  *
!  * POSTCONDITIONS:
!  *
!  *     No exist.
!  *
!  * CAVEATS:
!  *
!  *****************************************************************************
!  */
! static void
! initDraw(void)
! {
!     Fixed32   ztMax;
!     Sint32    i;
! 
!     /** BEGIN ***************************************************************/
!     if(zSortMode) {
!         zSortBZMin    = zSortZMinOrg;
!         zSortBZMax    = zSortZMaxOrg;
!     } else        {
!         zSortBZMin    = zSortZMin;
!         zSortBZMax    = zSortZMax;
!     }
!     zSortZMin     = FIXED_MAX;
!     zSortZMax     = FIXED_MIN;
!     ztMax = zSortBZMax - zSortBZMin;
!     for(i=0; i<32; i++)
! 	if((ztMax<<=1) & 0x80000000) break;
!     zSftCnt = 17 - i + blkSftCnt;
!     if(zSftCnt < 0) zSftCnt = 0;
!     dbFirstFlag = 1;
!     bufSW       = 0;
!     if(Sp2OpenFlag) {
!         gourTblNo   = 0;
!         clipScrXMin = -SpLCoordX;
!         clipScrXMax = SpScreenX - SpLCoordX - 1;
!         clipScrYMin = -SpLCoordY;
!         clipScrYMax = SpScreenY - SpLCoordY - 1;
!         Sp2OpenFlag = 0;
!     }
! }
! 
! 
! /*****************************************************************************
!  *
!  * NAME:  drawPol()  - Draw 1 Polygon
!  *
!  * PARAMETERS :
!  *
!  *     (1) PolTbl  *polTbl          - <i>  ポリゴンテーブルのポインタ
!  *
!  * DESCRIPTION:
!  *
!  *     ポリゴンの描画
!  *
!  * POSTCONDITIONS:
!  *
!  *     No exist.
!  *
!  * CAVEATS:
!  *
!  *****************************************************************************
!  */
! static void
! drawPol(PolTbl *polTbl)
! {
!     Sint32     drawPrtyBlkNo;
!     Sint32     shadingKind, dispKind, drawMode, colOrTex, textCtrl;
!     Sint32     surfBright;
!     Sint32     mateKind, i;
!     XyInt      *xy;
!     SprGourTbl *gourTbl;
!     Sint32     z;
! 
!     /** BEGIN ***************************************************************/
!     dispKind    = polTbl->dispFlag & DISP_MASK;
!     shadingKind = polTbl->dispFlag & SHADING_MASK;
!     mateKind    = polTbl->drawMode & MATE_MASK;
!     drawMode    = polTbl->drawMode & DRAW_MODE_MASK;
!     surfBright  = polTbl->surfBright;
!     gourTbl     = &polTbl->gourTbl;
!     colOrTex    = polTbl->color;
!     xy          = polTbl->xy;
! 
!     if(mateKind == MATE_TEXTURE) {
!         textCtrl   = colOrTex & 0xc000;
!         textCtrl >>= 10;
!         colOrTex  &= 0x3fff;
!     }
! 
!     /* Ｚ値ブロックソートの最大最小値を得る */
!     if(polTbl->z < zSortZMin) zSortZMin = polTbl->z;
!     if(polTbl->z > zSortZMax) zSortZMax = polTbl->z;
!     if(polTbl->z > zSortBZMin) {
! 	drawPrtyBlkNo = (int)((polTbl->z - zSortBZMin) >> zSftCnt);
! 	if(drawPrtyBlkNo >= zSortBlkCnt)
! 	    drawPrtyBlkNo = zSortBlkCnt - 1;
!     } else
! 	drawPrtyBlkNo = 0;
! 
!     for(i=0; i<polTbl->polyCnt; i++) {
! 	if(shadingKind == NO_SHADING) {
!             if(mateKind == MATE_TEXTURE) {
! 		SPR_2DistSpr(drawPrtyBlkNo, textCtrl,
!                                   drawMode | spriteDrawFlag,
! 		   	          0xffff, colOrTex, xy, NO_GOUR);
!             } else {
!     	        if(dispKind == DISP_POLYGON) {
! 	            SPR_2Polygon(drawPrtyBlkNo,
! 	                      drawMode | otherDrawFlag, colOrTex, xy, NO_GOUR);
!                 } else {
! 	            SPR_2PolyLine(drawPrtyBlkNo,
! 	                      drawMode | otherDrawFlag, colOrTex, xy, NO_GOUR);
!                 }
!             }
!         } else
! 	if(shadingKind == FLAT_SHADING) {  /* Color Mode is Only RGB */
!             if(mateKind == MATE_TEXTURE) {
! 	        SPR_2SetGourTbl(gourTblNo, gourTbl);
!                 SPR_2DistSpr(drawPrtyBlkNo, textCtrl,
!                              drawMode | DRAW_GOURAU  | spriteDrawFlag,
!                               0xffff, colOrTex, xy, gourTblNo);
! 		gourTblNo++;
!             } else {
!                 if(dispKind == DISP_POLYGON) {
! 		    SPR_2Polygon(drawPrtyBlkNo, drawMode | otherDrawFlag,
!                                  surfBright, xy, NO_GOUR);
!                 } else {
!                     SPR_2PolyLine(drawPrtyBlkNo, drawMode | otherDrawFlag,
!                                   surfBright, xy, NO_GOUR);
! 	        }
! 	    }
!         } else
!         if(shadingKind == GOURAUD_SHADING) { /* Color Mode is Only RGB */
!             SPR_2SetGourTbl(gourTblNo, gourTbl);
!             if(mateKind == MATE_TEXTURE) {
!                 SPR_2DistSpr(drawPrtyBlkNo, textCtrl,
!                                  drawMode | DRAW_GOURAU | spriteDrawFlag,
! 		   	                0xffff, colOrTex, xy, gourTblNo);
!             } else     {
! 	        if(dispKind == DISP_POLYGON) {
!                     SPR_2Polygon(drawPrtyBlkNo,
!                                  drawMode | DRAW_GOURAU | otherDrawFlag,
! 						colOrTex, xy, gourTblNo);
!                 } else {
! 		    SPR_2PolyLine(drawPrtyBlkNo,
!                                   drawMode | DRAW_GOURAU | otherDrawFlag,
! 				          	colOrTex, xy, gourTblNo);
!                 }
!             }
! 	    gourTblNo++;
!         }
!         xy += 4;
!     }
! }
! 
! 
! /*****************************************************************************
!  *
!  * NAME:  transCluster()  - Transfer Cluster Coord
!  *
!  * PARAMETERS :
!  *
!  *     (1) SprCluster  *cluster  - <i>  ルートクラスタのポインタ
!  *
!  * DESCRIPTION:
!  *
!  *     クラスタ単位の隠面、座標変換処理
!  *
!  *
!  * POSTCONDITIONS:
!  *
!  *     No exist.
!  *
!  * CAVEATS:
!  *
!  *****************************************************************************
!  */
! static void
! transCluster(SprCluster *cluster)
! {
!     SprObject3D  *obj;
!     SprSurface   *wSurface;
!     MthXyz       *wVertPoint, *wSurfaceVert;
!     Fixed32      *wSurfPoint, *wVPoint;
!     Uint8        *wSurfBright;
!     Uint16       *wVertNo;
!     Sint32 	 i, j;
!     const static MthMatrix	unitMatrix
! 	= { MTH_FIXED(1.0), MTH_FIXED(0.0), MTH_FIXED(0.0), MTH_FIXED(0.0),
! 	    MTH_FIXED(0.0), MTH_FIXED(1.0), MTH_FIXED(0.0), MTH_FIXED(0.0),
! 	    MTH_FIXED(0.0), MTH_FIXED(0.0), MTH_FIXED(1.0), MTH_FIXED(0.0)};
! 
!     /** BEGIN ***************************************************************/
!     while(cluster) {
!         if(cluster->transStart)  cluster->transStart(cluster);
! 
!         MTH_PushMatrix(&worldMatrixTbl);
! 
! 	/* カレントマトリックスにクラスタの移動量マトリックスセット */
! 	MTH_MoveMatrix(&worldMatrixTbl, 
!                        cluster->point.x, cluster->point.y, cluster->point.z);
! 	switch(cluster->angleSeq) {
! 	    case ROT_SEQ_ZYX :
! 		 MTH_RotateMatrixX(&worldMatrixTbl, cluster->angle.x);
! 	         MTH_RotateMatrixY(&worldMatrixTbl, cluster->angle.y);
! 	         MTH_RotateMatrixZ(&worldMatrixTbl, cluster->angle.z);
!                  break;
!             case ROT_SEQ_ZXY :
! 		 MTH_RotateMatrixY(&worldMatrixTbl, cluster->angle.y);
! 	         MTH_RotateMatrixX(&worldMatrixTbl, cluster->angle.x);
! 	         MTH_RotateMatrixZ(&worldMatrixTbl, cluster->angle.z);
! 		 break;
!             case ROT_SEQ_YZX :
! 	         MTH_RotateMatrixX(&worldMatrixTbl, cluster->angle.x);
! 		 MTH_RotateMatrixZ(&worldMatrixTbl, cluster->angle.z);
! 		 MTH_RotateMatrixY(&worldMatrixTbl, cluster->angle.y);
!                  break;
!             case ROT_SEQ_YXZ :
! 	         MTH_RotateMatrixZ(&worldMatrixTbl, cluster->angle.z);
! 	         MTH_RotateMatrixX(&worldMatrixTbl, cluster->angle.x);
! 		 MTH_RotateMatrixY(&worldMatrixTbl, cluster->angle.y);
! 		 break;
! 	    case ROT_SEQ_XYZ :
! 		 MTH_RotateMatrixZ(&worldMatrixTbl, cluster->angle.z);
! 		 MTH_RotateMatrixY(&worldMatrixTbl, cluster->angle.y);
! 		 MTH_RotateMatrixX(&worldMatrixTbl, cluster->angle.x);
! 		 break;
! 	    case ROT_SEQ_XZY :
! 		 MTH_RotateMatrixY(&worldMatrixTbl, cluster->angle.y);
! 		 MTH_RotateMatrixZ(&worldMatrixTbl, cluster->angle.z);
! 		 MTH_RotateMatrixX(&worldMatrixTbl, cluster->angle.x);
! 		 break;
! 	}
! 
! 	obj = cluster->object;
! 	if(obj) {
! 	    if(postWorldDataFlag) {
! 	        MTH_MulMatrix(&viewMatrix, worldMatrixTbl.current,
! 						     &viewLight.viewMatrix);
! 	        memcpy(viewLight.worldMatrix, worldMatrixTbl.current,
! 						     sizeof(MthMatrix));
! 	    } else {
! 	        memcpy(&viewLight.viewMatrix, worldMatrixTbl.current,
! 						     sizeof(MthMatrix));
! 	    }
! 	}
! 
! 	while(obj) {
!             cBuf = &dBuf[bufSW];
!             cBuf->cluster = cluster;
!             cBuf->object  = obj;
!             if(obj->dispFlag & INBETWEEN_OBJECT) {
! 		memcpy(&viewLight.viewMatrix, &unitMatrix,sizeof(MthMatrix));
! 		SPR_3SetSurfNormVect(obj);
!             }
! 
! 	    if(obj->surfaceVert == 0) {
! 		/* 面の代表頂点テーブルを得る */
! 		wSurfPoint  = (Fixed32*)cBuf->coordView3D;
! 		wSurface    = obj->surface;
! 		wVertPoint  = obj->vertPoint;
! 
! 		for(i = 0; i < obj->surfaceCount; i++) {
! 		    j = wSurface->vertNo[0];
! 		    wVPoint = (Fixed32*)&wVertPoint[j];
! 		    *wSurfPoint++ = *wVPoint++;
! 		    *wSurfPoint++ = *wVPoint++;
! 		    *wSurfPoint++ = *wVPoint;
! 		    wSurface++;
! 		}
! 		wSurfaceVert = cBuf->coordView3D;
! 	    } else
! 		wSurfaceVert = obj->surfaceVert;
! 
! 	    /* 面法線テーブルから面輝度テーブルを得るためのパラメータセット */
! 	    polyTransParm.viewLight = &viewLight;
! 	    polyTransParm.surfCount = obj->surfaceCount;
! 	    polyTransParm.surfPoint = wSurfaceVert;
! 	    polyTransParm.surfNormal = obj->surfaceNormal;
! 	    polyTransParm.surfBright = cBuf->surfBright;
! 
! 	    /* 頂点データの視点座標変換後テーブルを得るためのパラメータセット*/
! 	    polyTransParm.transViewVertCount = obj->vertCount;
! 	    polyTransParm.transViewVertSrc = obj->vertPoint;
! 	    polyTransParm.transViewVertAns = cBuf->coordView3D;
! 
! 	    /* グーロー用頂点輝度テーブルを得るためのパラメータセット  */
! 	    if((obj->dispFlag & SHADING_MASK) == GOURAUD_SHADING) {
!                 if(obj->dispFlag & INBETWEEN_OBJECT) {
!   	            polyTransParm.gourVertCount = 0;
!   	            memcpy(cBuf->vertBright,obj->vertNormal,
!   	                                  obj->vertCount*sizeof(Sint32));
!                 } else {
! 	            polyTransParm.gourVertCount = obj->vertCount;
! 	            polyTransParm.vertNormal    = obj->vertNormal;
! 		    polyTransParm.vertBright    = cBuf->vertBright;
! 		}
!             } else
! 	        polyTransParm.gourVertCount = 0;
! 
! 	    /* 頂点データのワールド座標変換後テーブルを得るための
!                                                         パラメータセット*/
! 	    if(postWorldDataFlag) {
! 	        polyTransParm.transWorldVertCount = obj->vertCount;
! 	        polyTransParm.transWorldVertSrc   = obj->vertPoint;
! 	        polyTransParm.transWorldVertAns   = cBuf->coordWorld3D;
!             } else
! 	        polyTransParm.transWorldVertCount = 0;
! 
! 	    MTH_PolyDataTransExec(&polyTransParm);
! 
!             if(dbFirstFlag) {
! 		MTH_PolyDataTransCheck();
!                 if(cluster->transEnd)
!                     cluster->transEnd(cluster, obj, worldMatrixTbl.current,
!                                                          cBuf->coordWorld3D);
!             } else {
! 		/* ポリゴン描画コマンドの登録処理 */
!                 cBuf = &dBuf[bufSW^1];
! 		transPolygons(cBuf, coord2D);
! 		setInbetPolygons(cBuf);
! 		MTH_PolyDataTransCheck();
!                 if(cluster->transEnd) {
! 		    cBuf = &dBuf[bufSW];
!                     cluster->transEnd(cluster, obj, worldMatrixTbl.current,
!                                                          cBuf->coordWorld3D);
!                 }
!             }
! 
! 	    if(doubleBufFlag) {
! 		dbFirstFlag = 0;
!                 bufSW ^= 1;
! 	    } else {
!                 cBuf = &dBuf[bufSW];
! 		transPolygons(cBuf, coord2D);
!                 setInbetPolygons(cBuf);
!             }
!             
!             obj = obj->next;
! 
! 	}
! 
! 	/* 子クラスタの処理 */
! 	if(cluster->child) transCluster(cluster->child);
! 
! 	MTH_PopMatrix(&worldMatrixTbl);
!         cluster = cluster->next;
!     }
! }
! 
! 
! /*****************************************************************************
!  *
!  * NAME:  setInbetPolygons  - Set Inbetween Polygon Data to Inbet Object
!  *
!  * PARAMETERS :
!  *
!  *     (1) DoubleBufArea  *buf    - <i>  カレント座標変換バッファ
!  *
!  * DESCRIPTION:
!  *
!  *     ３Ｄオブジェクト間接続ポリゴン視点座標系頂点データの登録処理
!  *
!  *
!  * POSTCONDITIONS:
!  *
!  *     No exist.
!  *
!  * CAVEATS:
!  *
!  *****************************************************************************
!  */
! static void
! setInbetPolygons(DoubleBufArea *buf)
! {
!     Sint32       i;
!     SprObject3D  *inbetObj;
!     SprInbetInf  *wInbetInf;
!     MthXyz       *fromVertPoint;
!     Sint32       *fromVertBright;
!     Uint16       *fromVertNo;
!     MthXyz       *toVertPoint;
!     Sint32       *toVertBright;
!     Uint16       *toVertNo;
!     SprCluster   *cluster;
!     SprObject3D  *obj;
! 
!     /** BEGIN ***************************************************************/
!     cluster = buf->cluster;
!     obj     = buf->object;
! 
!     /*  ３Ｄオブジェクト間接続ポリゴン情報がある場合     */
!     if(cluster->inbetInf) {
! 	 wInbetInf = cluster->inbetInf;
! 	 while(wInbetInf) {
! 	     if(obj == wInbetInf->fromObj) {
! 		 fromVertPoint = cBuf->coordView3D;
! 		 fromVertNo    = wInbetInf->fromVertNo;
! 		 toVertPoint   = wInbetInf->toObj->vertPoint;
! 		 toVertNo      = wInbetInf->toVertNo;
! 		 for(i=0 ; i<wInbetInf->vertCount; i++)
! 		     toVertPoint[toVertNo[i]] = fromVertPoint[fromVertNo[i]];
! 		 toVertBright  = (Sint32*)wInbetInf->toObj->vertNormal;
! 		 if(toVertBright) {
! 		     fromVertBright = cBuf->vertBright;
! 		     for(i=0 ; i<wInbetInf->vertCount; i++)
! 		         toVertBright[toVertNo[i]] = 
! 		                              fromVertBright[fromVertNo[i]];
! 		 }
!                  break;
!              }
!              wInbetInf = wInbetInf->next;
!          }
!     }
! }
! 
! 
! /*****************************************************************************
!  *
!  * NAME:  clip2DLevel2()  - Clip 2D Level 2
!  *
!  * PARAMETERS :
!  *
!  *     (1) PolTbl  *polTbl  - <i>  ２Ｄポリゴンテーブル
!  *
!  * DESCRIPTION:
!  *
!  *     ポリゴンの２Ｄクリッピング処理
!  *     スクリーンに掛からないポリゴンの削除
!  *
!  *
!  * POSTCONDITIONS:
!  *
!  *     int   rtncd          - <o>  リターンコード
!  *                                 １＝描画しない
!  *                                 ０＝描画する
!  *
!  * CAVEATS:
!  *
!  *****************************************************************************
!  */
! static int
! clip2DLevel2(PolTbl *polTbl)
! {
!     Uint32   f1,f2;
!     XyInt    *xy,*xyb;
!     Sint32   i;
! 
!     /** BEGIN ***************************************************************/
!     f1 = 0;
!     xy = polTbl->xy;
!     if(xy->x < clipScrXMin) f1 |= 8;
!     if(xy->x > clipScrXMax) f1 |= 4;
!     if(xy->y < clipScrYMin) f1 |= 2;
!     if(xy->y > clipScrYMax) f1 |= 1;
!     for(i=0; i<4; i++) {
! 	xyb = xy;
! 	if(i == 3)
! 	    xy -= 3;
! 	else
! 	    xy++;
! 	f2 = 0;
! 	if(xy->x < clipScrXMin) f2 |= 8;
! 	if(xy->x > clipScrXMax) f2 |= 4;
! 	if(xy->y < clipScrYMin) f2 |= 2;
! 	if(xy->y > clipScrYMax) f2 |= 1;
! 	if(!(f1 & f2)) {
! 	    if(!(f1 | f2)) return 0;
! 	    if(!clipScrCheck(xyb,xy,8)) return 0;
! 	}
! 	f1 = f2;
!     }
!     return 1;
! }
! 
! /*****************************************************************************
!  *
!  * NAME:  clipScrCheck()  - Clip Screen Detail Check
!  *
!  * PARAMETERS :
!  *
!  *     (1) XyInt     *xy1   - <i>  ライン始点
!  *     (2) XyInt     *xy2   - <i>  ライン終点
!  *     (2) Sint32    chkCnt - <i>  チェックカウンタ
!  *
!  * DESCRIPTION:
!  *
!  *     ラインの中点がスクリーン内に入っているか２分割法によりリカーシブに
!  *     チェックする。
!  *
!  *
!  * POSTCONDITIONS:
!  *
!  *     Sint32   ret         - <o>  リターンコード
!  *                                 ０＝スクリーン内に入っている
!  *                                 １＝入っていない
!  *
!  * CAVEATS:
!  *
!  *****************************************************************************
!  */
! static Sint32
! clipScrCheck(XyInt *xy1, XyInt *xy2, Sint32 chkCnt)
! {
!    Sint32       ret;
!    XyInt     xym;
! 
!    if(chkCnt <= 1) return 1;
!    xym.x = (xy1->x + xy2->x) >> 1;
!    if(xym.x & 0x4000) xym.x |= 0x8000;
!    xym.y = (xy1->y + xy2->y) >> 1;
!    if(xym.y & 0x4000) xym.y |= 0x8000;
!    if((clipScrXMin <= xym.x) && (xym.x <= clipScrXMax) &&
!       (clipScrYMin <= xym.y) && (xym.y <= clipScrYMax)) return 0;
!    switch(outcodeScr(xy1, &xym)) {
!       case -1 : /* just in */
!           return 0;
!       case  0 : /* nead detail check */
!           ret = clipScrCheck(xy1, &xym, chkCnt-1);
!           break;
!       case  1 : /* just out */
! 	  ret = clipScrCheck(&xym, xy2, chkCnt-1);
! 	  break;
!    }
!    return ret;
! }
! 
! static 
! Sint32 outcodeScr(XyInt *xy1, XyInt *xy2)
! {
!    Uint32 f1, f2;
! 
!    f1 = f2 = 0;
!    if(xy1->x < clipScrXMin) f1 |= 8;
!    if(xy1->x > clipScrXMax) f1 |= 4;
!    if(xy1->y < clipScrYMin) f1 |= 2;
!    if(xy1->y > clipScrYMax) f1 |= 1;
!    if(xy2->x < clipScrXMin) f2 |= 8;
!    if(xy2->x > clipScrXMax) f2 |= 4;
!    if(xy2->y < clipScrYMin) f2 |= 2;
!    if(xy2->y > clipScrYMax) f2 |= 1;
!    if(f1 & f2)
!        return  1; /* just out          */
!    else
!    if(f1 | f2)
!        return  0; /* need detail check */
!    else
!        return -1; /* just in           */
! }
! 
! 
! /*****************************************************************************
!  *
!  * NAME:  clipFrmCheck()  - Clip Frame Buffer Detail Check
!  *
!  * PARAMETERS :
!  *
!  *     (1) XyInt  *xy1   - <i>  ライン始点
!  *     (2) XyInt  *xy2   - <i>  ライン終点
!  *     (2) Sint32    chkCnt - <i>  チェックカウンタ
!  *
!  * DESCRIPTION:
!  *
!  *     ラインの中点がフレームバッファ内に入っているか２分割法によりリカーシブに
!  *     チェックする。
!  *
!  *
!  * POSTCONDITIONS:
!  *
!  *     Sint32   ret         - <o>  リターンコード
!  *                                 ０＝スクリーン内に入っている
!  *                                 １＝入っていない
!  *
!  * CAVEATS:
!  *
!  *****************************************************************************
!  */
! static Sint32
! clipFrmCheck(XyInt *xy1, XyInt *xy2, Sint32 chkCnt)
! {
!    Sint32       ret;
!    XyInt     xym;
! 
!    if(chkCnt <= 1) return 1;
!    xym.x = (xy1->x + xy2->x) >> 1;
!    if(xym.x & 0x4000) xym.x |= 0x8000;
!    xym.y = (xy1->y + xy2->y) >> 1;
!    if(xym.y & 0x4000) xym.y |= 0x8000;
!    if((FRMBUF_MIN_X <= xym.x) && (xym.x <= FRMBUF_MAX_X) &&
!       (FRMBUF_MIN_Y <= xym.y) && (xym.y <= FRMBUF_MAX_Y)) return 0;
!    switch(outcodeFrm(xy1, &xym)) {
!       case -1 : /* just in */
!           return 0;
!       case  0 : /* nead detail check */
!           ret = clipFrmCheck(xy1, &xym, chkCnt-1);
! 	  break;
!       case  1 : /* just out */
!           ret = clipFrmCheck(&xym, xy2, chkCnt-1);
!           break;
!    }
!    return ret;
! }
! 
! static 
! Sint32 outcodeFrm(XyInt *xy1, XyInt *xy2)
! {
!    Uint32 f1, f2;
! 
!    f1 = f2 = 0;
!    if(xy1->x < FRMBUF_MIN_X) f1 |= 8;
!    if(xy1->x > FRMBUF_MAX_X) f1 |= 4;
!    if(xy1->y < FRMBUF_MIN_Y) f1 |= 2;
!    if(xy1->y > FRMBUF_MAX_Y) f1 |= 1;
!    if(xy2->x < FRMBUF_MIN_X) f2 |= 8;
!    if(xy2->x > FRMBUF_MAX_X) f2 |= 4;
!    if(xy2->y < FRMBUF_MIN_Y) f2 |= 2;
!    if(xy2->y > FRMBUF_MAX_Y) f2 |= 1;
!    if(f1 & f2)
!        return  1; /* just out          */
!    else
!    if(f1 | f2)
!        return  0; /* need detail check */
!    else
!        return -1; /* just in           */
! }
! 
! 
! /*****************************************************************************
!  *
!  * NAME:  clip2DLevel3()  - Clip 2D Level 3
!  *
!  * PARAMETERS :
!  *
!  *     (1) PolTbl  *polTbl  - <i>  ２Ｄポリゴンテーブル
!  *
!  * DESCRIPTION:
!  *
!  *     ポリゴンの２Ｄクリッピング処理
!  *     フレームバッファの境界でクリップ
!  *
!  *
!  * POSTCONDITIONS:
!  *
!  *     int   rtncd          - <o>  リターンコード
!  *                                 １＝描画しない
!  *                                 ０＝描画する
!  *
!  * CAVEATS:
!  *
!  *****************************************************************************
!  */
! static int
! clip2DLevel3(PolTbl *polTbl)
! {
!     Uint32   f1,f2;
!     Sint32   i,justInCnt;
!     XyInt *xy, *xyb;
! 
!     /** BEGIN ***************************************************************/
!     f1 = 0;
!     xy = polTbl->xy;
!     justInCnt = 0;
!     if(xy->x < FRMBUF_MIN_X) f1 |= 8;
!     if(xy->x > FRMBUF_MAX_X) f1 |= 4;
!     if(xy->y < FRMBUF_MIN_Y) f1 |= 2;
!     if(xy->y > FRMBUF_MAX_Y) f1 |= 1;
!     for(i=0; i<4; i++) {
! 	xyb = xy;
! 	if(i == 3)
! 	    xy -= 3;
! 	else
! 	    xy++;
! 	f2 = 0;
! 	if(xy->x < FRMBUF_MIN_X) f2 |= 8;
! 	if(xy->x > FRMBUF_MAX_X) f2 |= 4;
! 	if(xy->y < FRMBUF_MIN_Y) f2 |= 2;
! 	if(xy->y > FRMBUF_MAX_Y) f2 |= 1;
! 	if(!(f1 & f2)) { /* just in or between */
! 	    if(!(f1 | f2))
! 		justInCnt++;
! 	    else
! 		if(!clipFrmCheck(xyb,xy,8))  return clipFrame(polTbl);
! 	}
! 	f1 = f2;
!     }
!     if(justInCnt >=  4)  return 0;
!     return 1;
! }
! 
! /*****************************************************************************
!  *
!  * NAME:  clipFrame()  - Clip Frame Buffer
!  *
!  * PARAMETERS :
!  *
!  *     (1) PolTbl  *polTbl  - <i/o>  ２Ｄポリゴンテーブル
!  *
!  * DESCRIPTION:
!  *
!  *     ポリゴンをフレームバッファ境界でクリッピングし、複数のポリゴン
!  *     を生成する
!  *
!  *
!  * POSTCONDITIONS:
!  *
!  *     int   rtncd          - <o>  リターンコード
!  *                                 １＝描画しない
!  *                                 ０＝描画する
!  *
!  * CAVEATS:
!  *
!  *****************************************************************************
!  */
! static int
! clipFrame(PolTbl *polTbl)
! {
!     Sint32   i, j, in, out, visible;
!     XyInt *pxy, *qxy, *wxy, w1xy[16], w2xy[16], fxy, sxy;
! 
!     /** BEGIN ***************************************************************/
!     pxy = polTbl->xy;          /* 入力多角形 */
!     qxy = w1xy;                /* 出力多角形 */
!     in  = 4;                   /* 入力頂点数 */
!     for(i=0; i<4; i++) {       /* フレームバッファ境界辺についてのループ */
! 	out = 0;               /* 出力頂点数 */
! 	for(j=0; j<in; j++) {  /* 表示多角形の辺についてのループ */
! 	    if(j == 0) {       /* 多角形の最初の点の場合 */
! 		fxy.x = pxy->x;
! 		fxy.y = pxy->y;
! 	    } else     {
! 		if(frmCrossChk(i,&sxy,&pxy[j],&qxy[out]))  out++;
! 	    }
! 	    sxy.x = pxy[j].x;
! 	    sxy.y = pxy[j].y;
! 	    visible = 0;
! 	    /* フレームバッファ境界の内側にポイントが入っているか可視チェック*/
! 	    switch(i) {
! 		case 0 : /* フレームバッファ左辺とのチェック */
! 		     if(FRMBUF_MIN_X <= sxy.x)  visible = 1;
! 		     break;
! 		case 1 : /* フレームバッファ上辺とのチェック */
! 		     if(FRMBUF_MIN_Y <= sxy.y)  visible = 1;
! 		     break;
! 		case 2 : /* フレームバッファ右辺との交差チェック */
! 		     if(sxy.x <= FRMBUF_MAX_X)  visible = 1;
! 		     break;
! 		case 3 : /* フレームバッファ下辺との交差チェック */
! 		     if(sxy.y <= FRMBUF_MAX_Y)  visible = 1;
! 		     break;
! 	    }
! 	    if(visible) {
! 		qxy[out].x = sxy.x;
! 		qxy[out].y = sxy.y;
! 		out++;
! 	    }
! 	}
! 	if(out) {    /* 最終辺についての処理 */
! 	    if(frmCrossChk(i,&sxy,&fxy,&qxy[out]))  out++;  /* 1 = cross */
! 	}
! 	in = out;
! 	if(i == 0) {
! 	    pxy = qxy;
! 	    qxy = w2xy;
! 	} else {
! 	    wxy = pxy;
! 	    pxy = qxy;
! 	    qxy = wxy;
! 	}
!     }
!     if(out >= 4) {   /* 多角形ポリゴンを４角形ポリゴンに分解 */
! 	qxy = pxy;
! 	wxy = polTbl->xy;
! 	for(i=0; i<4; i++,wxy++,qxy++) {
! 	    wxy->x = qxy->x;
! 	    wxy->y = qxy->y;
! 	}
! 	out -= 4;
! 	j = 1;
! 	qxy--;
! 	while(out) {
! 	    if(out >= 2) {
! 	       wxy  ->x = pxy  ->x;
! 	       wxy++->y = pxy  ->y;
! 	       wxy  ->x = qxy  ->x;
! 	       wxy++->y = qxy++->y;
! 	       wxy  ->x = qxy  ->x;
! 	       wxy++->y = qxy++->y;
! 	       wxy  ->x = qxy  ->x;
! 	       wxy++->y = qxy  ->y;
! 	       out -= 2;
! 	    } else       {
! 	       wxy  ->x = pxy  ->x;
! 	       wxy++->y = pxy  ->y;
! 	       wxy  ->x = qxy  ->x;
! 	       wxy++->y = qxy++->y;
! 	       wxy  ->x = qxy  ->x;
! 	       wxy++->y = qxy  ->y;
! 	       wxy  ->x = pxy  ->x;
! 	       wxy++->y = pxy  ->y;
! 	       out -= 1;
! 	    }
! 	    j++;
! 	}
! 	polTbl->polyCnt = j;
! 	return 0;
!     } else
!     if(out >= 3) {
! 	qxy = pxy;
! 	wxy = polTbl->xy;
! 	for(i=0; i<3; i++,wxy++,qxy++) {
! 	    wxy->x = qxy->x;
! 	    wxy->y = qxy->y;
! 	}
! 	wxy->x = pxy->x;
! 	wxy->y = pxy->y;
! 	return 0;
!     } else
! 	return 1;
! }
! 
! 
! /*****************************************************************************
!  *
!  * NAME:  frmCrossChk()  - Frame Buffer Cross Check
!  *
!  * PARAMETERS :
!  *
!  *     (1) int       frmNo  - <i>  フレームバッファ境界の辺番号
!  *                                 ０＝左辺
!  *                                 １＝上辺
!  *                                 ２＝右辺
!  *                                 ３＝下辺
!  *     (2) XyInt  *p1    - <i>  ラインのスタートポイント
!  *     (2) XyInt  *p2    - <i>  ラインのエンドポイント
!  *     (2) XyInt  *cp    - <o>  境界とラインのクロスポイント
!  *
!  *
!  * DESCRIPTION:
!  *
!  *     指定フレームバッファの境界と指定ラインが交差しているかチェックし、
!  *     交差している場合その交点を返す
!  *
!  *
!  * POSTCONDITIONS:
!  *
!  *     int   rtncd          - <o>  リターンコード
!  *                                 １＝交差している
!  *                                 ０＝交差していない
!  *
!  * CAVEATS:
!  *
!  *****************************************************************************
!  */
! static int
! frmCrossChk(int frmNo, XyInt *p1, XyInt *p2, XyInt *cp)
! {
!     Sint32   w1, w2, w3;
! 
!     /** BEGIN ***************************************************************/
!     switch(frmNo) {
! 	case 0 : /* フレームバッファ左辺との交差チェック */
! 	     w1 = FRMBUF_MIN_X - p1->x;
! 	     w2 = FRMBUF_MIN_X - p2->x;
! 	     if((w1 * w2) >= 0)  return 0;
! 	     w3 = p2->x - p1->x;
! 	     if(w3 == 0) return 0;
! 	     cp->x = FRMBUF_MIN_X;
! 	     cp->y = p1->y + ((Sint32)(p2->y - p1->y)) * w1 / w3;
!           /* if(cp->y < FRMBUF_MIN_Y) cp->y = FRMBUF_MIN_Y; else
!              if(cp->y > FRMBUF_MAX_Y) cp->y = FRMBUF_MAX_Y; */
! 	     break;
! 	case 1 : /* フレームバッファ上辺との交差チェック */
! 	     w1 = FRMBUF_MIN_Y - p1->y;
! 	     w2 = FRMBUF_MIN_Y - p2->y;
! 	     if((w1 * w2) >= 0)  return 0;
! 	     w3 = p2->y - p1->y;
! 	     if(w3 == 0) return 0;
! 	     cp->x = p1->x + ((Sint32)(p2->x - p1->x)) * w1 / w3;
! 	     cp->y = FRMBUF_MIN_Y;
!           /* if(cp->x < FRMBUF_MIN_X) cp->x = FRMBUF_MIN_X; else
!              if(cp->x > FRMBUF_MAX_X) cp->x = FRMBUF_MAX_X; */
! 	     break;
! 	case 2 : /* フレームバッファ右辺との交差チェック */
! 	     w1 = FRMBUF_MAX_X - p1->x;
! 	     w2 = FRMBUF_MAX_X - p2->x;
! 	     if((w1 * w2) >= 0)  return 0;
! 	     w3 = p2->x - p1->x;
! 	     if(w3 == 0) return 0;
! 	     cp->x = FRMBUF_MAX_X;
! 	     cp->y = p1->y + ((Sint32)(p2->y - p1->y)) * w1 / w3;
!           /* if(cp->y < FRMBUF_MIN_Y) cp->y = FRMBUF_MIN_Y; else
!              if(cp->y > FRMBUF_MAX_Y) cp->y = FRMBUF_MAX_Y; */
! 	     break;
! 	case 3 : /* フレームバッファ下辺との交差チェック */
! 	     w1 = FRMBUF_MAX_Y - p1->y;
! 	     w2 = FRMBUF_MAX_Y - p2->y;
! 	     if((w1 * w2) >= 0)  return 0;
! 	     w3 = p2->y - p1->y;
! 	     if(w3 == 0) return 0;
! 	     cp->x = p1->x + ((Sint32)(p2->x - p1->x)) * w1 / w3;
! 	     cp->y = FRMBUF_MAX_Y;
!           /* if(cp->x < FRMBUF_MIN_X) cp->x = FRMBUF_MIN_X; else
!              if(cp->x > FRMBUF_MAX_X) cp->x = FRMBUF_MAX_X; */
! 	     break;
!     }
!     return 1;
! }
! 
! 
! /*****************************************************************************
!  *
!  * NAME:  transPolygons  - Set Polygon Data to polTbl
!  *
!  * PARAMETERS :
!  *
!  *     (1) DoubleBufArea  *buf    - <i>  カレント座標変換バッファ
!  *     (12 XyInt          *vert2d - <O>  ２Ｄ座標保存ワークエリア
!  *
!  * DESCRIPTION:
!  *
!  *     ポリゴン描画コマンドの登録処理
!  *
!  *
!  * POSTCONDITIONS:
!  *
!  *     No exist.
!  *
!  * CAVEATS:
!  *
!  *****************************************************************************
!  */
! static void
! transPolygons(DoubleBufArea *buf, XyInt *vert2d)
! {
!     Sint32     i, j;
!     Sint32     shadingKind, mateKind, bothFace, dispFlag, sBright;
!     Uint32     zSortKind;
!     Sint32     *wSurfBright, *vertBright, l;
!     SprSurface *wSurface;
!     SprObject3D *obj;
!     PolTbl     polTbl;
!     Uint16     *gour, w;
!     Uint16     *wVertNo;
!     Uint16     *shadingTbl;
!     XyInt      *wxy;
!     MthXyz     xyz[4], *wxyz, *coordView3D;
!     Fixed32    zMax, *wFix1, *wFix2;
! 
!     static Uint16    grayCode[32] = {
!         RGB16_COLOR( 0, 0, 0), RGB16_COLOR( 1, 1, 1),
!         RGB16_COLOR( 2, 2, 2), RGB16_COLOR( 3, 3, 3),
!         RGB16_COLOR( 4, 4, 4), RGB16_COLOR( 5, 5, 5),
!         RGB16_COLOR( 6, 6, 6), RGB16_COLOR( 7, 7, 7),
!         RGB16_COLOR( 8, 8, 8), RGB16_COLOR( 9, 9, 9),
!         RGB16_COLOR(10,10,10), RGB16_COLOR(11,11,11),
!         RGB16_COLOR(12,12,12), RGB16_COLOR(13,13,13),
!         RGB16_COLOR(14,14,14), RGB16_COLOR(15,15,15),
!         RGB16_COLOR(16,16,16), RGB16_COLOR(17,17,17),
!         RGB16_COLOR(18,18,18), RGB16_COLOR(19,19,19),
!         RGB16_COLOR(20,20,20), RGB16_COLOR(21,21,21),
!         RGB16_COLOR(22,22,22), RGB16_COLOR(23,23,23),
!         RGB16_COLOR(24,24,24), RGB16_COLOR(25,25,25),
!         RGB16_COLOR(26,26,26), RGB16_COLOR(27,27,27),
!         RGB16_COLOR(28,28,28), RGB16_COLOR(29,29,29),
!         RGB16_COLOR(30,30,30), RGB16_COLOR(31,31,31)
!     };
! 
!     static Uint16    texGrayCode[32] = {
!         RGB16_COLOR( 8, 8, 8), RGB16_COLOR( 8, 8, 8),
!         RGB16_COLOR( 9, 9, 9), RGB16_COLOR( 9, 9, 9),
!         RGB16_COLOR(10,10,10), RGB16_COLOR(10,10,10),
!         RGB16_COLOR(11,11,11), RGB16_COLOR(11,11,11),
!         RGB16_COLOR(12,12,12), RGB16_COLOR(12,12,12),
!         RGB16_COLOR(13,13,13), RGB16_COLOR(13,13,13),
!         RGB16_COLOR(14,14,14), RGB16_COLOR(14,14,14),
!         RGB16_COLOR(15,15,15), RGB16_COLOR(15,15,15),
!         RGB16_COLOR(16,16,16), RGB16_COLOR(16,16,16),
!         RGB16_COLOR(17,17,17), RGB16_COLOR(17,17,17),
!         RGB16_COLOR(18,18,18), RGB16_COLOR(18,18,18),
!         RGB16_COLOR(19,19,19), RGB16_COLOR(19,19,19),
!         RGB16_COLOR(20,20,20), RGB16_COLOR(20,20,20),
!         RGB16_COLOR(21,21,21), RGB16_COLOR(21,21,21),
!         RGB16_COLOR(22,22,22), RGB16_COLOR(22,22,22),
!         RGB16_COLOR(23,23,23), RGB16_COLOR(23,23,23),
!     };
! 
!     /** BEGIN ***************************************************************/
!     obj         = buf->object;
!     coordView3D = buf->coordView3D;
!     vertBright  = buf->vertBright;
!     wSurfBright = buf->surfBright;
!     wSurface    = obj->surface;
!     shadingKind = obj->dispFlag & SHADING_MASK;
!     bothFace    = obj->dispFlag & BOTH_FACE;
!     wxy         = vert2d;
!     for(i=0; i < obj->vertCount; i++) {
! 	wxy->x = 0x7fff;
! 	wxy++;
!     }
! 
!     for(i = 0; i < obj->surfaceCount; i++, wSurfBright++, wSurface++) {
! 	sBright = *wSurfBright & 0xff;
! 	dispFlag = 1;
! 	if(*wSurfBright & 0x80000000)
! 	    if(bothFace) {
! 	       sBright = 31 - sBright;
! 	       dispFlag = 2;
! 	    } else
! 	       dispFlag = 0;
! 
!  /* *(Sint32*)0x6060008 += 1; */ /* ### */
! 	if(dispFlag) {
!  /* *(Sint32*)0x606000c += 1; */ /* ### */
! 	    /* 頂点データの取り出し */
! 	    wVertNo  = wSurface->vertNo;
! 	    wFix1 = (Fixed32*)xyz;
! 	    for(j = 0; j < 4; j++, wVertNo++) {
! 		wFix2 = (Fixed32*)&coordView3D[*wVertNo];
! 		*wFix1++ = *wFix2++;   /* X */
! 		*wFix1++ = *wFix2++;   /* Y */
! 		*wFix1++ = *wFix2;     /* Z */
! 	    }
! 
! 	    /* 代表Ｚ値による３Ｄクリッピング */
! 	    zMax = MAX(MAX(MAX(xyz[0].z,xyz[1].z),xyz[2].z),xyz[3].z);
! 	    if(clipLevel > 0)
! 		if((zMax < clipZMin) || (zMax > clipZMax)) continue;
! 
! 	    /* 代表Ｚ値の取り出し */
! 	    zSortKind = wSurface->drawMode & ZSORT_MASK;
! 	    if(zSortKind == ZSORT_MIN)
! 		polTbl.z = MIN(MIN(MIN(xyz[0].z,xyz[1].z),xyz[2].z),xyz[3].z);
! 	    else
! 	    if(zSortKind == ZSORT_MAX)
! 		polTbl.z = zMax;
! 	    else
! 		polTbl.z = MTH_Mul(xyz[0].z+xyz[1].z+xyz[2].z+xyz[3].z,
! 		                   MTH_FIXED(0.25));
! 
! 	    /* 透視変換 */
! 	    wVertNo = wSurface->vertNo;
! 	    wxyz    = xyz;
! 	    wxy     = polTbl.xy;
! 	    for(j = 0; j < 4; j++, wVertNo++) {
! 		if(vert2d[*wVertNo].x != 0x7fff) {
! 		    wxy->x = vert2d[*wVertNo].x;
! 		    wxy->y = vert2d[*wVertNo].y;
! 		} else {
! 		    MTH_Pers2D(wxyz, &unitPixel, wxy);
! 		    coord2D[*wVertNo].x = wxy->x;
! 		    coord2D[*wVertNo].y = wxy->y;
! 		}
! 		wxyz++;
! 		wxy++;
! 	    }
! 
! 	    /* ２Ｄクリッピング */
! 	    polTbl.polyCnt = 1;
! 	    if(clipLevel == 2) {
! 		if(clip2DLevel2(&polTbl)) continue;
! 	    } else
! 	    if(clipLevel == 3) {
! 		if(clip2DLevel3(&polTbl)) continue;
! 	    }
! 
! 	    if(shadingKind == GOURAUD_SHADING) {
! 		gour    = (Uint16*)&polTbl.gourTbl;
! 		wVertNo = wSurface->vertNo;
! 		if(obj->shdIdxTbl)
! 		    shadingTbl = obj->shdIdxTbl[0];
! 		else
! 		    shadingTbl = grayCode;
!                 if(dispFlag == 1) {
! 		    *gour++ = shadingTbl[vertBright[*wVertNo++]];
! 		    *gour++ = shadingTbl[vertBright[*wVertNo++]];
! 		    *gour++ = shadingTbl[vertBright[*wVertNo++]];
! 		    *gour   = shadingTbl[vertBright[*wVertNo  ]];
!                 } else {
! 		    *gour++ = shadingTbl[31 - vertBright[*wVertNo++]];
! 		    *gour++ = shadingTbl[31 - vertBright[*wVertNo++]];
! 		    *gour++ = shadingTbl[31 - vertBright[*wVertNo++]];
! 		    *gour   = shadingTbl[31 - vertBright[*wVertNo  ]];
!                 }
! 	    }
! 
! 	    polTbl.dispFlag = obj->dispFlag;
!             mateKind = wSurface->drawMode & MATE_MASK;
! 	    if(shadingKind == FLAT_SHADING) {
! 		if(mateKind == MATE_SHADING_TBL) {
! 		    shadingTbl = obj->shdIdxTbl[wSurface->color];
! 		    polTbl.surfBright = shadingTbl[sBright];
! 		} else
! 		if(mateKind == MATE_TEXTURE) {
! 		    gour    = (Uint16*)&polTbl.gourTbl;
! 		    if(obj->shdIdxTbl) {
! 		        shadingTbl = obj->shdIdxTbl[0];
! 		        w = shadingTbl[sBright];
! 		    } else
! 		        w = texGrayCode[sBright];
! 		    *gour++ = w;
! 		    *gour++ = w;
! 		    *gour++ = w;
! 		    *gour   = w;
! 		} else {
! 		    polTbl.surfBright =
! 			    SPR_3GetShdColor(wSurface->color,sBright);
! 		}
! 	    }
! 	    polTbl.drawMode   = wSurface->drawMode;
! 	    polTbl.color      = wSurface->color;
! 
! 	    drawPol(&polTbl);
! 	}
!     }
! }
! 
! 
! /*****************************************************************************
!  *
!  * NAME:  viewCoordMatrix()  - set View Coord Convert Matrix To
!  *                                                    current matrix
!  *
!  * PARAMETERS :
!  *
!  * 　　なし
!  *
!  *
!  * DESCRIPTION:
!  *
!  *     カレントマトリックスに視点座標系への変換マトリックスをセット
!  *
!  *
!  * POSTCONDITIONS:
!  *
!  *     No exist.
!  *
!  * CAVEATS:
!  *
!  *****************************************************************************
! */
! static void viewCoordMatrix(void)
! {
!     MTH_InitialMatrix(&viewMatrixTbl, 1, &viewMatrix);
!     MTH_ReverseZ(&viewMatrixTbl);
!     MTH_MoveMatrix(&viewMatrixTbl, viewCoordPoint.x,
! 				   viewCoordPoint.y,
! 				   viewCoordPoint.z);
!     switch(viewAngleSeq) {
!         case ROT_SEQ_ZYX :
!    	     MTH_RotateMatrixX(&viewMatrixTbl, -viewAngle.x);
! 	     MTH_RotateMatrixY(&viewMatrixTbl, -viewAngle.y);
! 	     MTH_RotateMatrixZ(&viewMatrixTbl,  viewAngle.z);
! 	     break;
!         case ROT_SEQ_ZXY :
! 	     MTH_RotateMatrixY(&viewMatrixTbl, -viewAngle.y);
! 	     MTH_RotateMatrixX(&viewMatrixTbl, -viewAngle.x);
! 	     MTH_RotateMatrixZ(&viewMatrixTbl,  viewAngle.z);
! 	     break;
!         case ROT_SEQ_YZX :
! 	     MTH_RotateMatrixX(&viewMatrixTbl, -viewAngle.x);
! 	     MTH_RotateMatrixZ(&viewMatrixTbl,  viewAngle.z);
! 	     MTH_RotateMatrixY(&viewMatrixTbl, -viewAngle.y);
! 	     break;
!         case ROT_SEQ_YXZ :
!              MTH_RotateMatrixZ(&viewMatrixTbl,  viewAngle.z);
! 	     MTH_RotateMatrixX(&viewMatrixTbl, -viewAngle.x);
! 	     MTH_RotateMatrixY(&viewMatrixTbl, -viewAngle.y);
! 	     break;
!         case ROT_SEQ_XYZ :
!   	     MTH_RotateMatrixZ(&viewMatrixTbl,  viewAngle.z);
! 	     MTH_RotateMatrixY(&viewMatrixTbl, -viewAngle.y);
! 	     MTH_RotateMatrixX(&viewMatrixTbl, -viewAngle.x);
! 	     break;
!         case ROT_SEQ_XZY :
! 	     MTH_RotateMatrixY(&viewMatrixTbl, -viewAngle.y);
! 	     MTH_RotateMatrixZ(&viewMatrixTbl,  viewAngle.z);
! 	     MTH_RotateMatrixX(&viewMatrixTbl, -viewAngle.x);
! 	     break;
!     }
!     MTH_MoveMatrix(&viewMatrixTbl, -viewPoint.x, -viewPoint.y, -viewPoint.z);
!     MTH_NormalTrans(&viewMatrix, &worldLightVector, &viewLight.lightVector);
!     if(postWorldDataFlag) {
!         MTH_ClearMatrix(&worldMatrixTbl);
!     } else {
! 	memcpy(worldMatrixTbl.current, &viewMatrix, sizeof(MthMatrix));
!     }
! 
! }
! 
! 
! /*****************************************************************************
!  *
!  * NAME:  lightAngle()  -
!  *
!  * PARAMETERS :
!  *
!  * 　　MthXyz *lightAngle
!  *
!  *
!  * DESCRIPTION:
!  *
!  *     光源のアングルを設定する
!  *
!  *
!  * POSTCONDITIONS:
!  *
!  *     No exist.
!  *
!  * CAVEATS:
!  *
!  *****************************************************************************
! */
! static void setLightAngle(void)
! {
!     MTH_InitialMatrix(&lightMatrixTbl, 1, &lightMatrix);
!     MTH_RotateMatrixZ(&lightMatrixTbl, lightAngle.z);
!     MTH_RotateMatrixY(&lightMatrixTbl, lightAngle.y);
!     MTH_RotateMatrixX(&lightMatrixTbl, lightAngle.x);
!     MTH_NormalTrans(&lightMatrix, &orgLightVect, &worldLightVector);
! }
! 
! /*  end of file */
! 
\ No newline at end of file
--- 1,2187 ----
! /*----------------------------------------------------------------------------
!  *  spr_3c.c -- SPR ライブラリ 3C モジュール
!  *  Copyright(c) 1994 SEGA
!  *  Written by H.E on 1994-02-15 Ver.0.80
!  *  Updated by H.E on 1994-07-25 Ver.1.00
!  *
!  *  このライブラリはスプライト３Ｄ表示処理モジュールで、以下のルーチンを含む。
!  *
!  *  SPR_3Initial            -  ３Ｄスプライト表示の初期化
!  *  SPR_3SetLight           -  光源ベクタのセット
!  *  SPR_3SetView            -  視点のセット
!  *  SPR_3CallAllCluster     -  全クラスタに対するファンクションコール
!  *  SPR_3MoveCluster        -  クラスタの移動
!  *  SPR_3DrawModel          -  モデルの登録
!  *  SPR_3Flush              -  モデルの描画
!  *  SPR_3SetTexture         -  テクスチャのセット
!  *  SPR_3ChangeTexColor     -  テクスチャカラーデータの変更
!  *  SPR_3ClrTexture         -  テクスチャエリアの解放
!  *  SPR_3SetClipLevel       -  クリッピングレベルのセット
!  *  SPR_3SetZSortMinMax     -  視点座標系Ｚソート範囲の最小・最大値をセット
!  *  SPR_3SetPixelCount      -  単位ピクセル数のセット
!  *  SPR_3SetTransPostRtn    -  座標変換結果通知ルーチンのセット
!  *  SPR_3GetStatus          -  現３Ｄ環境データの取得
!  *  SPR_3SetSurfNormVect    -  ３Ｄオブジェクトの面法線を計算しセット
!  *  SPR_3SetDrawSpeed       -  ＶＤＰ１の高速描画パラメータをセット
!  *
!  *  このライブラリを使用するには次のインクルードファイルとワークエリアを定義す
!  *  る必要がある。
!  *
!  *   #include "sega_scl.h"
!  *   #define  _SPR3_
!  *   #include "sega_spr.h"
!  *
!  *   #define CommandMax    100          // 最大コマンド数
!  *   #define GourTblMax    100          // 最大グーローテーブル数
!  *   #define LookupTblMax  100          // 最大ルックアップテーブル数
!  *   #define CharMax       100          // 最大キャラクタ数
!  *   #define DrawPrtyMax   256          // 最大プライオリティブロック数
!  *   SPR_2DefineWork(work2D,
!  *                CommandMax, GourTblMax, LookupTblMax, CharMax, DrawPrtyMax)
!  *                                      // ２Ｄワークエリア定義
!  *
!  *   #define ObjSurfMax     16          // ３Ｄオブジェクトの最大面数
!  *   #define ObjVertMax     16          // ３Ｄオブジェクトの最大頂点数
!  *   SPR_3DefineWork(work3D, ObjSurfMax, ObjVertMax)
!  *                                      // ３Ｄワークエリア定義
!  *
!  *----------------------------------------------------------------------------
!  */
! 
! /*
!  * USER SUPPLIED INCLUDE FILES
!  */
! 
! #include <string.h>
! 
! #define  _SPR3_
! #include "sega_spr.h"
! 
! #ifdef _SH
! #include <machine.h>
! #endif
! 
! /*
!  * GLOBAL DEFINES/MACROS DEFINES
!  */
! #define   SCREEN_W_SIZE     256
! #define   SCREEN_H_SIZE     256
! 
! #define   FRMBUF_MIN_X     -1000
! #define   FRMBUF_MAX_X      1000
! #define   FRMBUF_MIN_Y     -1000
! #define   FRMBUF_MAX_Y      1000
! 
! #define   FIXED_MIN        0x80000000
! #define   FIXED_MAX        0x7fffffff
! #define   CLIP_MIN_Z       FIXED_MIN
! #define   CLIP_MAX_Z       MTH_FIXED(-0.005)
! #define   ZSORT_MIN_Z      MTH_FIXED(-10.0)
! #define   ZSORT_MAX_Z      MTH_FIXED(0)
! 
! #define	WORLD_MATRIX_STACK_SIZE	32
! 
! /*
!  * DATA TYPE DECLARATIONS
!  */
! typedef struct PolTbl  PolTbl;
! struct PolTbl {
!     Uint16     dispFlag;        /* 表示フラグ                                */
!     Uint16     surfBright;      /* 面輝度                                    */
!     Uint16     drawMode;        /* 描画モード                                */
!     Uint16     color;           /* カラーデータ                              */
!     Uint16     polyCnt;         /* ２Ｄポリゴン数                            */
!     XyInt      xy[16];          /* ２Ｄポリゴン座標                          */
!     SprGourTbl gourTbl;         /* グーローテーブル                          */
!     Fixed32    z;               /* 描画ポリゴンＺ                            */
! };
! typedef struct DoubleBufArea  DoubleBufArea;
! struct DoubleBufArea {
!     SprCluster  *cluster;       /* クラスタ                                  */
!     SprObject3D *object;        /* ３Ｄオブジェクト                          */
!     Sint32      *surfBright;    /* 面輝度テーブル                            */
!     Sint32      *vertBright;    /* 頂点輝度テーブル                          */
!     MthXyz      *coordView3D;   /* ３Ｄ視点座標変換後テーブル                */
!     MthXyz      *coordWorld3D;  /* ３Ｄワールド座標変換後テーブル            */
! };
! 
! /*
!  * GLOBAL DECLARATIONS
!  */
! extern Sint32      Sp2OpenFlag;             /* Open Command Exec Flag        */
! extern SprCharTbl *SpCharTbl;               /* Character Table Pointer       */
! extern Sint32      SpCharMax;               /* Character Table Entry Count   */
! extern Sint32      SpDrawPrtyBlkMax;        /* Draw Priority Block Max Count */
! 
! /*
!  * STATIC DECLARATIONS
!  */
! static MthMatrix    viewMatrix;
! static MthMatrix    lightMatrix;
! static MthMatrix    worldMatrix [WORLD_MATRIX_STACK_SIZE];
! static MthMatrixTbl viewMatrixTbl;
! static MthMatrixTbl lightMatrixTbl;
! static MthMatrixTbl worldMatrixTbl;
! 
! static MthViewLight      viewLight;
! static MthPolyTransParm  polyTransParm;
! 
! static DoubleBufArea dBuf[2];      /* 座標変換ダブルバッファエリア管理       */
! static DoubleBufArea *cBuf;        /* カレント座標変換バッファ               */
! static Sint32    doubleBufFlag;    /* ダブルバッファ有りフラグ               */
! static Sint32    bufSW;            /* カレントダブルバッファＳＷ  0 or 1     */
! static Sint32    dbFirstFlag;      /* ダブルバッファ操作ファーストフラグ     */
! static Sint32    firstDrawFlag;    /* フラッシュ後最初のモデル描画フラグ     */
! static MthXy     unitPixel;        /* X,Y 1.0 に対するスクリーンのピクセル数 */
! static MthXyz    lightAngle;       /* 光源アングル                           */
! static MthXyz	 worldLightVector; /* ワールド座標系での光源ベクトル         */
! static MthXyz    viewCoordPoint;   /* 視点座標系内の視点位置                 */
! static MthXyz    viewPoint;        /* 視点座標                               */
! static MthXyz    viewAngle;        /* 視点アングル                           */
! static Sint32	 viewAngleSeq;     /* 視点アングル回転操作                   */
! static XyInt     *coord2D;         /* ２Ｄ透視変換後テーブル                 */
! static Uint8     *coord2DFlag;     /* ２Ｄ透視変換処理フラグテーブル         */
! static Sint32    gourTblNo;        /* フラッシュ単位グーローテーブルカウンタ */
! static Fixed32   zSortZMinOrg;     /* フラッシュ単位元Ｚ座標最小値           */
! static Fixed32   zSortZMaxOrg;     /* フラッシュ単位元Ｚ座標最大値           */
! static Fixed32   zSortZMin;        /* フラッシュ単位現Ｚ座標最小値           */
! static Fixed32   zSortZMax;        /* フラッシュ単位現Ｚ座標最大値           */
! static Fixed32   zSortBZMin;       /* フラッシュ単位前Ｚ座標最小値           */
! static Fixed32   zSortBZMax;       /* フラッシュ単位前Ｚ座標最大値           */
! static Uint16    zSortBlkCnt;      /* Ｚソートブロック数                     */
! static Sint32    zSortMode;        /* ＺソートＺ座標値の採用モード           */
! static int       blkSftCnt;        /* Ｚソートブロックハッシュ用シフト数     */
! static int       zSftCnt;          /* ＺソートＺシフト数                     */
! static Sint16    clipScrXMin;      /* スクリーン境界Ｘ最小値座標             */
! static Sint16    clipScrXMax;      /* スクリーン境界Ｘ最大値座標             */
! static Sint16    clipScrYMin;      /* スクリーン境界Ｙ最小値座標             */
! static Sint16    clipScrYMax;      /* スクリーン境界Ｙ最大値座標             */
! static Fixed32   clipZMin;         /* 視点座標系クリップＺ最小値座標         */
! static Fixed32   clipZMax;         /* 視点座標系クリップＺ最大値座標         */
! static Sint32    clipLevel;        /* クリッピングレベル                     */
! 				   /*   ０＝クリッピングなし                 */
! 				   /*   １＝視点座標系のＺ範囲でクリップ     */
!                                    /*       （座標変換後）                   */
!                                    /*   ２＝スクリーンに掛からないポリゴンの */
! 				   /*       削除（透視変換後）               */
!                                    /*   ３＝フレームバッファの境界でクリップ */
!                                    /*       （透視変換後）                   */
! static Uint16   postWorldDataFlag; /* ワールド座標通知要フラグ               */
! static Sint32   spriteDrawFlag;    /* 変形スプライト描画フラグ               */
! static Sint32   otherDrawFlag;     /* その他ポリゴン描画フラグ               */
! 
! static	MthXyz	orgLightVect =
! 	    { MTH_FIXED(0.0), MTH_FIXED(0.0), MTH_FIXED(-1.0)};
! 
! 
! static void   initDraw(void);
! static void   drawPol(PolTbl *polTbl);
! static void   transCluster(SprCluster *cluster);
! static void   setInbetPolygons(DoubleBufArea *buf);
! static int    clip2DLevel2(PolTbl *polTbl);
! static Sint32 clipScrCheck(XyInt *xy1, XyInt *xy2, Sint32 chkCnt);
! static Sint32 outcodeScr(XyInt *xy1, XyInt *xy2);
! static int    clip2DLevel3(PolTbl *polTbl);
! static Sint32 clipFrmCheck(XyInt *xy1, XyInt *xy2, Sint32 chkCnt);
! static Sint32 outcodeFrm(XyInt *xy1, XyInt *xy2);
! static int    clipFrame(PolTbl *polTbl);
! static int    frmCrossChk(int frmNo, XyInt *p1, XyInt *p2, XyInt *cp);
! static void   transPolygons(DoubleBufArea *buf, XyInt *vert2d);
! static void   viewCoordMatrix(void);
! static void   setLightAngle(void);
! extern Uint16 SPR_3GetShdColor(Uint16 baseRgbColor, Uint16 bright);
! 
! 
! 
! /*****************************************************************************
!  *
!  * NAME:  SPR_3Initial()  - Initial 3D Sprite Display Environment
!  *
!  * PARAMETERS :
!  *
!  * 　　(1) Spr3WorkArea *workArea - <i> ３Ｄスプライトワークエリア定義
!  *
!  * DESCRIPTION:
!  *
!  *     ３Ｄスプライト表示の初期化処理
!  *
!  *
!  * POSTCONDITIONS:
!  *
!  *     No exist.
!  *
!  * CAVEATS:
!  *
!  *****************************************************************************
!  */
! void
! SPR_3Initial(Spr3WorkArea  *workArea)
! {
!     MthXyz  w0,w1;
! 
!     /** BEGIN ***************************************************************/
!     SPR_3SetDrawSpeed(0, 0, 0);
! 
!     dBuf[0].surfBright   = workArea->surfBright[0];
!     dBuf[1].surfBright   = workArea->surfBright[1];
!     dBuf[0].vertBright   = workArea->vertBright[0];
!     dBuf[1].vertBright   = workArea->vertBright[1];
!     dBuf[0].coordView3D  = workArea->coordView3D[0];
!     dBuf[1].coordView3D  = workArea->coordView3D[1];
!     dBuf[0].coordWorld3D = workArea->coordWorld3D[0];
!     dBuf[1].coordWorld3D = workArea->coordWorld3D[1];
!     if(workArea->surfBright[1])
!         doubleBufFlag = 1;
!     else
!         doubleBufFlag = 0;
!     if(workArea->coordWorld3D[0])
!         postWorldDataFlag = 1;
!     else
!         postWorldDataFlag = 0;
! 
!     if(!dBuf[1].surfBright)   dBuf[1].surfBright   = dBuf[0].surfBright;
!     if(!dBuf[1].vertBright)   dBuf[1].vertBright   = dBuf[0].vertBright;
!     if(!dBuf[1].coordView3D)  dBuf[1].coordView3D  = dBuf[0].coordView3D;
!     if(!dBuf[1].coordWorld3D) dBuf[1].coordWorld3D = dBuf[0].coordWorld3D;
! 
!     coord2D      = workArea->coord2D;
!     coord2DFlag  = workArea->coord2DFlag;
! 
!     zSortBlkCnt = SpDrawPrtyBlkMax;
!     for(blkSftCnt=0; blkSftCnt<16; blkSftCnt++)
!        if((zSortBlkCnt<<=1) & 0x8000) break;
!     zSortBlkCnt = SpDrawPrtyBlkMax;
!     zSortZMin = ZSORT_MIN_Z;
!     zSortZMax = ZSORT_MAX_Z;
!     zSortMode = ZSORT_FLOAT_MODE;
! 
!     clipLevel = 2;
!     clipZMin  = CLIP_MIN_Z;
!     clipZMax  = CLIP_MAX_Z;
! 
!     w0.x = MTH_FIXED(0.0);   w0.y = MTH_FIXED(0.0);     w0.z = MTH_FIXED(0.0);
!     SPR_3SetLight(1, &w0);
!     w0.x = MTH_FIXED(0.0);   w0.y = MTH_FIXED(0.0);     w0.z = MTH_FIXED(0.0);
!     w1.x = MTH_FIXED(0.0);   w1.y = MTH_FIXED(0.0);     w1.z = MTH_FIXED(0.0);
!     SPR_3SetView(1, &w0, &w1, ROT_SEQ_XYZ, &w0);
! 
!     firstDrawFlag = 1;
!     MTH_InitialMatrix(&worldMatrixTbl, WORLD_MATRIX_STACK_SIZE,	worldMatrix);
!     MTH_PolyDataTransInit();
!     SPR_3SetPixelCount(SCREEN_W_SIZE, SCREEN_H_SIZE);
! }
! 
! 
! /*****************************************************************************
!  *
!  * NAME:  SPR_3SetLight()  - Set Light Angle
!  *
!  * PARAMETERS :
!  *
!  *     (1) Uint16      moveKind  - <i> 移動量の種別ーブルポインタ
!  *                       　　　　　    0 = 相対移動、1 = 絶対移動タ
!  *     (2) MthXyz *pLightAngler  - <i>  平行光源のアングル
!  *
!  * DESCRIPTION:
!  *
!  *     光源アングルセット
!  *
!  * POSTCONDITIONS:
!  *
!  *     No exist.
!  *
!  * CAVEATS:
!  *
!  *****************************************************************************
!  */
! void
! SPR_3SetLight(Uint16 moveKind, MthXyz *pLightAngle)
! {
!     Fixed32 angleX, angleY, angleZ;
! 
!     /** BEGIN ***************************************************************/
!     if(moveKind & 0x0002) {
!         angleX = MTH_Atan(pLightAngle->y, pLightAngle->z);
!         angleY = MTH_Atan(pLightAngle->z, pLightAngle->x);
!         angleZ = MTH_Atan(pLightAngle->y, pLightAngle->x);
!     } else  {
!         angleX = pLightAngle->x;
!         angleY = pLightAngle->y;
!         angleZ = pLightAngle->z;
!     }
!     if(moveKind & 0x0001) {
! 	lightAngle.x  = angleX;
! 	lightAngle.y  = angleY;
! 	lightAngle.z  = angleZ;
!     } else       {
! 	lightAngle.x  += angleX;
! 	lightAngle.y  += angleY;
! 	lightAngle.z  += angleZ;
!     }
!     if(lightAngle.x > MTH_FIXED( 180)) lightAngle.x -= MTH_FIXED(360);  else
!     if(lightAngle.x < MTH_FIXED(-180)) lightAngle.x += MTH_FIXED(360);
!     if(lightAngle.y > MTH_FIXED( 180)) lightAngle.y -= MTH_FIXED(360);  else
!     if(lightAngle.y < MTH_FIXED(-180)) lightAngle.y += MTH_FIXED(360);
!     if(lightAngle.z > MTH_FIXED( 180)) lightAngle.z -= MTH_FIXED(360);  else
!     if(lightAngle.z < MTH_FIXED(-180)) lightAngle.z += MTH_FIXED(360);
!     setLightAngle();
! }
! 
! 
! /*****************************************************************************
!  *
!  * NAME:  SPR_3SetView()  - Set View Point and Angle
!  *
!  * PARAMETERS :
!  *
!  *     (1) Uint16  moveKind         - <i> 移動量の種別ーブルポインタ
!  *                       　　　　　       0 = 相対移動、1 = 絶対移動タ
!  *     (2) MthXyz *pViewPoint       - <i> 視点座標
!  *     (3) MthXyz *pViewAngle       - <i> 視点のアングル（度）
!  *     (4) Uint16  pViewAngleSeq    - <i> アングルの回転操作
!  *　　　　　　　　　　　    　            ROT_SEQ_ZYX
!  *　　　　　　　　　　　    　            ROT_SEQ_ZXY
!  *　　　　　　　　　　　    　            ROT_SEQ_YZX
!  *　　　　　　　　　　　    　            ROT_SEQ_YXZ
!  *　　　　　　　　　　　    　            ROT_SEQ_XYZ
!  *　　　　　　　　　　　    　            ROT_SEQ_XZY
!  *     (5) MthXyz *pViewCoordPoint  - <i> 視点座標系内の視点位置
!  *
!  * DESCRIPTION:
!  *
!  *     視点のセット
!  *
!  * POSTCONDITIONS:
!  *
!  *     No exist.
!  *
!  * CAVEATS:
!  *
!  *****************************************************************************
!  */
! void
! SPR_3SetView(Uint16 moveKind, MthXyz *pViewPoint, MthXyz *pViewAngle,
!                               Uint16 pViewAngleSeq, MthXyz *pViewCoordPoint)
! {
!     Fixed32 angleX, angleY, angleZ;
! 
!     /** BEGIN ***************************************************************/
!     viewAngleSeq = pViewAngleSeq;
! 
!     if(pViewCoordPoint) {
!         if(moveKind & 0x0001) {
! 	    viewCoordPoint.x  = pViewCoordPoint->x;
! 	    viewCoordPoint.y  = pViewCoordPoint->y;
! 	    viewCoordPoint.z  = pViewCoordPoint->z;
!         } else       {
! 	    viewCoordPoint.x += pViewCoordPoint->x;
! 	    viewCoordPoint.y += pViewCoordPoint->y;
! 	    viewCoordPoint.z += pViewCoordPoint->z;
!         }
!     }
! 
!     if(pViewPoint) {
!         if(moveKind & 0x0001) {
! 	    viewPoint.x  = pViewPoint->x;
! 	    viewPoint.y  = pViewPoint->y;
! 	    viewPoint.z  = pViewPoint->z;
!         } else       {
! 	    viewPoint.x += pViewPoint->x;
! 	    viewPoint.y += pViewPoint->y;
! 	    viewPoint.z += pViewPoint->z;
!         }
!     }
! 
!     if(pViewAngle) {
!         if(moveKind & 0x0002) {
!             angleX = MTH_Atan(pViewAngle->y, pViewAngle->z);
!             angleY = MTH_Atan(pViewAngle->z, pViewAngle->x);
!             angleZ = MTH_Atan(pViewAngle->y, pViewAngle->x);
!         } else  {
!             angleX = pViewAngle->x;
!             angleY = pViewAngle->y;
!             angleZ = pViewAngle->z;
!         }
!         if(moveKind & 0x0001) {
! 	    viewAngle.x  = angleX;
! 	    viewAngle.y  = angleY;
! 	    viewAngle.z  = angleZ;
!         } else       {
! 	    viewAngle.x += angleX;
! 	    viewAngle.y += angleY;
! 	    viewAngle.z += angleZ;
!         }
!         if(viewAngle.x > MTH_FIXED( 180)) viewAngle.x -= MTH_FIXED(360);  else
!         if(viewAngle.x < MTH_FIXED(-180)) viewAngle.x += MTH_FIXED(360);
!         if(viewAngle.y > MTH_FIXED( 180)) viewAngle.y -= MTH_FIXED(360);  else
!         if(viewAngle.y < MTH_FIXED(-180)) viewAngle.y += MTH_FIXED(360);
!         if(viewAngle.z > MTH_FIXED( 180)) viewAngle.z -= MTH_FIXED(360);  else
!         if(viewAngle.z < MTH_FIXED(-180)) viewAngle.z += MTH_FIXED(360);
!     }
! 
! }
! 
! 
! /*****************************************************************************
!  *
!  * NAME:  SPR_3CallAllCluster()  - Call User Function with all Cluster
!  *
!  * PARAMETERS :
!  *
!  *     (1) SprCluster *cluster           - <i> ルートクラスタテーブルのポインタ
!  *     (2) void (*userFunc)(SprCluster*) - <i> ユーザファンクション
!  *
!  * DESCRIPTION:
!  *
!  *     ルートクラスタにつながる全クラスタをパラメータとして指定ファンクション
!  *     を呼び出す
!  *
!  * POSTCONDITIONS:
!  *
!  *     No exist.
!  *
!  * CAVEATS:
!  *
!  *****************************************************************************
!  */
! void   SPR_3CallAllCluster(SprCluster *cluster, void (*userFunc)(SprCluster*))
! {
!     /** BEGIN ***************************************************************/
!     while(cluster) {
!         userFunc(cluster);
! 	/* 子クラスタの処理 */
! 	if(cluster->child) SPR_3CallAllCluster(cluster->child, userFunc);
!         cluster = cluster->next;
!     }
! }
! 
! 
! /*****************************************************************************
!  *
!  * NAME:  SPR_3MoveCluster()  - Move Specify Cluster
!  *
!  * PARAMETERS :
!  *
!  *     (1) SprCluster *cluster   - <i> 移動すべきクラスタテーブルのポインタ
!  *     (2) Uint16      moveKind  - <i> 移動量の種別ーブルポインタ
!  *                       　　　　　    0 = 相対移動、1 = 絶対移動タ
!  *     (3) MthXyz     *angle     - <i> 回転移動量（度）
!  *     (4) MthXyz     *point     - <i> 平行移動量テーブルポインタ
!  *
!  * DESCRIPTION:
!  *
!  *     クラスタの移動
!  *
!  * POSTCONDITIONS:
!  *
!  *     No exist.
!  *
!  * CAVEATS:
!  *
!  *****************************************************************************
!  */
! void
! SPR_3MoveCluster(SprCluster *cluster, Uint16 moveKind,
! 				      MthXyz *angle, MthXyz *point)
! {
!     Fixed32 angleX, angleY, angleZ;
! 
!     /** BEGIN ***************************************************************/
!     if(angle) {
!         if(moveKind & 0x0002) {
!             angleX = MTH_Atan(angle->y, angle->z);
!             angleY = MTH_Atan(angle->z, angle->x);
!             angleZ = MTH_Atan(angle->y, angle->x);
!         } else  {
! 	    angleX = angle->x;
! 	    angleY = angle->y;
! 	    angleZ = angle->z;
!         }
!         if(moveKind & 0x0001) {
!    	    cluster->angle.x  = angleX;
! 	    cluster->angle.y  = angleY;
! 	    cluster->angle.z  = angleZ;
!         } else       {
! 	    cluster->angle.x += angleX;
! 	    cluster->angle.y += angleY;
! 	    cluster->angle.z += angleZ;
!         }
!         if(cluster->angle.x > MTH_FIXED( 180))
!             cluster->angle.x -= MTH_FIXED(360);
!         else
!         if(cluster->angle.x < MTH_FIXED(-180))
!             cluster->angle.x += MTH_FIXED(360);
!         if(cluster->angle.y > MTH_FIXED( 180))
!             cluster->angle.y -= MTH_FIXED(360);
!         else
!         if(cluster->angle.y < MTH_FIXED(-180))
!             cluster->angle.y += MTH_FIXED(360);
!         if(cluster->angle.z > MTH_FIXED( 180))
!             cluster->angle.z -= MTH_FIXED(360);
!         else
!         if(cluster->angle.z < MTH_FIXED(-180))
!             cluster->angle.z += MTH_FIXED(360);
!     }
!     if(point)
!         if(moveKind & 0x0001) {
! 	    cluster->point.x  = point->x;
! 	    cluster->point.y  = point->y;
! 	    cluster->point.z  = point->z;
!         } else       {
! 	    cluster->point.x += point->x;
! 	    cluster->point.y += point->y;
! 	    cluster->point.z += point->z;
!         }
! }
! 
! 
! /*****************************************************************************
!  *
!  * NAME:  SPR_3DrawModel()  - Set Specify Model
!  *
!  * PARAMETERS :
!  *
!  *     (1) SprCluster *rootCluster  - <i>  表示すべきモデルのルートクラスタ
!  *                                         テーブルのポインタ
!  *
!  * DESCRIPTION:
!  *
!  *     モデルの登録
!  *
!  * POSTCONDITIONS:
!  *
!  *     No exist.
!  *
!  * CAVEATS:
!  *
!  *****************************************************************************
!  */
! void
! SPR_3DrawModel(SprCluster *rootCluster)
! {
!     /** BEGIN ***************************************************************/
!     if(firstDrawFlag) {
! 	firstDrawFlag = 0;
! 	viewCoordMatrix();
! 	initDraw();
!     }
! 
!     transCluster(rootCluster);
! }
! 
! 
! /*****************************************************************************
!  *
!  * NAME:  SPR_3Flush()  - Draw End All Seted Cluster
!  *
!  * PARAMETERS :
!  *
!  *     No exist.
!  *
!  * DESCRIPTION:
!  *
!  *     登録された全モデルの描画終了処理
!  *
!  * POSTCONDITIONS:
!  *
!  *     No exist.
!  *
!  * CAVEATS:
!  *
!  *****************************************************************************
!  */
! void
! SPR_3Flush(void)
! {
!     /** BEGIN ***************************************************************/
!     if(doubleBufFlag) {
! 	cBuf = &dBuf[bufSW^1];
! 	transPolygons(cBuf, coord2D);
!     }
!     SPR_2FlushDrawPrty();
!     firstDrawFlag = 1;
! }
! 
! 
! /*****************************************************************************
!  *
!  * NAME:  SPR_3SetTexture()  - Set Texture Data
!  *
!  * PARAMETERS :
!  *
!  *     (1) SprTexture *texture  - <i>  テクスチャテーブルのポインタ
!  *
!  * DESCRIPTION:
!  *
!  *     テクスチャのセット
!  *
!  * POSTCONDITIONS:
!  *
!  *     No exist.
!  *
!  * CAVEATS:
!  *
!  *****************************************************************************
!  */
! void
! SPR_3SetTexture(SprTexture *texture)
! {
!     SprTexture   *wTex;
! 
!     /** BEGIN ***************************************************************/
!     for(wTex = texture; wTex->charNo != 0xffff; wTex++) {
! 	SPR_2SetChar(wTex->charNo, wTex->colorMode, wTex->color,
!                      wTex->width, wTex->height, wTex->charData);
! 	if(wTex->lookupTbl)
! 	    SPR_2SetLookupTbl(wTex->color, wTex->lookupTbl);
!     }
! }
! 
! 
! /*****************************************************************************
!  *
!  * NAME:  SPR_3ChangeTexColor()  - Change Texture Color
!  *
!  * PARAMETERS :
!  *
!  *     (1) Uint16      charNo    - <i>  キャラクタ番号
!  *     (2) Uint16      color     - <i>  カラーデータ（ｶﾗｰﾊﾞﾝｸorﾙｯｸｱｯﾌﾟﾃｰﾌﾞﾙNo）
!  *     (2) SprLookupTbl *lookupTbl   - <i>  ルックアップテーブルポインタ
!  *
!  * DESCRIPTION:
!  *
!  *     テクスチャカラーデータの変更
!  *
!  * POSTCONDITIONS:
!  *
!  *     No exist.
!  *
!  * CAVEATS:
!  *
!  *****************************************************************************
!  */
! void
! SPR_3ChangeTexColor(Uint16 charNo, Uint16 color, SprLookupTbl *lookupTbl)
! {
!     /** BEGIN ***************************************************************/
!     SpCharTbl[charNo].color = color;
!     if(lookupTbl)
!         SPR_2SetLookupTbl(color, lookupTbl);
! }
! 
! 
! /*****************************************************************************
!  *
!  * NAME:  SPR_3ClrTexture()  - Clear Texture Data
!  *
!  * PARAMETERS :
!  *
!  *     (1) SprTexture *texture  - <i>  テクスチャテーブルのポインタ
!  *
!  * DESCRIPTION:
!  *
!  *     テクスチャエリアの解放
!  *
!  * POSTCONDITIONS:
!  *
!  *     No exist.
!  *
!  * CAVEATS:
!  *
!  *****************************************************************************
!  */
! void
! SPR_3ClrTexture(SprTexture *texture)
! {
!     SprTexture  *wTex;
! 
!     /** BEGIN ***************************************************************/
!     for(wTex = texture; wTex->charNo != 0xffff; wTex++)
!         SPR_2ClrChar(wTex->charNo);
! }
! 
! 
! /*****************************************************************************
!  *
!  * NAME:  SPR_3SetZSortMinMax()  - Set Z Sort Min/Max Z Value
!  *
!  * PARAMETERS :
!  *
!  *     (1) Uint16   pZSortMode  - <i>  ＺソートＺ座標値の採用モード
!  *                                     ０＝浮動モード
!  *                                     １＝固定モード
!  *     (2) Fixed32  pZSortMin   - <i>  視点座標系ＺソートＺ最小値座標
!  *     (3) Fixed32  pZSortMax   - <i>  視点座標系ＺソートＺ最大値座標
!  *
!  *
!  * DESCRIPTION:
!  *
!  *     視点座標系Ｚソート範囲の最小・最大値をセット
!  *
!  * POSTCONDITIONS:
!  *
!  *     No exist.
!  *
!  * CAVEATS:
!  *
!  *****************************************************************************
!  */
! void
! SPR_3SetZSortMinMax(Uint16 pZSortMode, Fixed32 pZSortMin, Fixed32 pZSortMax)
! {
! 
!     /** BEGIN ***************************************************************/
!     zSortMode    = pZSortMode;
!     zSortZMin    = pZSortMin;
!     zSortZMax    = pZSortMax;
!     zSortZMinOrg = pZSortMin;
!     zSortZMaxOrg = pZSortMax;
! }
! 
! 
! /*****************************************************************************
!  *
!  * NAME:  SPR_3SetClipLevel()  - Set Cliping Level
!  *
!  * PARAMETERS :
!  *
!  *     (1) Uint16   pClipLevel  - <i>  クリッピングのレベル番号
!  *                                     ０＝クリッピングなし
!  *                                     １＝視点座標系のＺ範囲でクリップ
!  *                                         （座標変換後）
!  *                                     ２＝スクリーンに掛からないポリゴンの
!  *                                         削除（透視変換後）
!  *                                     ３＝フレームバッファの境界でクリップ
!  *                                         （透視変換後）
!  *     (2) Fixed32  pClipZMin   - <i>  視点座標系クリップＺ最小値座標
!  *     (3) Fixed32  pClipZMax   - <i>  視点座標系クリップＺ最大値座標
!  *
!  * DESCRIPTION:
!  *
!  *     クリッピングレベルのセット
!  *
!  * POSTCONDITIONS:
!  *
!  *     No exist.
!  *
!  * CAVEATS:
!  *
!  *****************************************************************************
!  */
! void
! SPR_3SetClipLevel(Uint16 pClipLevel, Fixed32 pClipZMin, Fixed32 pClipZMax)
! {
! 
!     /** BEGIN ***************************************************************/
!     clipLevel = pClipLevel;
!     clipZMin  = pClipZMin;
!     clipZMax  = pClipZMax;
! }
! 
! 
! /*****************************************************************************
!  *
!  * NAME:  SPR_3SetPixelCount()  - Set Screen Pixel Count
!  *
!  * PARAMETERS :
!  *
!  *     (1) Uint16   pixelCountX  - <i>  スクリーンＸの単位ピクセル数
!  *     (2) Uint16   pixelCountY  - <i>  スクリーンＹの単位ピクセル数
!  *
!  * DESCRIPTION:
!  *
!  *     スクリーンへの透視変換時のＸＹ各々 1.0 に対するスクリーンのピクセル数
!  *     を設定する。
!  *
!  * POSTCONDITIONS:
!  *
!  *     No exist.
!  *
!  * CAVEATS:
!  *
!  *****************************************************************************
!  */
! void SPR_3SetPixelCount(Uint16 pixelCountX, Uint16 pixelCountY)
! {
! 
!     /** BEGIN ***************************************************************/
!     unitPixel.x = MTH_IntToFixed(pixelCountX);
!     unitPixel.y = MTH_IntToFixed(pixelCountY);
! }
! 
! 
! /*****************************************************************************
!  *
!  * NAME:  SPR_3GetStatus()  - Get 3D Environment Value
!  *
!  * PARAMETERS :
!  *
!  *     (1) Spr3dStatus *spr3dStatus  - <o>  ３Ｄ環境データテーブルのポインタ
!  *
!  * DESCRIPTION:
!  *
!  *     現３Ｄ環境データの取得。
!  *
!  *
!  * POSTCONDITIONS:
!  *
!  *     No exist.
!  *
!  * CAVEATS:
!  *
!  *****************************************************************************
!  */
! void   SPR_3GetStatus(Spr3dStatus *spr3dStatus)
! {
!     /** BEGIN ***************************************************************/
!     spr3dStatus->lightAngle      = lightAngle;
!     spr3dStatus->viewCoordPoint  = viewCoordPoint;
!     spr3dStatus->viewPoint       = viewPoint;
!     spr3dStatus->viewAngle       = viewAngle;
!     spr3dStatus->viewAngleSeq    = viewAngleSeq;
!     spr3dStatus->zSortMode       = zSortMode;
!     spr3dStatus->zSortZMin       = zSortZMin;
!     spr3dStatus->zSortZMax       = zSortZMax;
!     spr3dStatus->clipZMin        = clipZMin;
!     spr3dStatus->clipZMax        = clipZMax;
!     spr3dStatus->clipLevel       = clipLevel;
!     spr3dStatus->unitPixel       = unitPixel;
! }
! 
! 
! /*****************************************************************************
!  *
!  * NAME:  SPR_3SetSurfNormVect() - Compute Surface Normal Vector in the Object
!  *
!  * PARAMETERS :
!  *
!  *     (1)  SprObject3D  *obj  - <i/o>  ３Ｄオブジェクトのポインタ
!  *
!  * DESCRIPTION:
!  *
!  *     指定３Ｄオブジェクトの面の法線を計算し、セットする。
!  *
!  *
!  * POSTCONDITIONS:
!  *
!  *     No exist.
!  *
!  * CAVEATS:
!  *
!  *****************************************************************************
!  */
! void   SPR_3SetSurfNormVect(SprObject3D  *obj)
! {
!     Sint32      i, p1, p2, p3;
!     MthXyz      *wVertPoint;
!     SprSurface  *wSurface;
!     MthXyz      *wSurfNormal;
! 
!     /** BEGIN ***************************************************************/
!     wSurface    = obj->surface;
!     wVertPoint  = obj->vertPoint;
!     wSurfNormal = obj->surfaceNormal;
!     for(i = 0; i < obj->surfaceCount; i++) {
! 	p1 = wSurface->vertNo[0];
! 	p2 = wSurface->vertNo[1];
! 	p3 = wSurface->vertNo[2];
! 	MTH_ComputeNormVect(obj->surfNormK, &wVertPoint[p1], &wVertPoint[p2],
! 			                    &wVertPoint[p3], wSurfNormal);
! 	wSurface++;
! 	wSurfNormal++;
!     }
! }
! 
! 
! /*****************************************************************************
!  *
!  * NAME:  SPR_3SetDrawSpeed() - Set VDP1 Drawing Speed up Parameter
!  *
!  * PARAMETERS :
!  *
!  *     (1)  Sint32    hssFlag  - <i>  ハイスピードシュリンクフラグ
!  *                                    テクスチャポリゴンの描画モード
!  *                                    ０＝精度優先描画（デフォルト）
!  *                                    １＝速度優先描画
!  *     (2)  Sint32    eosFlag  - <i>  hss=1 で速度優先描画を指定した時の
!  *                                    元絵テクスチャのサンプリング座標
!  *                                    ０＝偶数座標をサンプリング（デフォルト）
!  *                                    １＝奇数座標をサンプリング
!  *     (3)  Sint32    pclpFlag - <i>  プリクリッピング有効・無効フラグ
!  *                                    ０＝有効（デフォルト）
!  *                                    １＝無効
!  *
!  *
!  * DESCRIPTION:
!  *
!  *     ＶＤＰ１の高速描画パラメータをセット
!  *
!  *
!  * POSTCONDITIONS:
!  *
!  *     No exist.
!  *
!  * CAVEATS:
!  *
!  *****************************************************************************
!  */
! void   SPR_3SetDrawSpeed(Sint32 hssFlag, Sint32 eosFlag, Sint32 pclpFlag)
! {
!     Sint32      i, p1, p2, p3;
!     MthXyz      *wVertPoint;
!     SprSurface  *wSurface;
!     MthXyz      *wSurfNormal;
! 
!     /** BEGIN ***************************************************************/
!     if(hssFlag)
!        spriteDrawFlag  = HSS_ENABLE;
!     else
!        spriteDrawFlag  = 0;
! 
!     if(pclpFlag) {
!        spriteDrawFlag |= PCLP_ENABLE;
!        otherDrawFlag   = PCLP_ENABLE;
!     } else {
!        spriteDrawFlag &= ~PCLP_ENABLE;
!        otherDrawFlag   = 0;
!     }
! 
!     SPR_SetEosMode(eosFlag);
! }
! 
! 
! /*****************************************************************************
!  *
!  * NAME:  initDraw()  - Initial Draw Environment
!  *
!  * PARAMETERS :
!  *
!  *     No exist.
!  *
!  * DESCRIPTION:
!  *
!  *     ３Ｄ表示のテーブル初期化
!  *
!  *
!  * POSTCONDITIONS:
!  *
!  *     No exist.
!  *
!  * CAVEATS:
!  *
!  *****************************************************************************
!  */
! static void
! initDraw(void)
! {
!     Fixed32   ztMax;
!     Sint32    i;
! 
!     /** BEGIN ***************************************************************/
!     if(zSortMode) {
!         zSortBZMin    = zSortZMinOrg;
!         zSortBZMax    = zSortZMaxOrg;
!     } else        {
!         zSortBZMin    = zSortZMin;
!         zSortBZMax    = zSortZMax;
!     }
!     zSortZMin     = FIXED_MAX;
!     zSortZMax     = FIXED_MIN;
!     ztMax = zSortBZMax - zSortBZMin;
!     for(i=0; i<32; i++)
! 	if((ztMax<<=1) & 0x80000000) break;
!     zSftCnt = 17 - i + blkSftCnt;
!     if(zSftCnt < 0) zSftCnt = 0;
!     dbFirstFlag = 1;
!     bufSW       = 0;
!     if(Sp2OpenFlag) {
!         gourTblNo   = 0;
!         clipScrXMin = -SpLCoordX;
!         clipScrXMax = SpScreenX - SpLCoordX - 1;
!         clipScrYMin = -SpLCoordY;
!         clipScrYMax = SpScreenY - SpLCoordY - 1;
!         Sp2OpenFlag = 0;
!     }
! }
! 
! 
! /*****************************************************************************
!  *
!  * NAME:  drawPol()  - Draw 1 Polygon
!  *
!  * PARAMETERS :
!  *
!  *     (1) PolTbl  *polTbl          - <i>  ポリゴンテーブルのポインタ
!  *
!  * DESCRIPTION:
!  *
!  *     ポリゴンの描画
!  *
!  * POSTCONDITIONS:
!  *
!  *     No exist.
!  *
!  * CAVEATS:
!  *
!  *****************************************************************************
!  */
! static void
! drawPol(PolTbl *polTbl)
! {
!     Sint32     drawPrtyBlkNo;
!     Sint32     shadingKind, dispKind, drawMode, colOrTex, textCtrl;
!     Sint32     surfBright;
!     Sint32     mateKind, i;
!     XyInt      *xy;
!     SprGourTbl *gourTbl;
!     Sint32     z;
! 
!     /** BEGIN ***************************************************************/
!     dispKind    = polTbl->dispFlag & DISP_MASK;
!     shadingKind = polTbl->dispFlag & SHADING_MASK;
!     mateKind    = polTbl->drawMode & MATE_MASK;
!     drawMode    = polTbl->drawMode & DRAW_MODE_MASK;
!     surfBright  = polTbl->surfBright;
!     gourTbl     = &polTbl->gourTbl;
!     colOrTex    = polTbl->color;
!     xy          = polTbl->xy;
! 
!     if(mateKind == MATE_TEXTURE) {
!         textCtrl   = colOrTex & 0xc000;
!         textCtrl >>= 10;
!         colOrTex  &= 0x3fff;
!     }
! 
!     /* Ｚ値ブロックソートの最大最小値を得る */
!     if(polTbl->z < zSortZMin) zSortZMin = polTbl->z;
!     if(polTbl->z > zSortZMax) zSortZMax = polTbl->z;
!     if(polTbl->z > zSortBZMin) {
! 	drawPrtyBlkNo = (int)((polTbl->z - zSortBZMin) >> zSftCnt);
! 	if(drawPrtyBlkNo >= zSortBlkCnt)
! 	    drawPrtyBlkNo = zSortBlkCnt - 1;
!     } else
! 	drawPrtyBlkNo = 0;
! 
!     for(i=0; i<polTbl->polyCnt; i++) {
! 	if(shadingKind == NO_SHADING) {
!             if(mateKind == MATE_TEXTURE) {
! 		SPR_2DistSpr(drawPrtyBlkNo, textCtrl,
!                                   drawMode | spriteDrawFlag,
! 		   	          0xffff, colOrTex, xy, NO_GOUR);
!             } else {
!     	        if(dispKind == DISP_POLYGON) {
! 	            SPR_2Polygon(drawPrtyBlkNo,
! 	                      drawMode | otherDrawFlag, colOrTex, xy, NO_GOUR);
!                 } else {
! 	            SPR_2PolyLine(drawPrtyBlkNo,
! 	                      drawMode | otherDrawFlag, colOrTex, xy, NO_GOUR);
!                 }
!             }
!         } else
! 	if(shadingKind == FLAT_SHADING) {  /* Color Mode is Only RGB */
!             if(mateKind == MATE_TEXTURE) {
! 	        SPR_2SetGourTbl(gourTblNo, gourTbl);
!                 SPR_2DistSpr(drawPrtyBlkNo, textCtrl,
!                              drawMode | DRAW_GOURAU  | spriteDrawFlag,
!                               0xffff, colOrTex, xy, gourTblNo);
! 		gourTblNo++;
!             } else {
!                 if(dispKind == DISP_POLYGON) {
! 		    SPR_2Polygon(drawPrtyBlkNo, drawMode | otherDrawFlag,
!                                  surfBright, xy, NO_GOUR);
!                 } else {
!                     SPR_2PolyLine(drawPrtyBlkNo, drawMode | otherDrawFlag,
!                                   surfBright, xy, NO_GOUR);
! 	        }
! 	    }
!         } else
!         if(shadingKind == GOURAUD_SHADING) { /* Color Mode is Only RGB */
!             SPR_2SetGourTbl(gourTblNo, gourTbl);
!             if(mateKind == MATE_TEXTURE) {
!                 SPR_2DistSpr(drawPrtyBlkNo, textCtrl,
!                                  drawMode | DRAW_GOURAU | spriteDrawFlag,
! 		   	                0xffff, colOrTex, xy, gourTblNo);
!             } else     {
! 	        if(dispKind == DISP_POLYGON) {
!                     SPR_2Polygon(drawPrtyBlkNo,
!                                  drawMode | DRAW_GOURAU | otherDrawFlag,
! 						colOrTex, xy, gourTblNo);
!                 } else {
! 		    SPR_2PolyLine(drawPrtyBlkNo,
!                                   drawMode | DRAW_GOURAU | otherDrawFlag,
! 				          	colOrTex, xy, gourTblNo);
!                 }
!             }
! 	    gourTblNo++;
!         }
!         xy += 4;
!     }
! }
! 
! 
! /*****************************************************************************
!  *
!  * NAME:  transCluster()  - Transfer Cluster Coord
!  *
!  * PARAMETERS :
!  *
!  *     (1) SprCluster  *cluster  - <i>  ルートクラスタのポインタ
!  *
!  * DESCRIPTION:
!  *
!  *     クラスタ単位の隠面、座標変換処理
!  *
!  *
!  * POSTCONDITIONS:
!  *
!  *     No exist.
!  *
!  * CAVEATS:
!  *
!  *****************************************************************************
!  */
! static void
! transCluster(SprCluster *cluster)
! {
!     SprObject3D  *obj;
!     SprSurface   *wSurface;
!     MthXyz       *wVertPoint, *wSurfaceVert;
!     Fixed32      *wSurfPoint, *wVPoint;
!     Uint8        *wSurfBright;
!     Uint16       *wVertNo;
!     Sint32 	 i, j;
!     const static MthMatrix	unitMatrix
! 	= { MTH_FIXED(1.0), MTH_FIXED(0.0), MTH_FIXED(0.0), MTH_FIXED(0.0),
! 	    MTH_FIXED(0.0), MTH_FIXED(1.0), MTH_FIXED(0.0), MTH_FIXED(0.0),
! 	    MTH_FIXED(0.0), MTH_FIXED(0.0), MTH_FIXED(1.0), MTH_FIXED(0.0)};
! 
!     /** BEGIN ***************************************************************/
!     while(cluster) {
!         if(cluster->transStart)  cluster->transStart(cluster);
! 
!         MTH_PushMatrix(&worldMatrixTbl);
! 
! 	/* カレントマトリックスにクラスタの移動量マトリックスセット */
! 	MTH_MoveMatrix(&worldMatrixTbl,
!                        cluster->point.x, cluster->point.y, cluster->point.z);
! 	switch(cluster->angleSeq) {
! 	    case ROT_SEQ_ZYX :
! 		 MTH_RotateMatrixX(&worldMatrixTbl, cluster->angle.x);
! 	         MTH_RotateMatrixY(&worldMatrixTbl, cluster->angle.y);
! 	         MTH_RotateMatrixZ(&worldMatrixTbl, cluster->angle.z);
!                  break;
!             case ROT_SEQ_ZXY :
! 		 MTH_RotateMatrixY(&worldMatrixTbl, cluster->angle.y);
! 	         MTH_RotateMatrixX(&worldMatrixTbl, cluster->angle.x);
! 	         MTH_RotateMatrixZ(&worldMatrixTbl, cluster->angle.z);
! 		 break;
!             case ROT_SEQ_YZX :
! 	         MTH_RotateMatrixX(&worldMatrixTbl, cluster->angle.x);
! 		 MTH_RotateMatrixZ(&worldMatrixTbl, cluster->angle.z);
! 		 MTH_RotateMatrixY(&worldMatrixTbl, cluster->angle.y);
!                  break;
!             case ROT_SEQ_YXZ :
! 	         MTH_RotateMatrixZ(&worldMatrixTbl, cluster->angle.z);
! 	         MTH_RotateMatrixX(&worldMatrixTbl, cluster->angle.x);
! 		 MTH_RotateMatrixY(&worldMatrixTbl, cluster->angle.y);
! 		 break;
! 	    case ROT_SEQ_XYZ :
! 		 MTH_RotateMatrixZ(&worldMatrixTbl, cluster->angle.z);
! 		 MTH_RotateMatrixY(&worldMatrixTbl, cluster->angle.y);
! 		 MTH_RotateMatrixX(&worldMatrixTbl, cluster->angle.x);
! 		 break;
! 	    case ROT_SEQ_XZY :
! 		 MTH_RotateMatrixY(&worldMatrixTbl, cluster->angle.y);
! 		 MTH_RotateMatrixZ(&worldMatrixTbl, cluster->angle.z);
! 		 MTH_RotateMatrixX(&worldMatrixTbl, cluster->angle.x);
! 		 break;
! 	}
! 
! 	obj = cluster->object;
! 	if(obj) {
! 	    if(postWorldDataFlag) {
! 	        MTH_MulMatrix(&viewMatrix, worldMatrixTbl.current,
! 						     &viewLight.viewMatrix);
! 	        memcpy(&viewLight.worldMatrix, worldMatrixTbl.current,
! 						     sizeof(MthMatrix));
! 	    } else {
! 	        memcpy(&viewLight.viewMatrix, worldMatrixTbl.current,
! 						     sizeof(MthMatrix));
! 	    }
! 	}
! 
! 	while(obj) {
!             cBuf = &dBuf[bufSW];
!             cBuf->cluster = cluster;
!             cBuf->object  = obj;
!             if(obj->dispFlag & INBETWEEN_OBJECT) {
! 		memcpy(&viewLight.viewMatrix, &unitMatrix,sizeof(MthMatrix));
! 		SPR_3SetSurfNormVect(obj);
!             }
! 
! 	    if(obj->surfaceVert == 0) {
! 		/* 面の代表頂点テーブルを得る */
! 		wSurfPoint  = (Fixed32*)cBuf->coordView3D;
! 		wSurface    = obj->surface;
! 		wVertPoint  = obj->vertPoint;
! 
! 		for(i = 0; i < obj->surfaceCount; i++) {
! 		    j = wSurface->vertNo[0];
! 		    wVPoint = (Fixed32*)&wVertPoint[j];
! 		    *wSurfPoint++ = *wVPoint++;
! 		    *wSurfPoint++ = *wVPoint++;
! 		    *wSurfPoint++ = *wVPoint;
! 		    wSurface++;
! 		}
! 		wSurfaceVert = cBuf->coordView3D;
! 	    } else
! 		wSurfaceVert = obj->surfaceVert;
! 
! 	    /* 面法線テーブルから面輝度テーブルを得るためのパラメータセット */
! 	    polyTransParm.viewLight = &viewLight;
! 	    polyTransParm.surfCount = obj->surfaceCount;
! 	    polyTransParm.surfPoint = wSurfaceVert;
! 	    polyTransParm.surfNormal = obj->surfaceNormal;
! 	    polyTransParm.surfBright = cBuf->surfBright;
! 
! 	    /* 頂点データの視点座標変換後テーブルを得るためのパラメータセット*/
! 	    polyTransParm.transViewVertCount = obj->vertCount;
! 	    polyTransParm.transViewVertSrc = obj->vertPoint;
! 	    polyTransParm.transViewVertAns = cBuf->coordView3D;
! 
! 	    /* グーロー用頂点輝度テーブルを得るためのパラメータセット  */
! 	    if((obj->dispFlag & SHADING_MASK) == GOURAUD_SHADING) {
!                 if(obj->dispFlag & INBETWEEN_OBJECT) {
!   	            polyTransParm.gourVertCount = 0;
!   	            memcpy(cBuf->vertBright,obj->vertNormal,
!   	                                  obj->vertCount*sizeof(Sint32));
!                 } else {
! 	            polyTransParm.gourVertCount = obj->vertCount;
! 	            polyTransParm.vertNormal    = obj->vertNormal;
! 		    polyTransParm.vertBright    = cBuf->vertBright;
! 		}
!             } else
! 	        polyTransParm.gourVertCount = 0;
! 
! 	    /* 頂点データのワールド座標変換後テーブルを得るための
!                                                         パラメータセット*/
! 	    if(postWorldDataFlag) {
! 	        polyTransParm.transWorldVertCount = obj->vertCount;
! 	        polyTransParm.transWorldVertSrc   = obj->vertPoint;
! 	        polyTransParm.transWorldVertAns   = cBuf->coordWorld3D;
!             } else
! 	        polyTransParm.transWorldVertCount = 0;
! 
! 	    MTH_PolyDataTransExec(&polyTransParm);
! 
!             if(dbFirstFlag) {
! 		MTH_PolyDataTransCheck();
!                 if(cluster->transEnd)
!                     cluster->transEnd(cluster, obj, worldMatrixTbl.current,
!                                                          cBuf->coordWorld3D);
!             } else {
! 		/* ポリゴン描画コマンドの登録処理 */
!                 cBuf = &dBuf[bufSW^1];
! 		transPolygons(cBuf, coord2D);
! 		setInbetPolygons(cBuf);
! 		MTH_PolyDataTransCheck();
!                 if(cluster->transEnd) {
! 		    cBuf = &dBuf[bufSW];
!                     cluster->transEnd(cluster, obj, worldMatrixTbl.current,
!                                                          cBuf->coordWorld3D);
!                 }
!             }
! 
! 	    if(doubleBufFlag) {
! 		dbFirstFlag = 0;
!                 bufSW ^= 1;
! 	    } else {
!                 cBuf = &dBuf[bufSW];
! 		transPolygons(cBuf, coord2D);
!                 setInbetPolygons(cBuf);
!             }
! 
!             obj = obj->next;
! 
! 	}
! 
! 	/* 子クラスタの処理 */
! 	if(cluster->child) transCluster(cluster->child);
! 
! 	MTH_PopMatrix(&worldMatrixTbl);
!         cluster = cluster->next;
!     }
! }
! 
! 
! /*****************************************************************************
!  *
!  * NAME:  setInbetPolygons  - Set Inbetween Polygon Data to Inbet Object
!  *
!  * PARAMETERS :
!  *
!  *     (1) DoubleBufArea  *buf    - <i>  カレント座標変換バッファ
!  *
!  * DESCRIPTION:
!  *
!  *     ３Ｄオブジェクト間接続ポリゴン視点座標系頂点データの登録処理
!  *
!  *
!  * POSTCONDITIONS:
!  *
!  *     No exist.
!  *
!  * CAVEATS:
!  *
!  *****************************************************************************
!  */
! static void
! setInbetPolygons(DoubleBufArea *buf)
! {
!     Sint32       i;
!     SprObject3D  *inbetObj;
!     SprInbetInf  *wInbetInf;
!     MthXyz       *fromVertPoint;
!     Sint32       *fromVertBright;
!     Uint16       *fromVertNo;
!     MthXyz       *toVertPoint;
!     Sint32       *toVertBright;
!     Uint16       *toVertNo;
!     SprCluster   *cluster;
!     SprObject3D  *obj;
! 
!     /** BEGIN ***************************************************************/
!     cluster = buf->cluster;
!     obj     = buf->object;
! 
!     /*  ３Ｄオブジェクト間接続ポリゴン情報がある場合     */
!     if(cluster->inbetInf) {
! 	 wInbetInf = cluster->inbetInf;
! 	 while(wInbetInf) {
! 	     if(obj == wInbetInf->fromObj) {
! 		 fromVertPoint = cBuf->coordView3D;
! 		 fromVertNo    = wInbetInf->fromVertNo;
! 		 toVertPoint   = wInbetInf->toObj->vertPoint;
! 		 toVertNo      = wInbetInf->toVertNo;
! 		 for(i=0 ; i<wInbetInf->vertCount; i++)
! 		     toVertPoint[toVertNo[i]] = fromVertPoint[fromVertNo[i]];
! 		 toVertBright  = (Sint32*)wInbetInf->toObj->vertNormal;
! 		 if(toVertBright) {
! 		     fromVertBright = cBuf->vertBright;
! 		     for(i=0 ; i<wInbetInf->vertCount; i++)
! 		         toVertBright[toVertNo[i]] =
! 		                              fromVertBright[fromVertNo[i]];
! 		 }
!                  break;
!              }
!              wInbetInf = wInbetInf->next;
!          }
!     }
! }
! 
! 
! /*****************************************************************************
!  *
!  * NAME:  clip2DLevel2()  - Clip 2D Level 2
!  *
!  * PARAMETERS :
!  *
!  *     (1) PolTbl  *polTbl  - <i>  ２Ｄポリゴンテーブル
!  *
!  * DESCRIPTION:
!  *
!  *     ポリゴンの２Ｄクリッピング処理
!  *     スクリーンに掛からないポリゴンの削除
!  *
!  *
!  * POSTCONDITIONS:
!  *
!  *     int   rtncd          - <o>  リターンコード
!  *                                 １＝描画しない
!  *                                 ０＝描画する
!  *
!  * CAVEATS:
!  *
!  *****************************************************************************
!  */
! static int
! clip2DLevel2(PolTbl *polTbl)
! {
!     Uint32   f1,f2;
!     XyInt    *xy,*xyb;
!     Sint32   i;
! 
!     /** BEGIN ***************************************************************/
!     f1 = 0;
!     xy = polTbl->xy;
!     if(xy->x < clipScrXMin) f1 |= 8;
!     if(xy->x > clipScrXMax) f1 |= 4;
!     if(xy->y < clipScrYMin) f1 |= 2;
!     if(xy->y > clipScrYMax) f1 |= 1;
!     for(i=0; i<4; i++) {
! 	xyb = xy;
! 	if(i == 3)
! 	    xy -= 3;
! 	else
! 	    xy++;
! 	f2 = 0;
! 	if(xy->x < clipScrXMin) f2 |= 8;
! 	if(xy->x > clipScrXMax) f2 |= 4;
! 	if(xy->y < clipScrYMin) f2 |= 2;
! 	if(xy->y > clipScrYMax) f2 |= 1;
! 	if(!(f1 & f2)) {
! 	    if(!(f1 | f2)) return 0;
! 	    if(!clipScrCheck(xyb,xy,8)) return 0;
! 	}
! 	f1 = f2;
!     }
!     return 1;
! }
! 
! /*****************************************************************************
!  *
!  * NAME:  clipScrCheck()  - Clip Screen Detail Check
!  *
!  * PARAMETERS :
!  *
!  *     (1) XyInt     *xy1   - <i>  ライン始点
!  *     (2) XyInt     *xy2   - <i>  ライン終点
!  *     (2) Sint32    chkCnt - <i>  チェックカウンタ
!  *
!  * DESCRIPTION:
!  *
!  *     ラインの中点がスクリーン内に入っているか２分割法によりリカーシブに
!  *     チェックする。
!  *
!  *
!  * POSTCONDITIONS:
!  *
!  *     Sint32   ret         - <o>  リターンコード
!  *                                 ０＝スクリーン内に入っている
!  *                                 １＝入っていない
!  *
!  * CAVEATS:
!  *
!  *****************************************************************************
!  */
! static Sint32
! clipScrCheck(XyInt *xy1, XyInt *xy2, Sint32 chkCnt)
! {
!    Sint32       ret;
!    XyInt     xym;
! 
!    if(chkCnt <= 1) return 1;
!    xym.x = (xy1->x + xy2->x) >> 1;
!    if(xym.x & 0x4000) xym.x |= 0x8000;
!    xym.y = (xy1->y + xy2->y) >> 1;
!    if(xym.y & 0x4000) xym.y |= 0x8000;
!    if((clipScrXMin <= xym.x) && (xym.x <= clipScrXMax) &&
!       (clipScrYMin <= xym.y) && (xym.y <= clipScrYMax)) return 0;
!    switch(outcodeScr(xy1, &xym)) {
!       case -1 : /* just in */
!           return 0;
!       case  0 : /* nead detail check */
!           ret = clipScrCheck(xy1, &xym, chkCnt-1);
!           break;
!       case  1 : /* just out */
! 	  ret = clipScrCheck(&xym, xy2, chkCnt-1);
! 	  break;
!    }
!    return ret;
! }
! 
! static
! Sint32 outcodeScr(XyInt *xy1, XyInt *xy2)
! {
!    Uint32 f1, f2;
! 
!    f1 = f2 = 0;
!    if(xy1->x < clipScrXMin) f1 |= 8;
!    if(xy1->x > clipScrXMax) f1 |= 4;
!    if(xy1->y < clipScrYMin) f1 |= 2;
!    if(xy1->y > clipScrYMax) f1 |= 1;
!    if(xy2->x < clipScrXMin) f2 |= 8;
!    if(xy2->x > clipScrXMax) f2 |= 4;
!    if(xy2->y < clipScrYMin) f2 |= 2;
!    if(xy2->y > clipScrYMax) f2 |= 1;
!    if(f1 & f2)
!        return  1; /* just out          */
!    else
!    if(f1 | f2)
!        return  0; /* need detail check */
!    else
!        return -1; /* just in           */
! }
! 
! 
! /*****************************************************************************
!  *
!  * NAME:  clipFrmCheck()  - Clip Frame Buffer Detail Check
!  *
!  * PARAMETERS :
!  *
!  *     (1) XyInt  *xy1   - <i>  ライン始点
!  *     (2) XyInt  *xy2   - <i>  ライン終点
!  *     (2) Sint32    chkCnt - <i>  チェックカウンタ
!  *
!  * DESCRIPTION:
!  *
!  *     ラインの中点がフレームバッファ内に入っているか２分割法によりリカーシブに
!  *     チェックする。
!  *
!  *
!  * POSTCONDITIONS:
!  *
!  *     Sint32   ret         - <o>  リターンコード
!  *                                 ０＝スクリーン内に入っている
!  *                                 １＝入っていない
!  *
!  * CAVEATS:
!  *
!  *****************************************************************************
!  */
! static Sint32
! clipFrmCheck(XyInt *xy1, XyInt *xy2, Sint32 chkCnt)
! {
!    Sint32       ret;
!    XyInt     xym;
! 
!    if(chkCnt <= 1) return 1;
!    xym.x = (xy1->x + xy2->x) >> 1;
!    if(xym.x & 0x4000) xym.x |= 0x8000;
!    xym.y = (xy1->y + xy2->y) >> 1;
!    if(xym.y & 0x4000) xym.y |= 0x8000;
!    if((FRMBUF_MIN_X <= xym.x) && (xym.x <= FRMBUF_MAX_X) &&
!       (FRMBUF_MIN_Y <= xym.y) && (xym.y <= FRMBUF_MAX_Y)) return 0;
!    switch(outcodeFrm(xy1, &xym)) {
!       case -1 : /* just in */
!           return 0;
!       case  0 : /* nead detail check */
!           ret = clipFrmCheck(xy1, &xym, chkCnt-1);
! 	  break;
!       case  1 : /* just out */
!           ret = clipFrmCheck(&xym, xy2, chkCnt-1);
!           break;
!    }
!    return ret;
! }
! 
! static
! Sint32 outcodeFrm(XyInt *xy1, XyInt *xy2)
! {
!    Uint32 f1, f2;
! 
!    f1 = f2 = 0;
!    if(xy1->x < FRMBUF_MIN_X) f1 |= 8;
!    if(xy1->x > FRMBUF_MAX_X) f1 |= 4;
!    if(xy1->y < FRMBUF_MIN_Y) f1 |= 2;
!    if(xy1->y > FRMBUF_MAX_Y) f1 |= 1;
!    if(xy2->x < FRMBUF_MIN_X) f2 |= 8;
!    if(xy2->x > FRMBUF_MAX_X) f2 |= 4;
!    if(xy2->y < FRMBUF_MIN_Y) f2 |= 2;
!    if(xy2->y > FRMBUF_MAX_Y) f2 |= 1;
!    if(f1 & f2)
!        return  1; /* just out          */
!    else
!    if(f1 | f2)
!        return  0; /* need detail check */
!    else
!        return -1; /* just in           */
! }
! 
! 
! /*****************************************************************************
!  *
!  * NAME:  clip2DLevel3()  - Clip 2D Level 3
!  *
!  * PARAMETERS :
!  *
!  *     (1) PolTbl  *polTbl  - <i>  ２Ｄポリゴンテーブル
!  *
!  * DESCRIPTION:
!  *
!  *     ポリゴンの２Ｄクリッピング処理
!  *     フレームバッファの境界でクリップ
!  *
!  *
!  * POSTCONDITIONS:
!  *
!  *     int   rtncd          - <o>  リターンコード
!  *                                 １＝描画しない
!  *                                 ０＝描画する
!  *
!  * CAVEATS:
!  *
!  *****************************************************************************
!  */
! static int
! clip2DLevel3(PolTbl *polTbl)
! {
!     Uint32   f1,f2;
!     Sint32   i,justInCnt;
!     XyInt *xy, *xyb;
! 
!     /** BEGIN ***************************************************************/
!     f1 = 0;
!     xy = polTbl->xy;
!     justInCnt = 0;
!     if(xy->x < FRMBUF_MIN_X) f1 |= 8;
!     if(xy->x > FRMBUF_MAX_X) f1 |= 4;
!     if(xy->y < FRMBUF_MIN_Y) f1 |= 2;
!     if(xy->y > FRMBUF_MAX_Y) f1 |= 1;
!     for(i=0; i<4; i++) {
! 	xyb = xy;
! 	if(i == 3)
! 	    xy -= 3;
! 	else
! 	    xy++;
! 	f2 = 0;
! 	if(xy->x < FRMBUF_MIN_X) f2 |= 8;
! 	if(xy->x > FRMBUF_MAX_X) f2 |= 4;
! 	if(xy->y < FRMBUF_MIN_Y) f2 |= 2;
! 	if(xy->y > FRMBUF_MAX_Y) f2 |= 1;
! 	if(!(f1 & f2)) { /* just in or between */
! 	    if(!(f1 | f2))
! 		justInCnt++;
! 	    else
! 		if(!clipFrmCheck(xyb,xy,8))  return clipFrame(polTbl);
! 	}
! 	f1 = f2;
!     }
!     if(justInCnt >=  4)  return 0;
!     return 1;
! }
! 
! /*****************************************************************************
!  *
!  * NAME:  clipFrame()  - Clip Frame Buffer
!  *
!  * PARAMETERS :
!  *
!  *     (1) PolTbl  *polTbl  - <i/o>  ２Ｄポリゴンテーブル
!  *
!  * DESCRIPTION:
!  *
!  *     ポリゴンをフレームバッファ境界でクリッピングし、複数のポリゴン
!  *     を生成する
!  *
!  *
!  * POSTCONDITIONS:
!  *
!  *     int   rtncd          - <o>  リターンコード
!  *                                 １＝描画しない
!  *                                 ０＝描画する
!  *
!  * CAVEATS:
!  *
!  *****************************************************************************
!  */
! static int
! clipFrame(PolTbl *polTbl)
! {
!     Sint32   i, j, in, out, visible;
!     XyInt *pxy, *qxy, *wxy, w1xy[16], w2xy[16], fxy, sxy;
! 
!     /** BEGIN ***************************************************************/
!     pxy = polTbl->xy;          /* 入力多角形 */
!     qxy = w1xy;                /* 出力多角形 */
!     in  = 4;                   /* 入力頂点数 */
!     for(i=0; i<4; i++) {       /* フレームバッファ境界辺についてのループ */
! 	out = 0;               /* 出力頂点数 */
! 	for(j=0; j<in; j++) {  /* 表示多角形の辺についてのループ */
! 	    if(j == 0) {       /* 多角形の最初の点の場合 */
! 		fxy.x = pxy->x;
! 		fxy.y = pxy->y;
! 	    } else     {
! 		if(frmCrossChk(i,&sxy,&pxy[j],&qxy[out]))  out++;
! 	    }
! 	    sxy.x = pxy[j].x;
! 	    sxy.y = pxy[j].y;
! 	    visible = 0;
! 	    /* フレームバッファ境界の内側にポイントが入っているか可視チェック*/
! 	    switch(i) {
! 		case 0 : /* フレームバッファ左辺とのチェック */
! 		     if(FRMBUF_MIN_X <= sxy.x)  visible = 1;
! 		     break;
! 		case 1 : /* フレームバッファ上辺とのチェック */
! 		     if(FRMBUF_MIN_Y <= sxy.y)  visible = 1;
! 		     break;
! 		case 2 : /* フレームバッファ右辺との交差チェック */
! 		     if(sxy.x <= FRMBUF_MAX_X)  visible = 1;
! 		     break;
! 		case 3 : /* フレームバッファ下辺との交差チェック */
! 		     if(sxy.y <= FRMBUF_MAX_Y)  visible = 1;
! 		     break;
! 	    }
! 	    if(visible) {
! 		qxy[out].x = sxy.x;
! 		qxy[out].y = sxy.y;
! 		out++;
! 	    }
! 	}
! 	if(out) {    /* 最終辺についての処理 */
! 	    if(frmCrossChk(i,&sxy,&fxy,&qxy[out]))  out++;  /* 1 = cross */
! 	}
! 	in = out;
! 	if(i == 0) {
! 	    pxy = qxy;
! 	    qxy = w2xy;
! 	} else {
! 	    wxy = pxy;
! 	    pxy = qxy;
! 	    qxy = wxy;
! 	}
!     }
!     if(out >= 4) {   /* 多角形ポリゴンを４角形ポリゴンに分解 */
! 	qxy = pxy;
! 	wxy = polTbl->xy;
! 	for(i=0; i<4; i++,wxy++,qxy++) {
! 	    wxy->x = qxy->x;
! 	    wxy->y = qxy->y;
! 	}
! 	out -= 4;
! 	j = 1;
! 	qxy--;
! 	while(out) {
! 	    if(out >= 2) {
! 	       wxy  ->x = pxy  ->x;
! 	       wxy++->y = pxy  ->y;
! 	       wxy  ->x = qxy  ->x;
! 	       wxy++->y = qxy++->y;
! 	       wxy  ->x = qxy  ->x;
! 	       wxy++->y = qxy++->y;
! 	       wxy  ->x = qxy  ->x;
! 	       wxy++->y = qxy  ->y;
! 	       out -= 2;
! 	    } else       {
! 	       wxy  ->x = pxy  ->x;
! 	       wxy++->y = pxy  ->y;
! 	       wxy  ->x = qxy  ->x;
! 	       wxy++->y = qxy++->y;
! 	       wxy  ->x = qxy  ->x;
! 	       wxy++->y = qxy  ->y;
! 	       wxy  ->x = pxy  ->x;
! 	       wxy++->y = pxy  ->y;
! 	       out -= 1;
! 	    }
! 	    j++;
! 	}
! 	polTbl->polyCnt = j;
! 	return 0;
!     } else
!     if(out >= 3) {
! 	qxy = pxy;
! 	wxy = polTbl->xy;
! 	for(i=0; i<3; i++,wxy++,qxy++) {
! 	    wxy->x = qxy->x;
! 	    wxy->y = qxy->y;
! 	}
! 	wxy->x = pxy->x;
! 	wxy->y = pxy->y;
! 	return 0;
!     } else
! 	return 1;
! }
! 
! 
! /*****************************************************************************
!  *
!  * NAME:  frmCrossChk()  - Frame Buffer Cross Check
!  *
!  * PARAMETERS :
!  *
!  *     (1) int       frmNo  - <i>  フレームバッファ境界の辺番号
!  *                                 ０＝左辺
!  *                                 １＝上辺
!  *                                 ２＝右辺
!  *                                 ３＝下辺
!  *     (2) XyInt  *p1    - <i>  ラインのスタートポイント
!  *     (2) XyInt  *p2    - <i>  ラインのエンドポイント
!  *     (2) XyInt  *cp    - <o>  境界とラインのクロスポイント
!  *
!  *
!  * DESCRIPTION:
!  *
!  *     指定フレームバッファの境界と指定ラインが交差しているかチェックし、
!  *     交差している場合その交点を返す
!  *
!  *
!  * POSTCONDITIONS:
!  *
!  *     int   rtncd          - <o>  リターンコード
!  *                                 １＝交差している
!  *                                 ０＝交差していない
!  *
!  * CAVEATS:
!  *
!  *****************************************************************************
!  */
! static int
! frmCrossChk(int frmNo, XyInt *p1, XyInt *p2, XyInt *cp)
! {
!     Sint32   w1, w2, w3;
! 
!     /** BEGIN ***************************************************************/
!     switch(frmNo) {
! 	case 0 : /* フレームバッファ左辺との交差チェック */
! 	     w1 = FRMBUF_MIN_X - p1->x;
! 	     w2 = FRMBUF_MIN_X - p2->x;
! 	     if((w1 * w2) >= 0)  return 0;
! 	     w3 = p2->x - p1->x;
! 	     if(w3 == 0) return 0;
! 	     cp->x = FRMBUF_MIN_X;
! 	     cp->y = p1->y + ((Sint32)(p2->y - p1->y)) * w1 / w3;
!           /* if(cp->y < FRMBUF_MIN_Y) cp->y = FRMBUF_MIN_Y; else
!              if(cp->y > FRMBUF_MAX_Y) cp->y = FRMBUF_MAX_Y; */
! 	     break;
! 	case 1 : /* フレームバッファ上辺との交差チェック */
! 	     w1 = FRMBUF_MIN_Y - p1->y;
! 	     w2 = FRMBUF_MIN_Y - p2->y;
! 	     if((w1 * w2) >= 0)  return 0;
! 	     w3 = p2->y - p1->y;
! 	     if(w3 == 0) return 0;
! 	     cp->x = p1->x + ((Sint32)(p2->x - p1->x)) * w1 / w3;
! 	     cp->y = FRMBUF_MIN_Y;
!           /* if(cp->x < FRMBUF_MIN_X) cp->x = FRMBUF_MIN_X; else
!              if(cp->x > FRMBUF_MAX_X) cp->x = FRMBUF_MAX_X; */
! 	     break;
! 	case 2 : /* フレームバッファ右辺との交差チェック */
! 	     w1 = FRMBUF_MAX_X - p1->x;
! 	     w2 = FRMBUF_MAX_X - p2->x;
! 	     if((w1 * w2) >= 0)  return 0;
! 	     w3 = p2->x - p1->x;
! 	     if(w3 == 0) return 0;
! 	     cp->x = FRMBUF_MAX_X;
! 	     cp->y = p1->y + ((Sint32)(p2->y - p1->y)) * w1 / w3;
!           /* if(cp->y < FRMBUF_MIN_Y) cp->y = FRMBUF_MIN_Y; else
!              if(cp->y > FRMBUF_MAX_Y) cp->y = FRMBUF_MAX_Y; */
! 	     break;
! 	case 3 : /* フレームバッファ下辺との交差チェック */
! 	     w1 = FRMBUF_MAX_Y - p1->y;
! 	     w2 = FRMBUF_MAX_Y - p2->y;
! 	     if((w1 * w2) >= 0)  return 0;
! 	     w3 = p2->y - p1->y;
! 	     if(w3 == 0) return 0;
! 	     cp->x = p1->x + ((Sint32)(p2->x - p1->x)) * w1 / w3;
! 	     cp->y = FRMBUF_MAX_Y;
!           /* if(cp->x < FRMBUF_MIN_X) cp->x = FRMBUF_MIN_X; else
!              if(cp->x > FRMBUF_MAX_X) cp->x = FRMBUF_MAX_X; */
! 	     break;
!     }
!     return 1;
! }
! 
! 
! /*****************************************************************************
!  *
!  * NAME:  transPolygons  - Set Polygon Data to polTbl
!  *
!  * PARAMETERS :
!  *
!  *     (1) DoubleBufArea  *buf    - <i>  カレント座標変換バッファ
!  *     (12 XyInt          *vert2d - <O>  ２Ｄ座標保存ワークエリア
!  *
!  * DESCRIPTION:
!  *
!  *     ポリゴン描画コマンドの登録処理
!  *
!  *
!  * POSTCONDITIONS:
!  *
!  *     No exist.
!  *
!  * CAVEATS:
!  *
!  *****************************************************************************
!  */
! static void
! transPolygons(DoubleBufArea *buf, XyInt *vert2d)
! {
!     Sint32     i, j;
!     Sint32     shadingKind, mateKind, bothFace, dispFlag, sBright;
!     Uint32     zSortKind;
!     Sint32     *wSurfBright, *vertBright, l;
!     SprSurface *wSurface;
!     SprObject3D *obj;
!     PolTbl     polTbl;
!     Uint16     *gour, w;
!     Uint16     *wVertNo;
!     Uint16     *shadingTbl;
!     XyInt      *wxy;
!     MthXyz     xyz[4], *wxyz, *coordView3D;
!     Fixed32    zMax, *wFix1, *wFix2;
! 
!     static Uint16    grayCode[32] = {
!         RGB16_COLOR( 0, 0, 0), RGB16_COLOR( 1, 1, 1),
!         RGB16_COLOR( 2, 2, 2), RGB16_COLOR( 3, 3, 3),
!         RGB16_COLOR( 4, 4, 4), RGB16_COLOR( 5, 5, 5),
!         RGB16_COLOR( 6, 6, 6), RGB16_COLOR( 7, 7, 7),
!         RGB16_COLOR( 8, 8, 8), RGB16_COLOR( 9, 9, 9),
!         RGB16_COLOR(10,10,10), RGB16_COLOR(11,11,11),
!         RGB16_COLOR(12,12,12), RGB16_COLOR(13,13,13),
!         RGB16_COLOR(14,14,14), RGB16_COLOR(15,15,15),
!         RGB16_COLOR(16,16,16), RGB16_COLOR(17,17,17),
!         RGB16_COLOR(18,18,18), RGB16_COLOR(19,19,19),
!         RGB16_COLOR(20,20,20), RGB16_COLOR(21,21,21),
!         RGB16_COLOR(22,22,22), RGB16_COLOR(23,23,23),
!         RGB16_COLOR(24,24,24), RGB16_COLOR(25,25,25),
!         RGB16_COLOR(26,26,26), RGB16_COLOR(27,27,27),
!         RGB16_COLOR(28,28,28), RGB16_COLOR(29,29,29),
!         RGB16_COLOR(30,30,30), RGB16_COLOR(31,31,31)
!     };
! 
!     static Uint16    texGrayCode[32] = {
!         RGB16_COLOR( 8, 8, 8), RGB16_COLOR( 8, 8, 8),
!         RGB16_COLOR( 9, 9, 9), RGB16_COLOR( 9, 9, 9),
!         RGB16_COLOR(10,10,10), RGB16_COLOR(10,10,10),
!         RGB16_COLOR(11,11,11), RGB16_COLOR(11,11,11),
!         RGB16_COLOR(12,12,12), RGB16_COLOR(12,12,12),
!         RGB16_COLOR(13,13,13), RGB16_COLOR(13,13,13),
!         RGB16_COLOR(14,14,14), RGB16_COLOR(14,14,14),
!         RGB16_COLOR(15,15,15), RGB16_COLOR(15,15,15),
!         RGB16_COLOR(16,16,16), RGB16_COLOR(16,16,16),
!         RGB16_COLOR(17,17,17), RGB16_COLOR(17,17,17),
!         RGB16_COLOR(18,18,18), RGB16_COLOR(18,18,18),
!         RGB16_COLOR(19,19,19), RGB16_COLOR(19,19,19),
!         RGB16_COLOR(20,20,20), RGB16_COLOR(20,20,20),
!         RGB16_COLOR(21,21,21), RGB16_COLOR(21,21,21),
!         RGB16_COLOR(22,22,22), RGB16_COLOR(22,22,22),
!         RGB16_COLOR(23,23,23), RGB16_COLOR(23,23,23),
!     };
! 
!     /** BEGIN ***************************************************************/
!     obj         = buf->object;
!     coordView3D = buf->coordView3D;
!     vertBright  = buf->vertBright;
!     wSurfBright = buf->surfBright;
!     wSurface    = obj->surface;
!     shadingKind = obj->dispFlag & SHADING_MASK;
!     bothFace    = obj->dispFlag & BOTH_FACE;
!     wxy         = vert2d;
!     for(i=0; i < obj->vertCount; i++) {
! 	wxy->x = 0x7fff;
! 	wxy++;
!     }
! 
!     for(i = 0; i < obj->surfaceCount; i++, wSurfBright++, wSurface++) {
! 	sBright = *wSurfBright & 0xff;
! 	dispFlag = 1;
! 	if(*wSurfBright & 0x80000000)
! 	    if(bothFace) {
! 	       sBright = 31 - sBright;
! 	       dispFlag = 2;
! 	    } else
! 	       dispFlag = 0;
! 
!  /* *(Sint32*)0x6060008 += 1; */ /* ### */
! 	if(dispFlag) {
!  /* *(Sint32*)0x606000c += 1; */ /* ### */
! 	    /* 頂点データの取り出し */
! 	    wVertNo  = wSurface->vertNo;
! 	    wFix1 = (Fixed32*)xyz;
! 	    for(j = 0; j < 4; j++, wVertNo++) {
! 		wFix2 = (Fixed32*)&coordView3D[*wVertNo];
! 		*wFix1++ = *wFix2++;   /* X */
! 		*wFix1++ = *wFix2++;   /* Y */
! 		*wFix1++ = *wFix2;     /* Z */
! 	    }
! 
! 	    /* 代表Ｚ値による３Ｄクリッピング */
! 	    zMax = MAX(MAX(MAX(xyz[0].z,xyz[1].z),xyz[2].z),xyz[3].z);
! 	    if(clipLevel > 0)
! 		if((zMax < clipZMin) || (zMax > clipZMax)) continue;
! 
! 	    /* 代表Ｚ値の取り出し */
! 	    zSortKind = wSurface->drawMode & ZSORT_MASK;
! 	    if(zSortKind == ZSORT_MIN)
! 		polTbl.z = MIN(MIN(MIN(xyz[0].z,xyz[1].z),xyz[2].z),xyz[3].z);
! 	    else
! 	    if(zSortKind == ZSORT_MAX)
! 		polTbl.z = zMax;
! 	    else
! 		polTbl.z = MTH_Mul(xyz[0].z+xyz[1].z+xyz[2].z+xyz[3].z,
! 		                   MTH_FIXED(0.25));
! 
! 	    /* 透視変換 */
! 	    wVertNo = wSurface->vertNo;
! 	    wxyz    = xyz;
! 	    wxy     = polTbl.xy;
! 	    for(j = 0; j < 4; j++, wVertNo++) {
! 		if(vert2d[*wVertNo].x != 0x7fff) {
! 		    wxy->x = vert2d[*wVertNo].x;
! 		    wxy->y = vert2d[*wVertNo].y;
! 		} else {
! 		    MTH_Pers2D(wxyz, &unitPixel, wxy);
! 		    coord2D[*wVertNo].x = wxy->x;
! 		    coord2D[*wVertNo].y = wxy->y;
! 		}
! 		wxyz++;
! 		wxy++;
! 	    }
! 
! 	    /* ２Ｄクリッピング */
! 	    polTbl.polyCnt = 1;
! 	    if(clipLevel == 2) {
! 		if(clip2DLevel2(&polTbl)) continue;
! 	    } else
! 	    if(clipLevel == 3) {
! 		if(clip2DLevel3(&polTbl)) continue;
! 	    }
! 
! 	    if(shadingKind == GOURAUD_SHADING) {
! 		gour    = (Uint16*)&polTbl.gourTbl;
! 		wVertNo = wSurface->vertNo;
! 		if(obj->shdIdxTbl)
! 		    shadingTbl = obj->shdIdxTbl[0];
! 		else
! 		    shadingTbl = grayCode;
!                 if(dispFlag == 1) {
! 		    *gour++ = shadingTbl[vertBright[*wVertNo++]];
! 		    *gour++ = shadingTbl[vertBright[*wVertNo++]];
! 		    *gour++ = shadingTbl[vertBright[*wVertNo++]];
! 		    *gour   = shadingTbl[vertBright[*wVertNo  ]];
!                 } else {
! 		    *gour++ = shadingTbl[31 - vertBright[*wVertNo++]];
! 		    *gour++ = shadingTbl[31 - vertBright[*wVertNo++]];
! 		    *gour++ = shadingTbl[31 - vertBright[*wVertNo++]];
! 		    *gour   = shadingTbl[31 - vertBright[*wVertNo  ]];
!                 }
! 	    }
! 
! 	    polTbl.dispFlag = obj->dispFlag;
!             mateKind = wSurface->drawMode & MATE_MASK;
! 	    if(shadingKind == FLAT_SHADING) {
! 		if(mateKind == MATE_SHADING_TBL) {
! 		    shadingTbl = obj->shdIdxTbl[wSurface->color];
! 		    polTbl.surfBright = shadingTbl[sBright];
! 		} else
! 		if(mateKind == MATE_TEXTURE) {
! 		    gour    = (Uint16*)&polTbl.gourTbl;
! 		    if(obj->shdIdxTbl) {
! 		        shadingTbl = obj->shdIdxTbl[0];
! 		        w = shadingTbl[sBright];
! 		    } else
! 		        w = texGrayCode[sBright];
! 		    *gour++ = w;
! 		    *gour++ = w;
! 		    *gour++ = w;
! 		    *gour   = w;
! 		} else {
! 		    polTbl.surfBright =
! 			    SPR_3GetShdColor(wSurface->color,sBright);
! 		}
! 	    }
! 	    polTbl.drawMode   = wSurface->drawMode;
! 	    polTbl.color      = wSurface->color;
! 
! 	    drawPol(&polTbl);
! 	}
!     }
! }
! 
! 
! /*****************************************************************************
!  *
!  * NAME:  viewCoordMatrix()  - set View Coord Convert Matrix To
!  *                                                    current matrix
!  *
!  * PARAMETERS :
!  *
!  * 　　なし
!  *
!  *
!  * DESCRIPTION:
!  *
!  *     カレントマトリックスに視点座標系への変換マトリックスをセット
!  *
!  *
!  * POSTCONDITIONS:
!  *
!  *     No exist.
!  *
!  * CAVEATS:
!  *
!  *****************************************************************************
! */
! static void viewCoordMatrix(void)
! {
!     MTH_InitialMatrix(&viewMatrixTbl, 1, &viewMatrix);
!     MTH_ReverseZ(&viewMatrixTbl);
!     MTH_MoveMatrix(&viewMatrixTbl, viewCoordPoint.x,
! 				   viewCoordPoint.y,
! 				   viewCoordPoint.z);
!     switch(viewAngleSeq) {
!         case ROT_SEQ_ZYX :
!    	     MTH_RotateMatrixX(&viewMatrixTbl, -viewAngle.x);
! 	     MTH_RotateMatrixY(&viewMatrixTbl, -viewAngle.y);
! 	     MTH_RotateMatrixZ(&viewMatrixTbl,  viewAngle.z);
! 	     break;
!         case ROT_SEQ_ZXY :
! 	     MTH_RotateMatrixY(&viewMatrixTbl, -viewAngle.y);
! 	     MTH_RotateMatrixX(&viewMatrixTbl, -viewAngle.x);
! 	     MTH_RotateMatrixZ(&viewMatrixTbl,  viewAngle.z);
! 	     break;
!         case ROT_SEQ_YZX :
! 	     MTH_RotateMatrixX(&viewMatrixTbl, -viewAngle.x);
! 	     MTH_RotateMatrixZ(&viewMatrixTbl,  viewAngle.z);
! 	     MTH_RotateMatrixY(&viewMatrixTbl, -viewAngle.y);
! 	     break;
!         case ROT_SEQ_YXZ :
!              MTH_RotateMatrixZ(&viewMatrixTbl,  viewAngle.z);
! 	     MTH_RotateMatrixX(&viewMatrixTbl, -viewAngle.x);
! 	     MTH_RotateMatrixY(&viewMatrixTbl, -viewAngle.y);
! 	     break;
!         case ROT_SEQ_XYZ :
!   	     MTH_RotateMatrixZ(&viewMatrixTbl,  viewAngle.z);
! 	     MTH_RotateMatrixY(&viewMatrixTbl, -viewAngle.y);
! 	     MTH_RotateMatrixX(&viewMatrixTbl, -viewAngle.x);
! 	     break;
!         case ROT_SEQ_XZY :
! 	     MTH_RotateMatrixY(&viewMatrixTbl, -viewAngle.y);
! 	     MTH_RotateMatrixZ(&viewMatrixTbl,  viewAngle.z);
! 	     MTH_RotateMatrixX(&viewMatrixTbl, -viewAngle.x);
! 	     break;
!     }
!     MTH_MoveMatrix(&viewMatrixTbl, -viewPoint.x, -viewPoint.y, -viewPoint.z);
!     MTH_NormalTrans(&viewMatrix, &worldLightVector, &viewLight.lightVector);
!     if(postWorldDataFlag) {
!         MTH_ClearMatrix(&worldMatrixTbl);
!     } else {
! 	memcpy(worldMatrixTbl.current, &viewMatrix, sizeof(MthMatrix));
!     }
! 
! }
! 
! 
! /*****************************************************************************
!  *
!  * NAME:  lightAngle()  -
!  *
!  * PARAMETERS :
!  *
!  * 　　MthXyz *lightAngle
!  *
!  *
!  * DESCRIPTION:
!  *
!  *     光源のアングルを設定する
!  *
!  *
!  * POSTCONDITIONS:
!  *
!  *     No exist.
!  *
!  * CAVEATS:
!  *
!  *****************************************************************************
! */
! static void setLightAngle(void)
! {
!     MTH_InitialMatrix(&lightMatrixTbl, 1, &lightMatrix);
!     MTH_RotateMatrixZ(&lightMatrixTbl, lightAngle.z);
!     MTH_RotateMatrixY(&lightMatrixTbl, lightAngle.y);
!     MTH_RotateMatrixX(&lightMatrixTbl, lightAngle.x);
!     MTH_NormalTrans(&lightMatrix, &orgLightVect, &worldLightVector);
! }
! 
! /*  end of file */
diff -crB --binary sbl6/segasmp/bup/font/fnt_cod1.c sbl6_patch/segasmp/bup/font/fnt_cod1.c
*** sbl6/segasmp/bup/font/fnt_cod1.c	1996-02-08 05:26:36.000000000 -0500
--- sbl6_patch/segasmp/bup/font/fnt_cod1.c	2021-12-18 11:44:08.000000000 -0500
***************
*** 1,3 ****
--- 1,5 ----
+ #include <string.h>
+ 
  #include	<sega_xpt.h>
  
  #define		FNT_JAPAN	1
***************
*** 89,95 ****
  #ifndef __GNUC__
  	if(wx > FntXsize)	wx = FntXsize/2 - strlen(str)*4;
  #else
! 	if(wx > FntXsize)	wx = FntXsize/2 - strlen((Uint8 *)str)*4;
  #endif
  
  	i=0;
--- 91,97 ----
  #ifndef __GNUC__
  	if(wx > FntXsize)	wx = FntXsize/2 - strlen(str)*4;
  #else
! 	if(wx > FntXsize)	wx = FntXsize/2 - strlen((const char *)str)*4;
  #endif
  
  	i=0;
***************
*** 118,121 ****
  		i++;
  	}
  }
! 
\ No newline at end of file
--- 120,123 ----
  		i++;
  	}
  }
! 
diff -crB --binary sbl6/segasmp/bup/smpbup1.c sbl6_patch/segasmp/bup/smpbup1.c
*** sbl6/segasmp/bup/smpbup1.c	1996-02-08 05:26:38.000000000 -0500
--- sbl6_patch/segasmp/bup/smpbup1.c	2021-12-18 11:31:22.000000000 -0500
***************
*** 20,27 ****
  #include	"sega_scl.h"
  #include	"sega_per.h"
  #include	"sega_bup.h"
! #include	"..\v_blank\v_blank.h"
! #include	"font\smp_font.h"
  
  #define 	BUP_START_ADDR	0x6070000
  
--- 20,27 ----
  #include	"sega_scl.h"
  #include	"sega_per.h"
  #include	"sega_bup.h"
! #include	"v_blank/v_blank.h"
! #include	"font/smp_font.h"
  
  #define 	BUP_START_ADDR	0x6070000
  
***************
*** 73,79 ****
  	"SAT"
  };
  
! void main(void)
  {
  /* #if !(__GNUC__) */
  #ifndef __GNUC__
--- 73,79 ----
  	"SAT"
  };
  
! int main(void)
  {
  /* #if !(__GNUC__) */
  #ifndef __GNUC__
***************
*** 433,438 ****
--- 433,440 ----
  			PadInputWait();
  			break;
  	}
+ 
+ 	return 0;
  }
  
  
***************
*** 865,868 ****
  
  	return(ret);
  }
! 
\ No newline at end of file
--- 867,870 ----
  
  	return(ret);
  }
! 
diff -crB --binary sbl6/segasmp/csh/smpcsh.c sbl6_patch/segasmp/csh/smpcsh.c
*** sbl6/segasmp/csh/smpcsh.c	1996-02-08 05:28:00.000000000 -0500
--- sbl6_patch/segasmp/csh/smpcsh.c	2021-12-18 11:30:38.000000000 -0500
***************
*** 1,13 ****
  #include "sega_xpt.h"
  #include "sega_csh.h"
  
! void main(void)
  {
  	CSH_Init(CSH_4WAY);
  	CSH_AllClr();
! 	CSH_Purge((volatile void *)0x06000008, (Uint32)0x10);
  
  	while(1)
  		;
  }
! 
\ No newline at end of file
--- 1,14 ----
  #include "sega_xpt.h"
  #include "sega_csh.h"
  
! int main(void)
  {
  	CSH_Init(CSH_4WAY);
  	CSH_AllClr();
! 	CSH_Purge((void *)0x06000008, (Uint32)0x10);
  
  	while(1)
  		;
+ 	return 0;
  }
! 
diff -crB --binary sbl6/segasmp/dbg/smpdbg1/smpdbg10.c sbl6_patch/segasmp/dbg/smpdbg1/smpdbg10.c
*** sbl6/segasmp/dbg/smpdbg1/smpdbg10.c	1996-02-08 05:28:04.000000000 -0500
--- sbl6_patch/segasmp/dbg/smpdbg1/smpdbg10.c	2021-12-18 11:37:54.000000000 -0500
***************
*** 12,17 ****
--- 12,18 ----
  
  #include	<stdio.h>
  #include	<stdlib.h>
+ #include	<string.h>
  #include	<machine.h>
  
  #define		_SPR2_
***************
*** 322,328 ****
  extern Uint16	PadData1;
  #endif
  
! void main()
  {
      Uint8  *VRAM;
      int    i, j, l;
--- 323,329 ----
  extern Uint16	PadData1;
  #endif
  
! int main(void)
  {
      Uint8  *VRAM;
      int    i, j, l;
***************
*** 378,384 ****
          if(val == 99)
              *(Uint32*)0x6000001 = val; /* cause program error */
      }
  }
  
  /*  end of file */
! 
\ No newline at end of file
--- 379,386 ----
          if(val == 99)
              *(Uint32*)0x6000001 = val; /* cause program error */
      }
+     return 0;
  }
  
  /*  end of file */
! 
diff -crB --binary sbl6/segasmp/dma/smpdma0/smpdma0.c sbl6_patch/segasmp/dma/smpdma0/smpdma0.c
*** sbl6/segasmp/dma/smpdma0/smpdma0.c	1996-02-08 05:28:08.000000000 -0500
--- sbl6_patch/segasmp/dma/smpdma0/smpdma0.c	2021-12-18 11:46:30.000000000 -0500
***************
*** 16,25 ****
  void SDMA_CpuAllStart(void);
  void SDMA_CpuCst(Uint32 , Uint32 ,void *, void *, Uint32);
  Uint32 SDMA_CpuResult(Uint32);
! Uint32 hikaku(void *, void *, Uint32, Uint32, Sint8 *); /*  結果確認関数    */
  void rev(void *, void *, Uint32, Uint32);   /*  転送先データ破壊関数        */
  
! void main(void)
  {
      void *src, *dst;
      Uint32 cnt;
--- 16,25 ----
  void SDMA_CpuAllStart(void);
  void SDMA_CpuCst(Uint32 , Uint32 ,void *, void *, Uint32);
  Uint32 SDMA_CpuResult(Uint32);
! Uint32 hikaku(void *, void *, Uint32, Uint32, char *); /*  結果確認関数    */
  void rev(void *, void *, Uint32, Uint32);   /*  転送先データ破壊関数        */
  
! int main(void)
  {
      void *src, *dst;
      Uint32 cnt;
***************
*** 55,60 ****
--- 55,62 ----
      hikaku((void *)0x00000, (void *)0x6050000, 0x400, 1, "BOOT to WORK");
  
      for(;;);
+     
+     return 0;
  }
  /****************************************************************************/
  /*  全チャネルDMA開始                                                       */
***************
*** 140,146 ****
  /****************************************************************************/
  /*  結果比較関数                                                            */
  /****************************************************************************/
! Uint32 hikaku(void *src, void *dst, Uint32 cnt, Uint32 size, Sint8 *msg)
  {
  #if	0
  	/*
--- 142,148 ----
  /****************************************************************************/
  /*  結果比較関数                                                            */
  /****************************************************************************/
! Uint32 hikaku(void *src, void *dst, Uint32 cnt, Uint32 size, char *msg)
  {
  #if	0
  	/*
***************
*** 162,168 ****
      sprintf(pbuf, "[[ \'%s\' %08X >> %08X : %08X Count, %01X Byte ",
       msg, src, dst, cnt, size);
  #else
!     sprintf(pbuf, "[[ \'%s\' %08lX >> %08lX : %08lX Count, %01lX Byte ",
       msg, ( Uint32 )src, ( Uint32 )dst, cnt, size);
  #endif
      pbuf += strlen(pbuf);
--- 164,170 ----
      sprintf(pbuf, "[[ \'%s\' %08X >> %08X : %08X Count, %01X Byte ",
       msg, src, dst, cnt, size);
  #else
!     sprintf((const char *)pbuf, "[[ \'%s\' %08lX >> %08lX : %08lX Count, %01lX Byte ",
       msg, ( Uint32 )src, ( Uint32 )dst, cnt, size);
  #endif
      pbuf += strlen(pbuf);
***************
*** 308,311 ****
  /****************************************************************************/
  /*  End of File                                                             */
  /****************************************************************************/
! 
\ No newline at end of file
--- 310,313 ----
  /****************************************************************************/
  /*  End of File                                                             */
  /****************************************************************************/
! 
diff -crB --binary sbl6/segasmp/spr/smpspr2/smpspr20.c sbl6_patch/segasmp/spr/smpspr2/smpspr20.c
*** sbl6/segasmp/spr/smpspr2/smpspr20.c	1996-02-08 05:33:26.000000000 -0500
--- sbl6_patch/segasmp/spr/smpspr2/smpspr20.c	2021-12-18 17:29:08.000000000 -0500
***************
*** 20,29 ****
  
  #include	<stdio.h>
  #include	<stdlib.h>
  
  #define		_SPR2_
  #include        "sega_spr.h"
! #include        "sega_dbg.h"
  #include        "sega_per.h"
  
  #include	<machine.h>
--- 20,30 ----
  
  #include	<stdio.h>
  #include	<stdlib.h>
+ #include	<string.h>
  
  #define		_SPR2_
  #include        "sega_spr.h"
! //#include        "sega_dbg.h"
  #include        "sega_per.h"
  
  #include	<machine.h>
***************
*** 862,868 ****
  };
  
  
! void main()
  {
      Uint8  *VRAM;
      Uint16 *colAddr;
--- 863,869 ----
  };
  
  
! int main(void)
  {
      Uint8  *VRAM;
      Uint16 *colAddr;
***************
*** 984,990 ****
          }
          SCL_DisplayFrame();
      }
  }
  
  /*  end of file */
! 
\ No newline at end of file
--- 985,993 ----
          }
          SCL_DisplayFrame();
      }
+ 
+     return 0;
  }
  
  /*  end of file */
! 
diff -crB --binary sbl6/segasmp/v_blank/set_vb.c sbl6_patch/segasmp/v_blank/set_vb.c
*** sbl6/segasmp/v_blank/set_vb.c	1996-02-08 05:34:02.000000000 -0500
--- sbl6_patch/segasmp/v_blank/set_vb.c	2021-04-21 19:17:26.000000000 -0400
***************
*** 1,27 ****
! /*----------------------------------------------------------------------------
!  *  Set_VB.c -- V-Blank割り込みルーチンの登録
!  *  Copyright(c) 1994 SEGA
!  *  Written by K.M on 1994-05-16 Ver.0.90
!  *  Updated by K.M on 1994-10-04 Ver.1.02
!  *----------------------------------------------------------------------------
!  */
! 
! #include	<sega_xpt.h>
! #include	<sega_int.h>
! #include	"per_x.h"
! 
! void	UsrVblankIn( void );
! void	UsrVblankOut( void );
! extern SysPort	*__port;
! 
! void	SetVblank( void ){
! 	
! 	__port = PER_OpenPort();
! 	
! 	/* V-Blank割り込みルーチンの登録 */
! 	INT_ChgMsk(INT_MSK_NULL,INT_MSK_VBLK_IN | INT_MSK_VBLK_OUT);
! 	INT_SetScuFunc(INT_SCU_VBLK_IN,UsrVblankIn);
! 	INT_SetScuFunc(INT_SCU_VBLK_OUT,UsrVblankOut);
! 	INT_ChgMsk(INT_MSK_VBLK_IN | INT_MSK_VBLK_OUT,INT_MSK_NULL);
! }
! 
\ No newline at end of file
--- 1,46 ----
! /*----------------------------------------------------------------------------
!  *  Set_VB.c -- V-Blank割り込みルーチンの登録
!  *  Copyright(c) 1994 SEGA
!  *  Written by K.M on 1994-05-16 Ver.0.90
!  *  Updated by K.M on 1994-10-04 Ver.1.02
!  *----------------------------------------------------------------------------
!  */
! 
! #include <sega_xpt.h>
! #include <sega_int.h>
! #include <sega_per.h>
! 
! extern	void  UsrVblankStart(void);
! extern	void  UsrVblankEnd(void);
! 
! extern	Uint32	PadWorkArea[7];
! 
! volatile Sint32	perFlag;
! 
! void   CheckVblankEnd(void);
! 
! void SetVblank(void)
! {
! 	/* V_Blank Out 割り込みを待つ */
! 	
! 	INT_ChgMsk(INT_MSK_NULL,INT_MSK_VBLK_IN | INT_MSK_VBLK_OUT);
! 	INT_SetScuFunc(INT_SCU_VBLK_OUT,CheckVblankEnd);
! 	INT_ChgMsk(INT_MSK_VBLK_OUT,INT_MSK_NULL);
! 
! 	perFlag = 1;
! 	while(perFlag);
!     
! 	PER_Init(PER_KD_PERTIM,2,PER_ID_DGT,PER_SIZE_DGT,PadWorkArea,0);
! 
! 	/* V-Blank割り込みルーチンの登録 */
! 	INT_ChgMsk(INT_MSK_NULL,INT_MSK_VBLK_IN | INT_MSK_VBLK_OUT);
! 	INT_SetScuFunc(INT_SCU_VBLK_IN,UsrVblankStart);
! 	INT_SetScuFunc(INT_SCU_VBLK_OUT,UsrVblankEnd);
! 	INT_ChgMsk(INT_MSK_VBLK_IN | INT_MSK_VBLK_OUT,INT_MSK_NULL);
! }
! 
! 
! void   CheckVblankEnd(void)
! {
! 	perFlag = 0;
! }
diff -crB --binary sbl6/segasmp/v_blank/v_blank.c sbl6_patch/segasmp/v_blank/v_blank.c
*** sbl6/segasmp/v_blank/v_blank.c	1996-02-08 05:34:02.000000000 -0500
--- sbl6_patch/segasmp/v_blank/v_blank.c	2021-11-21 14:22:26.000000000 -0500
***************
*** 19,31 ****
  volatile trigger_t	PadData1E = 0x0000;
  volatile trigger_t	PadData2  = 0x0000;
  volatile trigger_t	PadData2E = 0x0000;
! SysPort	*__port = NULL;
  
  void	UsrVblankIn( void ){
  	SCL_VblankStart();
  }
  
! void   UsrVblankOut( void ){
  	SCL_VblankEnd();
  	
  	if( __port != NULL ){
--- 19,60 ----
  volatile trigger_t	PadData1E = 0x0000;
  volatile trigger_t	PadData2  = 0x0000;
  volatile trigger_t	PadData2E = 0x0000;
! //SysPort	*__port = NULL;
! 
! Uint32	PadWorkArea[7];
! 
  
  void	UsrVblankIn( void ){
  	SCL_VblankStart();
  }
  
! void   UsrVblankStart(void)
! {
! 	/* グラフィックライブラリを使用する為には実行しなければならない */
! 	SCL_VblankStart();
! }
! 
! 
! void   UsrVblankEnd(void)
! {
! 	PerDgtInfo	*pad;
! 
! 	/* グラフィックライブラリを使用する為には実行しなければならない */
! 	SCL_VblankEnd();
! 
! 	/* パッドデータ取得 */
! 
! 	PER_GetPer((PerGetPer **)&pad);
! 	if( pad != NULL ){
! 		PadData1   = pad[0].data ^ 0xffff;
! 		PadData1E |= pad[0].push ^ 0xffff;
! 		PadData2   = pad[1].data ^ 0xffff;
! 		PadData2E |= pad[1].push ^ 0xffff;
! 	}
! 
! }
! 
! /*void   UsrVblankOut( void ){
  	SCL_VblankEnd();
  	
  	if( __port != NULL ){
***************
*** 55,59 ****
  			PadData2 = PadData2E = 0;
  		}
  	}
! }
! 
\ No newline at end of file
--- 84,88 ----
  			PadData2 = PadData2E = 0;
  		}
  	}
! }*/
! 
